[
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)",
    "source": "ds-slide00_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 1,
      "page_heading": "",
      "images": [
        "ds-slide00/images/0_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0001"
  },
  {
    "type": "강의자료",
    "text": "## 자료구조란 \n\n● 프로그램은 각종 데이터를 처리함 \n\n● 데이터를 처리함에 있어 해당 데이터를 컴퓨터 내부에 표현하는 방법과 유지하는 방법이 성능에 큰 영향을 줌 \n\n● 자료구조는 특정 종류의 데이터를 여러 개 유지하는 복합 타입의 구체적인 구현을 말하며, 개별 데이터를 저장하고 추출하는 방법에 의해 그 특성이 결정됨 \n\n● 예) 리스트, 스택, 큐, 집합, 해시 테이블, 힙, 이진 검색 트리, union-find, 그래프 등 \n\n● 왜 이렇게 많은 종류의 자료구조가 있을까? \n\n● 각 자료구조가 효과적으로 할 수 있는 것이 다름 \n\n● 어떤 자료구조를 사용하지? \n\n● 주어진 문제는 어떤 종류의 연산이 필요한가? \n\n● 일반적으로 자료구조가 제공하는 연산의 수가 적을수록 연산의 성능이 우수하며, 공간 사용 측면도 효과적임",
    "source": "ds-slide00_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 2,
      "page_heading": "## 자료구조란",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0002"
  },
  {
    "type": "강의자료",
    "text": "## 강의목표 \n\n![](images/2_0.jpg)",
    "source": "ds-slide00_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 3,
      "page_heading": "## 강의목표",
      "images": [
        "ds-slide00/images/2_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0003"
  },
  {
    "type": "강의자료",
    "text": "# 프로그래밍 언어 순위 \n\n<table><tr><td>순위</td><td>프로그래밍 언어</td><td>Rating</td></tr><tr><td>1</td><td>Python</td><td>15.42</td></tr><tr><td>2</td><td>C</td><td>14.59</td></tr><tr><td>3</td><td>Java</td><td>12.40</td></tr><tr><td>4</td><td>C++</td><td>10.17</td></tr><tr><td>5</td><td>C#</td><td>5.59</td></tr><tr><td>6</td><td>Visual Basic</td><td>4.99</td></tr><tr><td>7</td><td>JavaScript</td><td>2.33</td></tr><tr><td>8</td><td>Assembly</td><td>2.17</td></tr><tr><td>9</td><td>SQL</td><td>1.70</td></tr><tr><td>10</td><td>PHP</td><td>1.39</td></tr></table>\n\nwww.tiobe.com (2022 Aug Index) \n\n![](images/3_0.jpg)",
    "source": "ds-slide00_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 4,
      "page_heading": "# 프로그래밍 언어 순위",
      "images": [
        "ds-slide00/images/3_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0004"
  },
  {
    "type": "강의자료",
    "text": "1 JavaScript  \n2 Python  \n2 Java  \n4 PHP  \n5 CSS  \n5 C++  \n5 C#  \n8 TypeScript  \n9 Ruby  \n10 C  \n11 Swift  \n12 R  \n13 Objective- C  \n14 Shell  \n14 Scala  \n16 Go  \n17 PowerShell  \n18 Kotlin  \n19 Rust  \n20 Dart  \n\nRedMonk the developer- focused industry analyst firm https://url.kr/yopmhq (2021 Jun Index)  \n\nGitHub stackoverflow",
    "source": "ds-slide00_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 5,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0005"
  },
  {
    "type": "강의자료",
    "text": "![](images/5_0.jpg)\n\n2021 IEEE Spectrum 전체순위 https://spectrum.ieee.org/top-programming-languages/",
    "source": "ds-slide00_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 6,
      "page_heading": "",
      "images": [
        "ds-slide00/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0006"
  },
  {
    "type": "강의자료",
    "text": "## 강의 방식 \n\n● C++/Java/Python3 언어 중 하나를 선택하여 실습 및 과제를 수행할 수 있음 \n\n● C++11은 C++11, C++14, C++17의 기능들을 최대한 활용함 \n\n● 주제마다 사용하는 언어를 바꿀 수 있음 \n\n● 수업 시간에 어떤 언어로 실습??? \n\n● 각 자료구조에 대한 기본 개념 설명 \n\n● 정수를 저장하는 해당 자료구조 구현 \n\n● 해당 자료구조의 여러 변형 구현 \n\n● 예) 동적 배열 방식 \n\n● 예) 데이터를 정렬하여 유지하는 경우와 그렇지 않은 경우 등 \n\n● 해당 자료구조의 범용 자료구조 구현 \n\n● 해당 자료구조 관련 C++, Java, Python3 라이브러리 소개 \n\n● 강의 녹화 동영상을 e1를 통해 제공함 (복습에 활용) \n\n● http://youtube.com/c/SangjinKim",
    "source": "ds-slide00_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 7,
      "page_heading": "## 강의 방식",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0007"
  },
  {
    "type": "강의자료",
    "text": "# 강의정보 \n\n- 교수 정보 \n\n- 연구실: 제2공학관 239호 \n\n- 전화번호: 교내 1490 (041-560-1490) \n\n- 전자우편: sangjin@koreatech.ac.kr \n\n- 강의홈페이지: el.koreatech.ac.kr \n\n- 교재 \n\n- 직접 집필한 교재를 주차별 제공 \n\n- 자료구조 관련 학습자료 제시 \n\n- 조교 정보: \n\n- 노유찬: youchan9133@gmail.com",
    "source": "ds-slide00_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 8,
      "page_heading": "# 강의정보",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0008"
  },
  {
    "type": "강의자료",
    "text": "## 강의정보 - 평가방법 \n\n![](images/8_0.jpg)\n\n● 강의 평가 방법 ● 출석: 5%, 퀴즈: 5%, 실습, 과제: 15%, 중간실습시험: 25%, 기말실습시험: 25%, 이론시험 25% ● 참고. 바꿀 수 있음 ● Pre-requisite ● C/C++, Java, Python3 언어 ● 강의자료 (모든 자료는 eI을 통해 제공함) ● 제공하는 자료 ● 교재, 강의 슬라이드, ● 수업 및 실습에 사용할(한) eclipse C++ 프로젝트, eclipse Java 프로젝트, Python3 코드 ● 과거 학기 질의응답 정리 자료 ● 실습 환경 구축 방법 설명 자료",
    "source": "ds-slide00_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 9,
      "page_heading": "## 강의정보 - 평가방법",
      "images": [
        "ds-slide00/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0009"
  },
  {
    "type": "강의자료",
    "text": "## 퀴즈, 질의응답 \n\n● 퀴즈: eI을 통해 강의 슬라이드가 끝날 때마다 3~5문제 제공 \n\n● 4지선다 또는 단단형 \n\n● 정답 비율이 최종 평가에 반영됨 \n\n● 강의 내용과 관련된 질문은 eI의 질의응답 게시판 이용 \n\n● 다른 방법을 통해 질의 가능하지만 가급적 질의응답 게시판 이용 \n\n● 메일보다는 카톡 선호 \n\n● 진행 중인 과제 관련 소스는 질의응답에 포함하지 않아야 함 (별도 전달) \n\n● 지난 2년 동안은 질의응답 횟수를 성적에 반영하였음 \n\n● 이번 학기부터는 반영하지 않음 \n\n● 반영하지 않더라고 학습 중 궁금한 것은 꼭 여기를 통해 질의응답 부탁함 \n\n● 익명으로 질의 가능 \n\n● 학습 내용과 관련이 없는 질문은 카톡, 메일, 자유 게시판 등을 활용",
    "source": "ds-slide00_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 10,
      "page_heading": "## 퀴즈, 질의응답",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0010"
  },
  {
    "type": "강의자료",
    "text": "## 과제 \n\n● 프로그램링 실습, 과제는 지정된 마감 기한까지 제출해야 함 \n\n○ 지각 제출은 가능하지만 감점함 \n\n○ 지각 제출 기한까지 제출하지 않으면 0점으로 처리함 \n\n● 별도 보고서는 필요 없음 \n\n● 추가 설명 요구사항은 프로그램 주석에 포함 \n\n● C++/Java는 eclipse 프로젝트를 압축파일로 export하여 제출함 \n\n○ 과제 마감 기한 이후 랜덤 선택한 제출 소스를 이용하여 과제 피드백 영상을 만들어 제공함 \n\n● 평가 기준 (과제 평가: 조교) \n\n● 감점 요인 (정상제출, 지각제출 80%, 영상피드백 이후 제출로 구분 50%) \n\n○ 프로그램 주석이 없는 경우 (제출한 모든 소스에 있어야 함) \n\n○ 들어쓰기를 하지 않는 경우 \n\n○ 과제의 요구사항을 온전하게 충족하지 못한 경우",
    "source": "ds-slide00_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 11,
      "page_heading": "## 과제",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0011"
  },
  {
    "type": "강의자료",
    "text": "# 강의정보 – 부교재 \n\n- **Nell Dale et al. C++ Plus Data Structures, 6th Ed., J&B Learnings, 2017** \n\n- **Nell Dale et al. Object-oriented Data Structures using Java, 4th Ed., Jones & Bartlett, 2016** \n\n- **Adam Drozdek, Data Structures and Algorithms in C++, 4th Ed., Cengage Learning, 2013** \n\n![](images/11_0.jpg)\n\n \n\n![](images/11_1.jpg)\n\n \n\n![](images/11_2.jpg)\n\n \n\n![](images/11_3.jpg)",
    "source": "ds-slide00_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 12,
      "page_heading": "# 강의정보 – 부교재",
      "images": [
        "ds-slide00/images/11_0.jpg",
        "ds-slide00/images/11_1.jpg",
        "ds-slide00/images/11_2.jpg",
        "ds-slide00/images/11_3.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0012"
  },
  {
    "type": "강의자료",
    "text": "# 다음을 한 번 생각하여 보자 \n\n## Pair programming \n\n- 두 명이 한 조가 되어 프로그래밍을 함.\n한 명이 코딩하면 다른 한 명은 분석을 하고, 이것을 교대로 \n\n- Code review: 다른 사람의 코드를 분석하여 보자 \n\n## Test driven programming \n\n- 테스트 프로그램을 먼저 작성하여 보자.\n아니면 동시에 작성하여 보자 \n\n- 이 수업은 단위 테스팅을 이용함 \n\n- C++: google test \n\n- Java: JUnit5 \n\n- Python3: unittest \n\n![](images/12_0.jpg)",
    "source": "ds-slide00_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 13,
      "page_heading": "# 다음을 한 번 생각하여 보자",
      "images": [
        "ds-slide00/images/12_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0013"
  },
  {
    "type": "강의자료",
    "text": "# 학습 리소스 \n\n- MOOC 강좌 \n\n- Data Structures (Coursera) \n\n- Data Structures and Software Design (edx) \n\n- Data Structures (Stepik) \n\n- 프로그래밍 경시대회 및 인터뷰 문제 사이트 \n\n- www.leetcode.com (무조건 가입 필요) \n\n- C++ Reference \n\n- http://en.cppreference.com/w/ \n\n- http://www.cplusplus.com/ \n\n- http://www.cprogramming.com/ \n\n- 기타 \n\n- https://www.cs.usfca.edu/~galles/visualization/Algorithms.html \n\n- http://www.geeksforgeeks.org/data-structures/",
    "source": "ds-slide00_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 14,
      "page_heading": "# 학습 리소스",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0014"
  },
  {
    "type": "강의자료",
    "text": "강의계획 \n\n<table><tr><td>1</td><td>강의소개<br/>자료구조 소개</td><td>9</td><td>트리<br/>이진 검색 트리</td></tr><tr><td>2</td><td>자료구조의 구현 (스택)</td><td>10</td><td>균형 이진 검색 트리</td></tr><tr><td>3</td><td rowspan=\"2\">리스트 - 배열기반</td><td>11</td><td rowspan=\"2\">집합, 맵, 해싱</td></tr><tr><td>4</td><td>12</td></tr><tr><td>5</td><td>연결구조 - 단일 연결구조</td><td>13</td><td>우선순위 큐<br/>2차실습시험</td></tr><tr><td>6</td><td>연결구조 - 이중 연결구조</td><td>14</td><td>그래프</td></tr><tr><td>7</td><td>스택, 큐, 덱</td><td>15</td><td>기말이론시험</td></tr><tr><td>8</td><td>1차실습시험</td><td>16</td><td></td></tr></table>",
    "source": "ds-slide00_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 15,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0015"
  },
  {
    "type": "강의자료",
    "text": "# 사용할 소프트웨어 \n\n● C++ \n\n○ MinGW (Minimalist GNU for Windows) \n\n● http://mingw-w64.org/ \n\n○ Eclipse CDT \n\n● www.eclipse.org: 최신 버전 2022-06 \n\n○ Googletest \n\n● https://github.com/google/googletest \n\n● Java \n\n○ Java SDK: Java 18 \n\n○ Eclipse Java: 최신 버전 2022-06 \n\n● Python3 \n\n● https://www.python.org \n\n● 설치 매뉴얼 제공: el.koreatech.ac.kr",
    "source": "ds-slide00_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 16,
      "page_heading": "# 사용할 소프트웨어",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0016"
  },
  {
    "type": "강의자료",
    "text": "## 부탁사항 \n\n● 강의 슬라이드, 강의 교재 중 오류가 있는 부분, 오타가 있는 부분을 발견하면 꼭 알려주세요. \n\n● 오류나 오타가 아니더라도 슬라이드나 교재 관한 어떤 피드백도 환영합니다. \n\nl 설명이 잘 이해가 되지 않는 부분, 설명이 부족하다고 생각되는 부분, 예시의 추가가 필요한 부분, 좋은 예시의 제안 등 모두 환영합니다. \n\n● 제공하는 소스의 오류나 개선 사항도 환영합니다. \n\nl 특히, 파이썬 소스는 부족한 것이 많을 수 있습니다. \n\nl 예제나 실습 내용의 제안도 환영합니다. \n\n● 질문도 많이 해주세요. \n\nl 정리된 질의응답을 보면 알 수 있지만 질의응답이 학습에 큰 도움이 될 뿐만 아니라 수업 개선에도 큰 도움이 됩니다.",
    "source": "ds-slide00_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 17,
      "page_heading": "## 부탁사항",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0017"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide00_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "ds-slide00",
      "page_no": 18,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0018"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n![](images/0_3.jpg)\n\n![](images/0_4.jpg)\n\n# 자료구조 개요 \n\nNOTE 01 \n\n# 한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide01_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 1,
      "page_heading": "# 자료구조 개요",
      "images": [
        "ds-slide01/images/0_0.jpg",
        "ds-slide01/images/0_1.jpg",
        "ds-slide01/images/0_2.jpg",
        "ds-slide01/images/0_3.jpg",
        "ds-slide01/images/0_4.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0019"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 데이터와 데이터 추상화 ● 추상 데이터 타입(ADT, Abstract Data Type)과 자료구조 ● 알고리즘 성능 분석: 시간 복잡도, 공간 복잡도 ● Big-O",
    "source": "ds-slide01_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0020"
  },
  {
    "type": "강의자료",
    "text": "## 데이터 (1/2) \n\n● 오늘날 소프트웨어가 처리하는 데이터는 다양하고, 복잡하고, 생성 속도가 매우 빠를 수 있고, 처리하는 양도 매우 클 수 있음 \n\n● 소프트웨어가 필요한 데이터를 처리하기 위해서는 해당 데이터를 컴퓨터 내부에 표현하여 메모리에 유지해야 함 \n\n● 이때 데이터를 표현하고 유지하는 형태가 소프트웨어 성능에 큰 영향을 줄 수 있음 \n\n● 자료구조를 학습하는 이유 \n\n● 어떤 데이터가 소프트웨어 내부에 표현하고 유지하는 형태는 보통 사람이 해당 데이터를 생각하고 바라보는 시각과 같을 수 없음",
    "source": "ds-slide01_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 3,
      "page_heading": "## 데이터 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0021"
  },
  {
    "type": "강의자료",
    "text": "# 데이터 (2/2) \n\n## 예) 사람 나이 \n\n- Human: 사람 나이는 1살부터 시작하여 1년이 지날 때마다 1씩 증가함. 양의 정수 데이터임 \n\n- Computer: 사용된 언어에 따라 차이가 있음. 컴퓨터는 나이 정보를 이진 데이터로 유지하며, 보통 2의 보수 표현 방법을 사용함 \n\nclass Person{\n    int age;\n    public:\n    void setAge(int age);\n}; \n\n<table><tr><td>사람 나이</td><td>1~150(?)</td></tr><tr><td>signed int</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr></table>\n\n- 개발자가 사고를 할 때 이 생각의 차이를 항상 고려해야 하는 것은 아닌. 상황에 따라 추상화(abstraction)하여 생각하는 것이 편리함 \n\n![](images/3_0.jpg)",
    "source": "ds-slide01_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 4,
      "page_heading": "# 데이터 (2/2)",
      "images": [
        "ds-slide01/images/3_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0022"
  },
  {
    "type": "강의자료",
    "text": "## 데이터의 종류 \n\n● 프로그래밍에서 데이터의 종류를 타입 또는 자료유형이라 함 \n\n● 타입의 정의 \n\n○ 해당 타입이 가질 수 있는 값의 범위(도메인)와 해당 값들을 가지고 할 수 있는 연산에 의해 정의됨 \n\n● 예) int \n\n○ 도메인(4 byte signed): -2,147,483,648 ~ +2,147,483,647 \n\n○ 연산: 사칙연산, 나머지 연산 등 \n\n● 서로 비교할 수 있음 \n\n● 추상 데이터 타입(ADT, Abstract Data Type): 특정 구현 방식과 무관한 데이터의 특성(도메인, 연산) \n\n○ int는 ADT가 아님. 정수에 대한 특정 구현이며, 범위도 제한적임",
    "source": "ds-slide01_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 5,
      "page_heading": "## 데이터의 종류",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0023"
  },
  {
    "type": "강의자료",
    "text": "## 타입의 종류 \n\n● 원시타입(primitive type, basic type) \n\n○ 해당 타입의 변수는 특정 값을 하나만 유지함 \n\n○ 프로그래밍 언어에서 기본적으로 제공 \n\n● C++ 예) int, float, double, char, bool \n\n● 복합타입 \n\n○ 여러 개의 값을 유지함 \n\n○ 예) 배열, 문자열, C/C++의 구조체 \n\n![](images/5_0.jpg)\n\n○ 프로그래밍언어에서 기본적으로 제공하는 복합타입도 있지만 다수의 복합타입은 라이브러리 형태로 원시타입들을 활용하여 정의되며, 이들이 자료구조임 \n\n● 참고. 값 타입 vs. 참조 타입 \n\n○ 값 타입: 값 자체를 유지하는 타입. 예) int n = 10; \n\n○ 참조 타입: 값 대신에 값이 있는 위치 정보를 유지하는 타입 \n\n● 예) int* p = &n; \n\n● C++의 reference 변수는 특이함",
    "source": "ds-slide01_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 6,
      "page_heading": "## 타입의 종류",
      "images": [
        "ds-slide01/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0024"
  },
  {
    "type": "강의자료",
    "text": "# 프로그래밍에서 데이터 타입 \n\n## ● 예) 정수 2개를 받아 그것의 합을 계산 \n\nint i{0}, j{0};\nstd::cin >> i >> j;\nstd::cout << i+j << '\\n'; \n\n- 언어에 포함된 원시타입만 가지고 프로그래밍 가능\n- 이 프로그램의 문제는? \n\n## ● 예) 사각형의 면적을 구하기 \n\n- 사각형을 프로그램 내에 어떻게 표현할까? \n\n- 어떤 정보가 필요한가? \n\n- 왼쪽 위 꼭짓점의 좌표, 폭, 높이 \n\n- 왼쪽 위, 오른쪽 아래 꼭짓점 \n\n- 새 타입의 정의 필요 \n\nstruct Rectangle{\n    int upperLeftX;\n    int upperLeftY;\n    int width;\n    int height;\n}; \n\nstruct Point{\n    int x;\n    int y;\n}; \n\nstruct Rectangle{\n    Point upperLeft;\n    int width;\n    int height;\n};",
    "source": "ds-slide01_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 7,
      "page_heading": "# 프로그래밍에서 데이터 타입",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0025"
  },
  {
    "type": "강의자료",
    "text": "## 신심 \n\n● 좌표 3개로 구성되는 삼각형 클래스(새 데이터 타입)를 정의하시오. \n\n● 이 클래스에 면적을 구하는 연산을 추가하시오. \n\n● 좌표가 주어졌을 때 이 좌표가 삼각형 내부에 있는지 외부에 있는지 판단하는 연산을 추가하시오. \n\nstruct Point{ int x; int y; }; \n\nclass Triangle{ private: \n\nPoint p1; \n\nPoint p2; \n\nPoint p3; \n\npublic: \n\nTriangle(const Point& p1, const Point& p2, const Point& p3); \n\ndouble area(); \n\nbool isInside(const Point& p); \n\n};",
    "source": "ds-slide01_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 8,
      "page_heading": "## 신심",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0026"
  },
  {
    "type": "강의자료",
    "text": "## 자료구조 \n\n● 자료구조: 복합타입의 구체적 구현  ● 개별 데이터를 저장하고 추출하는 방식에 의해 그 특성이 결정  ● 자료구조의 주요 특징  ● 특징 1. 개별 요소로 나눌 수 있음  ● 특징 2. 개별 요소의 배치가 각 요소의 접근 방법을 결정함  ● 특징 3. 배치와 접근 방법을 모두 추상화할 수 있음  ● ADT와 자료구조의 차이  ● ADT: 논리적 뷰  ● ADT만으로는 공간 복잡성이나 개별 연산의 복잡성을 논할 수 없음  ● 자료구조: 구체적 구현  ● 공간 복잡성과 연산의 복잡성을 계산할 수 있음 \n\n 객체지향 프로그래밍에서 클래스를 정의하면 클래스를 사용하는 측에서는 클래스는 ADT가 됨  클래스를 구현하는 프로그래머 입장에서 클래스는 “자료구조+알고리즘”임",
    "source": "ds-slide01_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 9,
      "page_heading": "## 자료구조",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0027"
  },
  {
    "type": "강의자료",
    "text": "# 자료구조 vs. ADT \n\n## ● 예) 스택(stack) \n\n### ● ADT: LIFO(Last-In-First-Out) \n\n- 정수 5, 3, 7 순으로 삽입하였을 경우 추출 연산을 실행하였을 때 가장 먼저 추출되는 것은 7입 \n\n#### ● 자료구조 \n\n- 내부적으로 배열로 구현할 수 있고, 연결구조로 구현할 수 있음 \n\n- 내부적 구현 방법을 모르더라도 스택 자료구조를 사용할 수 있음 \n\n- 하지만 구체적인 구현 방법을 알아야 성능을 논할 수 있음 \n\n<table><tr><td>5</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>5</td><td></td><td></td><td></td></tr><tr><td>7</td><td>3</td><td>5</td><td></td><td></td></tr><tr><td>3</td><td>5</td><td></td><td></td><td></td><td></td></tr></table>\n\n<table><tr><td>5</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>3</td><td></td><td></td><td></td></tr><tr><td>5</td><td>3</td><td>7</td><td></td><td></td></tr><tr><td>5</td><td>3</td><td></td><td></td><td></td><td></td></tr></table>\n\n![](images/9_0.jpg)",
    "source": "ds-slide01_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 10,
      "page_heading": "# 자료구조 vs. ADT",
      "images": [
        "ds-slide01/images/9_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0028"
  },
  {
    "type": "강의자료",
    "text": "# 범용 자료구조 \n\n- 유지하는 데이터 타입에 제한이 없는 자료구조 \n\n  - C++는 template 사용 \n\n  - 구현할 때에는 타입 매개변수를 사용하여 실제 사용할 타입과 독립적으로 구현하고, 사용할 때 타입 인자를 제시함 \n\n  - template로 구현된 것을 n개의 다른 타입 인자를 이용하여 사용하게 되면 컴파일러는 총 n개의 서로 다른 구현을 내부적으로 만들어 사용함 (모든 언어가 이와 같지는 않음) \n\n- 이 수업에서는 다음 순서로 \n\n  - int 자료구조 구현 \n\n  - 다양한 변형 구현 \n\n  - 가장 일반적인 구현방법을 이용하여 범용 자료구조를 구현 \n\n  - 표준 라이브러리에 있는 관련 자료구조 활용 \n\n  - 관련 문제 풀이 \n\ntemplate <typename T>\nclass Stack{\n    T* buffer;\n    // \n}; \n\nStack<int> stack;",
    "source": "ds-slide01_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 11,
      "page_heading": "# 범용 자료구조",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0029"
  },
  {
    "type": "강의자료",
    "text": "# 자료구조 기본연산 \n\n- 데이터 추가: push, put, add \n\n  - 앞뒤가 있는 자료구조: pushFront, pushBack \n\n- 데이터 추출: pop, poll \n\n  - 앞뒤가 있는 자료구조: popFront, popBack \n\n- 데이터 보기: peek, get \n\n  - 앞뒤가 있는 자료구조: peekFront, peekBack \n\n- 데이터 삭제: remove \n\n- 데이터 검색: find \n\n- 반복자: 저장된 모든 데이터를 한 번씩 방문 \n\n- 기타 연산 \n\n  - 교체(replace, set) \n\n- 자료구조 상태 조회 \n\n  - isEmpty, isFull, size 등 \n\n- 자료구조가 제공하는 연산이 제한적이면 더 효과적으로 구현할 수 있음 \n\n  - 다양한 연산을 제공할 경우 모두 효과적으로 제공하기 힘들 \n\n  - 자료구조에서 제공하는 각 연산의 성능을 이해하고 가능하면 성능이 우수한 연산만 이용하여 구현해야 함",
    "source": "ds-slide01_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 12,
      "page_heading": "# 자료구조 기본연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0030"
  },
  {
    "type": "강의자료",
    "text": "## 자료구조의 종류 \n\n● 선형 vs. 비선형 \n\n○ 선형 자료구조는 배열처럼 요소들이 선형으로 배치되는 경우 \n\n● 선행 또는 후속 요소가 있으면 하나만 있는 경우 \n\n○ 비선형 자료구조는 트리처럼 선형으로 배치되지 않는 경우 \n\n● 동질구조 vs. 비동질구조 \n\n○ 동질 자료구조는 저장된 요소들이 논리적 또는 물리적으로 같은 타입인 경우 \n\n○ 비동질 자료구조는 구조체처럼 요소들이 같은 타입이 아닐 수 있는 경우 \n\n● 정적 vs. 동적 \n\n○ 정적 자료구조는 용량이 고정되어 있는 경우를 말하며, 동적은 요소가 추가됨에 따라 용량이 늘어나는 경우를 말함 \n\n● 프로그래밍 언어에서 라이브러리를 통해 제공하는 자료구조의 보통 다음 형태임 1) 범용 자료구조 2) 동질 자료구조 3) 동적 자료구조",
    "source": "ds-slide01_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 13,
      "page_heading": "## 자료구조의 종류",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0031"
  },
  {
    "type": "강의자료",
    "text": "# 선형 자료구조의 종류 \n\n- 리스트 \n\n- 스택 (LIFO) \n\n- 큐 (FIFO) \n\n![](images/13_0.jpg)\n\n \n\n![](images/13_1.jpg)\n\n \n\n![](images/13_2.jpg)\n\n \n\n- 리스트, 스택, 큐는 자료구조가 아니고 ADT임\n- 우선순위 큐는 비선형 자료구조임",
    "source": "ds-slide01_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 14,
      "page_heading": "# 선형 자료구조의 종류",
      "images": [
        "ds-slide01/images/13_0.jpg",
        "ds-slide01/images/13_1.jpg",
        "ds-slide01/images/13_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0032"
  },
  {
    "type": "강의자료",
    "text": "## 비선형 자료구조의 예 \n\n● 트리 ● 그래프 ● 방향/무방향 그래프 ● 가중치/비가중치 그래프 \n\n![](images/14_0.jpg)\n\n![](images/14_1.jpg)\n\n● 트리, 그래프도 ADT",
    "source": "ds-slide01_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 15,
      "page_heading": "## 비선형 자료구조의 예",
      "images": [
        "ds-slide01/images/14_0.jpg",
        "ds-slide01/images/14_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0033"
  },
  {
    "type": "강의자료",
    "text": "## 자료구조와 알고리즘 \n\n● 자료구조와 알고리즘은 서로 밀접한 관계를 가지고 있음 \n\n○ 어떤 문제를 해결하는 방법을 찾을 때 \n\n● 1) 문제를 해결할 때 사용할 자료구조를 먼저 결정 \n\n● 보통 자료구조에 의해 알고리즘이 결정됨 \n\n● 2) 그것을 해결하기 위한 알고리즘을 먼저 결정 \n\n● 이 알고리즘에 적합(필요)한 자료구조가 보통 있음 \n\n● 자료구조와 알고리즘, 알고리즘과 자료구조는 문제를 해결하기 위해 함께 설계되어야 함 \n\n![](images/15_0.jpg)",
    "source": "ds-slide01_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 16,
      "page_heading": "## 자료구조와 알고리즘",
      "images": [
        "ds-slide01/images/15_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0034"
  },
  {
    "type": "강의자료",
    "text": "# 알고리즘의 비교 (1/2) \n\n- 특정 문제를 해결하는 방법은 다양한 수 있음 \n\n- 예) 정수 배열에서 중복된 요소의 존재 여부 \n\n**containDuplicates(nums):** \n\n**for i:=1 to n-1 do** \n\n**for j:=1 to n do** \n\n**if nums[i]==nums[j] then return true** \n\n**return false** \n\n- 또 다른 방법은? \n\n- 이와 같은 방법들을 생각해 \n\n별 수 있나? \n\n- 이 중 어느 것이 우수한 것인가? \n\n**containDuplicates(nums):** \n\n**sort nums in ascending order** \n\n**for i:=2 to n do** \n\n**if nums[i-1]==nums[i] then return true** \n\n**return false** \n\n**containDuplicates(nums):** \n\n**S := empty hash set** \n\n**for i:=1 to n-1 do** \n\n**if S contains nums[i] then return true** \n\n**add nums[i] to S** \n\n**return false**",
    "source": "ds-slide01_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 17,
      "page_heading": "# 알고리즘의 비교 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0035"
  },
  {
    "type": "강의자료",
    "text": "## 알고리즘의 비교 (2/2) \n\n● 그러면 어떤 방법을 사용하는 것이 좋을까? \n\n○ 성능이 우수한 것 \n\n● 알고리즘 수행에 필요한 시간: 빠른 것 \n\n● 입력 크기에 따라 느리게 증가하는 것 \n\n● 알고리즘 수행에 필요한 메모리 공간: 적게 사용하는 것 \n\n○ 구현하기 쉬운 것 \n\n○ 이해하기 쉬운 것 \n\n○ 당연히 사용할 알고리즘은 정확해야 함 \n\n● 빠른 것은 어떻게 측정 \n\n○ 실제 시간을 계산??? \n\n● 컴퓨팅 환경, 프로그래밍 언어, 구현 결과에 따라 다를 수 있음 \n\n○ 필요한 기본 연산 수를 계산 \n\n● 기본 연산: 대입, 산술, 비교 등 \n\n● 필요한 기본 연산 수도 언어와 구현 결과에 따라 다를 수 있음 \n\n● 전체 연산 수에 미치는 영향이 지배적인 것과 그렇지 않은 것으로 나누어질 수 있음",
    "source": "ds-slide01_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 18,
      "page_heading": "## 알고리즘의 비교 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0036"
  },
  {
    "type": "강의자료",
    "text": "# 알고리즘 성능의 측정 (1/2) \n\n## ● 예) 리스트에 있는 요소를 파일에 기록하기 \n\nopen file\nwhile(more elements in the list) write the next element\nclose file \n\n- (n × 한 요소를 기록하는데 소요되는 시간) + (파일을 열고 닫는 시간) \n\n- 코드 레벨에서 더 구체화한 후에 분석하면 \n\nopen file\nfor(int i=0; i<size; i++) outFile.write(list[i]);\n// for(auto n: list) outFile.write(n);\nclose file \n\n- 파일을 열고 닫는 시간은 항상 고정된 시간\n- 리스트에 있는 개수에 영향을 받지 않음 \n\n- i와 size를 비교하는 시간, i++ 시간 등이 더 필요함 \n\n- 이 부분은 구현 방법에 따라 다를 수 있음 \n\n- 중요한 것은 전체 비용은 리스트 개수에 비례한다는 것임",
    "source": "ds-slide01_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 19,
      "page_heading": "# 알고리즘 성능의 측정 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0037"
  },
  {
    "type": "강의자료",
    "text": "# 알고리즘 성능의 측정 (2/2) \n\n## ● 예) 배열을 특정 값으로 초기화 \n\nvoid fill(int[] nums, int size, int v){\n    for(int i=0; i<size; i++) nums[i] = v;\n} \n\n- 입력의 크기가 같으면\n  항상 같은 비용이 소요됨 \n\n- size = n일 때, i 변수의 초기화: 1, i와 size의 비교: n + 1번,\n  i의 증가: n번, 대입: n번 → 총: 3n + 2 \n\n- 알고리즘 A: 5n² + 1, B: 3000n + 100 \n\n<table><tr><td>n</td><td>A: 5n² + 1</td><td>B: 3000n + 100</td></tr><tr><td>100</td><td>50,001</td><td>300,100</td></tr><tr><td>1,000</td><td>5,000,001</td><td>3,000,100</td></tr><tr><td>10,000</td><td>500,000,0001</td><td>30,000,100</td></tr><tr><td>100,000</td><td>50,000,000,001</td><td>300,000,100</td></tr><tr><td></td><td>10,000,000,000</td><td>100,000</td></tr></table>\n\n- 최고차항의 계수를 무시한 경우",
    "source": "ds-slide01_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 20,
      "page_heading": "# 알고리즘 성능의 측정 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0038"
  },
  {
    "type": "강의자료",
    "text": "# Big-O (1/4) \n\n- **Big-O** 표기법은 **최악의 경우 알고리즘이 특정 수준과 같거나 빠르다는 것을 나타냄** \n\n- **예)** \\(f(n) = 3n^4 + 100n^2 + 10n + 50\\) \n\n- \\(n\\)이 매우 크면 \\(n^4\\)이 다른 것을 압도하게 됨 \n\n- 따라서 위의 경우 빅O는 \\(o(n^4)\\)됨 \n\n- 보통 컴퓨팅 환경(CPU의 종류)과 프로그래밍 언어에 따라 위 식의 계수는 달라질 수 있음 \n\n- \\(n\\)이 매우 크면 최고차 항을 제외한 나머지를 무시하여도 비교에 문제가 없음 \n\n- **빅O는 상한**이므로 위 \\(f\\)는 \\(o(n^5)\\)이라고 하여도 틀린 것은 아닌 \n\n- \\(f\\)는 \\(o(n^3)\\)이라고 할 수는 없음 \n\n- 하지만 비교를 위해서는 최소 상한이 중요 \n\n- 목표는 같은 문제를 해결하는 알고리즘을 비교하는 것임 \n\n- **빅O를 많이 사용하는 이유는 정확하게 분석하는 것이 어렵고, 정확하게 분석하지 않아도 문제가 없기 때문임** \n\n**Big-O: Upper bound, Big-Omega: Lower Bound, Big-Theta: both**",
    "source": "ds-slide01_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 21,
      "page_heading": "# Big-O (1/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0039"
  },
  {
    "type": "강의자료",
    "text": "![](images/21_0.jpg)\n\n성능이 우수하다는 것은 입력 크기에 따라 느리게 증가하는 것 성능이 좋을수록 그래프는 아래에 위치함 상한이라는 것은 주어진 상한보다 알고리즘은 좋다는 것임 하한이라는 것은 주어진 하한보다 알고리즘이 좋을 수 없다는 것임",
    "source": "ds-slide01_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 22,
      "page_heading": "",
      "images": [
        "ds-slide01/images/21_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0040"
  },
  {
    "type": "강의자료",
    "text": "# Big-O (3/4) \n\n- 입력의 크기 \n\n- 예) 리스트에 특정 요소 존재 여부: 리스트의 크기 \n\n- 예) 주어진 양의 정수가 소수인지 판단: ??? \n\n- 정수가 커질수록 소요되는 비용이 증가함 \n\n- 정수가 커질수록 그것을 표현하는데 소요되는 비트 수는 증가함 \n\n- 넉어에서 입력의 크기는 정확하게는 그 입력을 컴퓨터에 표현하기 위한 문자 수임 \n\n- 정수 \\(x\\)를 표현하기 위한 비트 수: \\(n \\approx \\log_2 x \\to x \\approx 2^n\\) \n\n- 최악의 경우 시간 복잡도: \\(W(x) = x^{1/2} = 2^{n/2} \\to O(2^n)\\) \n\nisPrime(x): \n\nfor i:=2 to sqrt(n) do \n\nif x%i==0 then return false \n\nreturn true \n\n// log₂ x \n\nfind(list, v): \n\nfor i:=1 to n do \n\nif list[i]==v then return false \n\nreturn true \n\n// size=k, n = klog₂ L \n\n- \\(W(k) = 3k + 2 = \\frac{3n}{\\log_2 L} + 2\\) \n\n- \\(O(n)\\)",
    "source": "ds-slide01_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 23,
      "page_heading": "# Big-O (3/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0041"
  },
  {
    "type": "강의자료",
    "text": "# Big O (4/4) \n\n- 다중 변수 비O \n\n- 보통 알고리즘은 특정 입력 하나에만 영향을 받음 \n\n- 하지만 여러 입력의 크기에 영향을 받는 경우가 있음 \n\n- 예) 구간 평균 중 최댓값 찾기 \n\n- 구간 크기와 입력 배열의 크기에 영향을 받음. \\(O(mn)\\) \n\n- 그래프의 경우 보통 노드 수 \\(n\\)과 간선 수 \\(m\\)에 알고리즘이 영향을 받음 \n\n- 다중 변수에 영향을 받으면 다중 변수가 모두 나타나도록 표현하는 것이 바람직함 \n\n\\(maxInterval(nums, m)\\): \n\n\\(ret := -inf\\) \n\n\\(for i := 1 to n-m+1 do\\) \n\n\\(sum := 0\\) \n\n\\(for j := 1 to m do\\) \n\n\\(sum += nums[i+j-1]\\) \n\n\\(ret := max(ret, sum/m)\\) \n\n\\(return ret\\) \n\n- \\(O(mn)\\), \\(O(m+n)\\), \\(O(m\\log n)\\) \n\n- 더 많은 정보를 얻을 수 있음 \n\n- 하나의 변수로 바꾸어 분석하는 경우도 있음 \n\n- 간선의 수가 최대 \\(n^2\\)이면 \\(O(mn) = O(n^3)\\)으로 분석 가능",
    "source": "ds-slide01_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 24,
      "page_heading": "# Big O (4/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0042"
  },
  {
    "type": "강의자료",
    "text": "## 최선, 최약, 평균 비용 \n\n● 항상 일정한 비용(?)이 요구되는 알고리즘 \n\n● 예) 선택 정렬 \n\nselectionSort(nums): \n\nfor i:=1 to n-1 do \n\nminLoc := i; \n\nfor j:=i+1 to n do \n\nif nums[minLoc] > nums[j] then minLoc := j; \n\nswap nums[i] with nums[minLoc] \n\n● 요구되는 비용이 입력 데이터에 따라 다를 수 있는 알고리즘 \n\n● 예) 정렬되어 있지 않는 리스트에서 검색 \n\n● 최선(best-case): 1 \n\n● 최약(worst-case): n \n\n● 평균(average-case): n/2 ??? \n\n● 보통 최약의 경우를 활용하여 비교 \n\n● 평균은 구하기 어려울 수 있고, 최선은 의미가 없을 수 있음",
    "source": "ds-slide01_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 25,
      "page_heading": "## 최선, 최약, 평균 비용",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0043"
  },
  {
    "type": "강의자료",
    "text": "# Common Order (1/2) \n\n- \\(O(1)\\): 상수시간(constant time) 비용. 입력 크기에 전혀 영향을 받지 않는 경우 \n\n- 예) 배열 끝에 요소 저장하기 \n\n- \\(O(\\log n)\\): 로그시간(logarithmic time) 비용. 한 번에 처리해야 하는 양이 반복 줄어드는 경우 \n\n- 예) 이진 검색 \n\n- \\(O(n)\\): 선형시간(linear time) 비용. 예) 선형 검색 \n\n- \\(O(n\\log n)\\): 의사선형시간(quasilinear time) 비용 \n\n- 예) 합병 정렬, 퀵정렬 \n\n- \\(O(n^2)\\): 이차시간(quadratic time) 비용. 예) 버블정렬 \n\n- 다차시간(polynomial time) 비용 \n\n- \\(O(2^n)\\): 지수시간(exponential time) 비용 \n\n- \\(O(n!)\\): 계승시간(factorial time) 비용",
    "source": "ds-slide01_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 26,
      "page_heading": "# Common Order (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0044"
  },
  {
    "type": "강의자료",
    "text": "## 이진검색 \n\n![](images/26_0.jpg)\n\n \n\n- 정수 k가 이 배열에 있는지 알고 싶다. \n\n- 선형검색: 처음부터 하나씩 k와 비교한다.\n  - 최악의 경우는 몇 번 비교가 필요하나?\n  - 평균적으로 몇 번 비교가 필요하나? \n\n- 이진검색: 중간 위치에 있는 값과 비교, 비교 결과에 따라 한 쪽 반의 중간과 다시 비교\n  - 최악의 경우는 몇 번 비교가 필요하나?\n  - 평균적으로 몇 번 비교가 필요하나? \n\n- 데이터가 정렬되어 있지 않다면?",
    "source": "ds-slide01_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 27,
      "page_heading": "## 이진검색",
      "images": [
        "ds-slide01/images/26_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0045"
  },
  {
    "type": "강의자료",
    "text": "# Common Order (2/2) \n\n## 복잡도 비교 \n\n<table><tr><td>logn</td><td>n</td><td>nlogn</td><td>\\(n^{2}\\)</td><td>\\(2^{n}\\)</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td></tr><tr><td>2</td><td>4</td><td>8</td><td>16</td><td>16</td></tr><tr><td>3</td><td>8</td><td>24</td><td>256</td><td>65,536</td></tr><tr><td>5</td><td>32</td><td>160</td><td>1,024</td><td>4,294,967,296</td></tr><tr><td>8</td><td>256</td><td>2048</td><td>65,536</td><td>don't ask</td></tr></table>\n\n## 중요. 빅O는 \\(n\\)이 충분히 클 경우에만 의미가 있음 \n\n## 자료구조, 알고리즘에서 빅O는 시간 복잡성뿐만 아니라 공간 복잡성을 나타내기 위해서도 사용함",
    "source": "ds-slide01_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 28,
      "page_heading": "# Common Order (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0046"
  },
  {
    "type": "강의자료",
    "text": "# 복잡성과 빅O \n\n- 정렬되어 있지 않은 정수 배열에 요소 추가하기 \n\n- 어디에? \n\n  - 맨 앞: 나머지 요소를 하나씩 뒤로 옮겨야 함: \\(O(n)\\) \n\n  - 맨 뒤: 위치 정보를 알면 바로 처리 가능 \n\n  - 상수 비용: \\(O(1)\\) \n\n- 정렬되어 있지 않은 정수 배열에서 특정 요소 삭제하기 \n\n  - 해당 요소를 찾아야 함: 최악의 경우 \\(O(n)\\) \n\n  - 찾은 후에는 제거해야 함: 비용? \n\n<table><tr><td>7</td><td>1</td><td>2</td><td>5</td><td>9</td><td>6</td><td>remove(2)</td></tr></table>\n\n<table><tr><td>7</td><td>1</td><td>5</td><td>9</td><td>6</td><td>방법 1. 뒤 요소 이동</td></tr></table>\n\n<table><tr><td>7</td><td>1</td><td>-1</td><td>5</td><td>9</td><td>방법 2. 제거 위치 표시</td></tr></table>\n\n<table><tr><td>7</td><td>1</td><td>6</td><td>5</td><td>9</td><td>방법 3. 맨 뒤 요소 이동</td></tr></table>",
    "source": "ds-slide01_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 29,
      "page_heading": "# 복잡성과 빅O",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0047"
  },
  {
    "type": "강의자료",
    "text": "## 공간 복잡도 \n\n● 공간 복잡도도 넉○를 이용하여 분석함 \n\n● 공간 복잡도는 입력의 크기와 알고리즘이 내부적으로 사용하는 공간의 크기를 합하여 분석함 (input space + auxiliary space) \n\n○ 하지만 알고리즘을 비교할 때는 입력의 크기는 차이가 없기 때문에 어느 알고리즘이 내부적으로 사용하는 공간의 크기가 적은지 비교함 \n\n● 예) containDuplicates \n\n● 방법 1. for 문의 제어 변수만 추가로 사용함 \n\n○ 방법 2. 정렬 함수가 사용하는 공간에 의해 결정됨 \n\n● 합병 정렬은 추가 공간 사용, 빠른 정렬은 추가 공간을 사용하지 않음 \n\n● 방법 3. 집합 자료구조가 사용한 공간만큼 추가로 사용함 \n\n● 재귀호출을 이용하는 알고리즘의 경우에는 사용하는 스택 공간을 공간 복잡도에 포함함",
    "source": "ds-slide01_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 30,
      "page_heading": "## 공간 복잡도",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0048"
  },
  {
    "type": "강의자료",
    "text": "## Big O 요약 \n\n● 같은 문제를 해결하는 알고리즘의 성능을 비교하는 것이 목적 \n\n● 시간 복잡도, 공간 복잡도 분석에 모두 사용 가능 \n\n● 최악의 경우 성능 비교 \n\n● 입력 크기가 매우 클 경우에만 의미가 있음 \n\n● 빅O가 같으면 생략된 계수와 항까지 비교해야 함 \n\n● 입력 크기 관련 주의사항 \n\n● 정확하게 분석해야 하는 경우가 있음. 예) isPrime \n\n● 다중 변수에 영향을 받는 알고리즘이면 다중 변수가 모두 등장하도록 빅O을 표현하는 것이 바람직함",
    "source": "ds-slide01_page_31",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 31,
      "page_heading": "## Big O 요약",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0049"
  },
  {
    "type": "강의자료",
    "text": "## 알고리즘의 성능과 선택 \n\n● 가장 중요한 것 \n\n○ 주어진 문제를 해결할 수 있는 알고리즘을 고안해 낼 수 있어야 함 \n\n○ 여러 알고리즘 중 어느 것이 개발하고자 하는 응용에 적합한지 선택할 수 있어야 함 \n\n○ 알고리즘의 성능을 분석할 수 있어야 선택할 수 있음 \n\n● 빠른 알고리즘이 무조건 우선되어야 하나? \n\n○ 빅O 분석은 최악의 경우에 대한 분석이며, 입력 데이터의 크기가 매우 클 경우에만 의미가 있음 \n\n○ 알고리즘을 적용할 문제의 입력 데이터 크기가 제한적이면 빅O 분석에서 복잡도가 높더라도 더 효과적일 수 있음 \n\n○ 성능이 떨어지지만 정확성이 보장된 알고리즘은 새 알고리즘을 테스트하기 위해 활용할 수 있음 \n\n● 주어진 문제에 효과적인 해결책을 찾지 못하였을 때 접근 방법 \n\n○ 최적의 답을 꼭 찾을 필요가 없는 응용: 최적의 답을 주지 않지만 최적에 가까운 답을 주는 효율적인 알고리즘 사용 (편차 보장 여부)",
    "source": "ds-slide01_page_32",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 32,
      "page_heading": "## 알고리즘의 성능과 선택",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0050"
  },
  {
    "type": "강의자료",
    "text": "## 자료구조 실전 \n\n● 카톡에서 친구 목록은 어떻게 유지? \n\n○ 현재 친구가 아니지만 친구의 친구를 친구로 추천하고 싶음 \n\n○ 이와 같은 관계가 많은 사용자를 우선적으로 추천하고 싶음 \n\n○ 나와 공통 친구가 많은 사용자를 우선적으로 추천하고 싶음 \n\n● 단순한 방법 \n\n○ 각 사용자마다 정렬된 친구목록 유지 \n\n○ 특정 사용자 관련하여 그 사용자 친구의 친구 목록과 차집합을 구한 다음 각 차집합에 공통적으로 가장 많이 등장하는 순으로 추천함 ○ 특정 사용자와 친구가 아닌 사용자들과 교집합을 구하여 교집합의 크기가 큰 순으로 추천함 \n\n● 또 다른 방법 \n\n○ 모든 사용자 간에 친구 관계를 나타내는 2차원 배열을 사용함",
    "source": "ds-slide01_page_33",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 33,
      "page_heading": "## 자료구조 실전",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0051"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide01_page_34",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조 개요",
      "page_no": 34,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0052"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n## 자료구조의 구현 \n\nNOTE 02 \n\n한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide02_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 1,
      "page_heading": "## 자료구조의 구현",
      "images": [
        "ds-slide02/images/0_0.jpg",
        "ds-slide02/images/0_1.jpg",
        "ds-slide02/images/0_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0053"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● C++, Java, Python을 이용한 스택 자료구조 구현 \n\n○ 기본 골격 비교 \n\n○ 초깃값 목록 \n\n○ 소멸자, clear \n\n○ 복합타입의 저장 \n\n○ 동적 배열 기법 \n\n○ 복합타입의 반환 \n\n○ 추출과 삭제 \n\n○ 반복자 \n\n○ 단위 테스팅 \n\n○ 기타 \n\n○ 각 언어별 자료구조 구현을 위해 필요한 사전 지식 학습\n○ 각 언어별 차이점 학습 \n\n![](images/1_0.jpg)",
    "source": "ds-slide02_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide02/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0054"
  },
  {
    "type": "강의자료",
    "text": "## 프로그램명 언어와 자료구조 구현 \n\n● 프로그램밍 언어의 특성 때문에 특정 언어로 자료구조를 구현할 때 주의할 점이 다르고, 구현 방법에 차이가 있을 수 있음 \n\n● C++17, Java18, Python3를 이용하여 자료구조를 구현할 때 주의할 점과 차이점을 살펴보는 것이 이 장의 목적임 \n\n● LIFO(Last-In-First-Out) 방식의 선형 자료구조인 스택의 구현을 통해 이것을 살펴봄 \n\n● 배열 기반으로 스택을 구현함 \n\n● 내부적으로 배열에 삽입한 데이터를 유지함 \n\n● 동적 자료구조로 구현함 \n\n● 용량이 부족하면 확대함 \n\n● 범용 자료구조로 구현함 \n\n● 자료구조는 복합 타입이므로 내부적으로 배열 아니면 연결구조와 같은 형태(저장된 데이터를 서로 연결하여 유지)로 구현함",
    "source": "ds-slide02_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 3,
      "page_heading": "## 프로그램명 언어와 자료구조 구현",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0055"
  },
  {
    "type": "강의자료",
    "text": "template <typename T>  class Stack{  private:  size_t capacity;  size_t top{0};  T* buf;  public:  Stack(size_t capacity=0):  capacity{capacity},  buf{(capacity>0)? new T{capacity}:  nullptr}  }; \n\npublic class Stack<T>{\n    private int capacity = 0;\n    private int top = 0;\n    private T[] buf = null;\n    public Stack() {}\n    @SuppressWarnings(\"unchecked\")\n    public Stack(int capacity){\n        if(capacity<0)\n            throw new RuntimeException(\"\");\n        this.capacity = capacity;\n        buf = (T[])new Object[capacity];\n    }\n} \n\nclass Stack:  def __init__(self, capacity: int=0):  if capacity<0:  raise RuntimeError('init: capacity<0')  self.capacity = capacity  self.top = 0  self.buf = [None]*self.capacity if self.capacity>0 else None",
    "source": "ds-slide02_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 4,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0056"
  },
  {
    "type": "강의자료",
    "text": "## 기본 클격 비교 (1/8) \n\n● C++, 자바는 template 기능을 이용하여 구현 \n\n● C++는 나중에 타입 인자만큼의 클래스 구현을 만들어 처리함 \n\n● 적절하지 않은 타입 인자의 사용은 문법 검사를 통해 나타남 \n\n● 자바는 Object를 이용한 단일 구현을 통해 처리함 \n\n● 적절하지 않은 타입 인자의 사용은 실행 시간 예외를 통해 나타남 \n\n● 사용할 수 있는 타입 인자를 제한하여 이 문제를 해결함 \n\n● 참고. 자바는 타입 인자로 원시 타입을 사용할 수 없음 \n\n● autoboxing/unboxing 기능이 있어 원시 타입을 사용할 수 없어도 불편하지 않지만 전환 과정의 추가 비용이 소요됨 \n\n● 종종 별도 원시 타입 클래스를 만들어 사용하기도 함",
    "source": "ds-slide02_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 5,
      "page_heading": "## 기본 클격 비교 (1/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0057"
  },
  {
    "type": "강의자료",
    "text": "# 기본 골격 비교 (2/8) \n\n- 파이썬은 오리 타이핑(동적 타이핑)이기 때문에 template 기능을 통해 범용 자료구조를 구현하지 않음 \n\n- 하지만 오리 타이핑이기 때문에 동질 구조를 보장하지 못함 \n\n- 참고. 실제 파이썬 라이브러리는 파이썬을 이용하여 구현하지 않음 \n\n- 우리는 자료구조의 구현 방법을 이해하기 위해 파이썬을 통해 구현을 해보는 것임 \n\n- 파이썬에서 동질 구조를 보장하는 방법 \n\n- 생성할 때 유지할 타입 정보를 받아 항상 검사함 \n\nclass Stack: \n\ndef __init__(self, T: type = None, capacity: int=0): \n\nself.T = T \n\n# \n\n- 효율적인 방법은 아님 \n\ndef push(self, item): \n\nif not isinstance(item, self.T): \n\nraise TypeError(f'This stack can only store type {self.T}') \n\n# \n\nS = Stack(int, 10)",
    "source": "ds-slide02_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 6,
      "page_heading": "# 기본 골격 비교 (2/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0058"
  },
  {
    "type": "강의자료",
    "text": "# 기본 골격 비교 (3/8) \n\n- 또 다른 방법. 타입 힌트를 이용하여 구현하고, `mypy`와 같은 것을 이용하여 문법 검사를 함 \n\nfrom typing import TypeVar, Generic, List \n\nT = TypeVar('T') \n\nclass Stack(Generic[T]):\n    def __init__(self, capacity: int=0) -> None:\n    self.buf: List[T] = []\n    # \n\ndef push(self, item: T) -> None:\n    # \n\n- 여전히 실행 시간 오류 발생 가능",
    "source": "ds-slide02_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 7,
      "page_heading": "# 기본 골격 비교 (3/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0059"
  },
  {
    "type": "강의자료",
    "text": "## 기본 골격 비교 (4/8) \n\n● 자료구조는 기본적으로 저장된 요소의 개수 정보를 유지함 \n\n● 배열 기반 동적 자료구조의 경우에는 현재 사용 중인 배열의 용량도 유지하고 있어야 함 \n\n● 보통 이들 정보는 정수 타입에 유지하면 됨 \n\n● C++는 size_t에 보통 유지함 \n\n● size_t는부호가없는정수타입이며, sizeof 연산자가반환하는 타입임. 사용하는컴퓨팅환경에맞게설정되는타입임 \n\n● 자바와 파이썬은 부호가 없는 정수가 없으므로 그냥 int에 유지함 \n\n● 부호가 없는 정수를 사용하면 음수에 대한 예외 처리가 필요함 \n\n● 예외 처리하지 않고 기본 크기로 할당하여 처리할 수 있음 \n\n● 참고. 자바에서 배열 색인의 타입은 int이며, 배열의 가능한 최대 용량은 Integer.MAX_VALUE임",
    "source": "ds-slide02_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 8,
      "page_heading": "## 기본 골격 비교 (4/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0060"
  },
  {
    "type": "강의자료",
    "text": "## 기본 골격 비교 (5/8) \n\n● 배열 기반 동적 자료구조이므로 주어진 타입 인자에 맞는 배열을 동적 생성하여야 함 \n\n● 자바는 타입 인자가 주어졌을 때, new를 이용하여 해당 타입의 객체를 생성할 수 없고, 해당 타입의 객체를 유지하는 배열을 생성할 수 없음 \n\n● Object 배열을 생성한 후 타입 변환하는 것이 가장 효과적인 구현 방법임 \n\n● 파이썬은 배열이 아니라 리스트를 이용하여 구현하게 됨 \n\n● 파이썬을 이용한 자료구조 구현 실습은 어색한 것이 많음",
    "source": "ds-slide02_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 9,
      "page_heading": "## 기본 골격 비교 (5/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0061"
  },
  {
    "type": "강의자료",
    "text": "## 기본 골격 비교 (6/8) \n\n● 자료구조는 보통 여러 개의 생성자를 제공해야 할 수 있음 \n\n● C++와 파이썬은 기본 인자를 이용하여 제공하는 생성자의 수를 줄일 수 있음 \n\n● 자바는 기본 인자를 사용할 수 없어 다중 정의가 불가피함 \n\n● 파이썬은 다중 정의가 가능하지 않음 (동적 언어) \n\n● 기본인자, 가변인자, 키워드인자로비슷한효과를낼수있음 \n\n● C++는동적배열을내부멤버변수로유지하고있으므로빅5의 구현이불가피함 \n\n● 소멸자, 복사 생성자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자 \n\n● copy-and-swap idiom을 활용하면 코드 중복을 제거할 수 있음 \n\n● 자바는 복제 기능을 제공하고 싶으면 clone을 재정의해 주어야 함 \n\n● 파이썬은 복제 기능이 필요하면 copy 모듈을 이용하면 됨 \n\n● copy.copy(x), copy.deepcopy(x)",
    "source": "ds-slide02_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 10,
      "page_heading": "## 기본 골격 비교 (6/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0062"
  },
  {
    "type": "강의자료",
    "text": "# 5, copy-and-swap idiom \n\n**Stack(const Stack& other):**\n**capacity{other.capacity}, top{other.top}, buf{new T{capacity}}{\nstd::copy(other.buf, other.buf+capacity, buf);\n}**\n\n**Stack(Stack&& tmp) noexcept:**\n**capacity{tmp.capacity}, top{tmp.top}, buf{tmp.buf}{\ntmp.top = 0;\ntmp.buf = nullptr;\n}**\n\n**const Stack& operator=(const Stack& other){**\n**if(this!=&other){**\n**Stack tmp(other);**\n**swap(tmp);**\n**}**\n\n**void swap(Stack& other) noexcept{**\n**std::swap(capacity, other.capacity);**\n**std::swap(top, other.top);**\n**std::swap(buf, other.buf);**\n**}**\n\n**return *this;**\n\n**const Stack& operator=(Stack&& tmp) noexcept{\nswap(tmp);\nreturn *this;\n}**\n\n**const Stack& operator=(Stack other){\nswap(other);\nreturn *this;\n}**",
    "source": "ds-slide02_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 11,
      "page_heading": "# 5, copy-and-swap idiom",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0063"
  },
  {
    "type": "강의자료",
    "text": "## 기본 골격 비교 (8/8) \n\n● 복사 생성자, 복사 대입 연산자는 내부적으로 하는 일은 거의 같음 \n\n● 차이점은 복사 생성자는 객체를 생성할 때 사용하는 것이고, 복사 대입 연산자는 기존 객체의 내부 내용을 바꾸는 것임 \n\n● 이 개념은 이동 생성자, 이동 대입 연산자에도 적용됨 \n\n● copy-and-swap idiom을 적용하면 모든 자료구조의 복사 대입 연산자와 이동 대입 연산자를 항상 동일하게 구현할 수 있음 \n\n● 예외 발생 위치도 제한할 수 있음",
    "source": "ds-slide02_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 12,
      "page_heading": "## 기본 골격 비교 (8/8)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0064"
  },
  {
    "type": "강의자료",
    "text": "# 초깃값 목록 (1/3) \n\n- C++는 std::initializer_list를 이용하여 초깃값 목록을 받는 생성자를 정의할 수 있음 \n\nStack(const std::initializer_list<T>& initList):\n    capacity{initList.size()}, top{capacity}, buf{new T{capacity}}{\n    std::copy(initList.begin(), initList.end(), buf);\n    } \n\n- 초깃값 목록을 받는 생성자를 정의할 경우 중괄호를 이용한 자료구조를 생성할 때 주의해야 함 \n\nstd::vector<int> vec1{5, 1}; // capacity = 2, size = 2, [5,1]\nstd::vector<int> vec2{5,1}; // capacity = 5, size = 5, [1,1,1,1,1] \n\n- 타입 인자가 정수일 경우에만 주의 필요",
    "source": "ds-slide02_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 13,
      "page_heading": "# 초깃값 목록 (1/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0065"
  },
  {
    "type": "강의자료",
    "text": "# 초깃값 목록 (2/3) \n\n## ● 자바 \n\n### ● 가변 인자를 이용하여 초깃값 목록 기능을 제공할 수 있음 \n\n@SafeVarargs\npublic Stack(T... initList){\n    this(initList.length);\n    for(var item: initList) push(item)\n} \n\n- 자바에서 가변 인자의 이점은 인자를 나열하지 않고 배열을 대신 전달할 수 있는 것이지만 범용 클래스의 타입 인자가 원시타입이 될 수 없으므로 원시 타입 배열을 인자로 전달할 수 없음 \n\n- Stack<Integer> s = new Stack<>(1,2,3,4,5); // ok \n\n- Stack<Integer> s = new Stack<>(nums); // error (nums: int[]) \n\n- 가변 인자와 일반 인자를 받는 메소드를 다중 정의할 경우 일반 인자를 받는 것이 우선적으로 바인딩됨 \n\n- A(), A(int), A(int...) 있을 때 다음은 어느 것과 바인딩? \n\n- A a1 = new A()\n- A a2 = new A(1)\n- A a3 = new A(2,3)",
    "source": "ds-slide02_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 14,
      "page_heading": "# 초깃값 목록 (2/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0066"
  },
  {
    "type": "강의자료",
    "text": "# 초깃값 목록 (3/3) \n\n## ● 파이썬 \n\n### ● 자바와 마찬가지로 가변 인자를 이용할 수 있음 \n\ndef __init__(self, *initList, capacity=0):\n    if capacity<0: raise RuntimeError('init: capacity<0')\n    values = initList[0] if len(initList) == 1 and isinstance(initList[0], list) else list(initList)\n    self.capacity = max(len(values), capacity)\n    self.buf = [None]*self.capacity\n    self.buf[:len(values)] = values\n    self.top = len(values) \n\n- 파이썬에서 가변 인자는 tuple임\n- 가변 인자를 이용하면서 리스트를 이용하여 초깃값 목록도 제시할 수 있도록 할 경우 제시한 개수를 이용하여 구분하여야 함\n  len(initList) == 1 and isinstance(initList[0], list)",
    "source": "ds-slide02_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 15,
      "page_heading": "# 초깃값 목록 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0067"
  },
  {
    "type": "강의자료",
    "text": "## 소멸자 또는 clear \n\n● C++는 동적할당한 것을 직접 반납해 주어야 함 \n\n● 빅5에 소멸자가 포함되어 있음 \n\n● 스택에서 clear는 공간 반납 없이 top을 0로 설정하면 됨 \n\n● 자바와 파이썬은 동적할당한 것을 직접 반납하지 않음 \n\n● 자바는 소멸자 개념이 없음 \n\n● 파이썬은 __del__ dunder 메소드를 정의하여 소멸자에서 해야 할\n일을 정의할 수 있지만 여기서 동적할당한 것을 반납할 필요는 없음 \n\n● 연결구조나 트리를 학습하게 되면 동적할당한 여러 노드를 clear\n메소드에서 반납해 주어야 함 (이 경우 clear를 소멸자에서 활용함) \n\n● 자바와 파이썬은 이와 같은 자료구조에서도 반납에 대한 고려가 필요 없음 \n\n● 쓰레기 수집을 촉진하기 위해 사용한 참조 변수를 null로 바꾸는 것이 필요하다고 생각할 수 있지만 이는 잘못된 생각임 \n\n● 연결구조와 같은 경우 head만 null로 바꾸어주면 나머지\n노드들도 자동으로 쓰레기 수집 대상이 됨",
    "source": "ds-slide02_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 16,
      "page_heading": "## 소멸자 또는 clear",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0068"
  },
  {
    "type": "강의자료",
    "text": "# 복합 타입의 저장 (1/2) \n\nvoid push(const T& item){\n    if(top==capacity) increaseCapacity();\n    buf[top++] = item;\n}\n\nvoid push(T&& item){\n    if(top==capacity) increaseCapacity();\n    buf[top++] = std::move(item);\n}\n\n- C++는 효율성을 매우 중요하게 고려하는 언어임 \n\n- 타입 인자로 무거운 복합타입을 사용할 수 있으므로 다양한 버전의 삽입 연산을 제공함 \n\n- 보통 Lvalue에 최적화된 버전, Rvalue에 최적화된 버전, emplace 버전을 제공함 \n\ntemplate <typename... Ts>\nvoid emplace(Ts&&... args){\n    if(top==capacity) increaseCapacity();\n    new (&buf[top++]) T(std::forward<Ts>(args)...);\n}\n\n- 전달할 인자를 호출할 때 생성할 경우에는 T&& item 버전 대신에 생성할 때 사용할 인자를 전달하는 emplace가 더 효율적인 방법임\n- emplace는 가변 인자 template 기능, 완벽 포워딩, 특정 위치에 동적할당하는 기법을 사용하여 구현함",
    "source": "ds-slide02_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 17,
      "page_heading": "# 복합 타입의 저장 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0069"
  },
  {
    "type": "강의자료",
    "text": "# 복합 타입의 저장 (2/3) \n\n- 자바와 파이썬은 항상 참조 변수를 이용하여 전달하므로 C++처럼 효율성을 위해 여러 버전을 다중 정의할 필요가 없음 \n\n- 참조 변수를 이용하여 인자를 전달하면 실제 내부 배열에 유지하는 것이 위치 정보이므로 저장된 요소의 위치 정보를 별도 유지하고 있으면 자료구조의 캡슐화를 위배한 상태에서 자료구조가 유지하는 요소의 상태를 변경할 수 있음 (보통 C++는 항상 복제하여 저장) \n\n- 이 문제는 복사본을 저장하여 해결할 수 있음 \n\n- 하지만 코드가 매우 복잡해지며, 복제 비용 때문에 효율성도 떨어짐 \n\n- 자바에서 불변 객체의 경우에는 자료구조 내에 위치 정보를 유지하여도 같은 문제가 발생하지 않음 \n\npublic void push(T item){\n    if(top==capacity) increaseCapacity();\n    buf[top++] = item.clone();\n} \n\n- 사용하는 타입 인자가 clone을 제공하지 않을 수 있음\n- String 같은 불변 객체는 복제하여 저장할 필요가 없음\n- 내부 구현은 이를 고려하지 않고 구현하고 사용하는 측에서 필요하면 push(item.clone()) 형태로 사용해야 함",
    "source": "ds-slide02_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 18,
      "page_heading": "# 복합 타입의 저장 (2/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0070"
  },
  {
    "type": "강의자료",
    "text": "# 복합 타입의 저장 (3/3) \n\n- C++는 복합 타입의 데이터를 효과적으로 저장하기 위해 보통 3종류의 삽입 연산을 제공함 \n\n- 효율성이나 다른 목적 때문에 데이터 자체를 유지하는 것이 아니라 자바/파이썬처럼 C++도 데이터의 주소를 유지할 수 있음 \n\n- 데이터의 주소를 유지할 경우 장단점 \n\n<table><tr><td>장점</td><td>단점</td></tr><tr><td>매우 효과적으로 저장 및 추출할 수 있음<br/>여러 버전의 삽입 연산이 필요하지 않음<br/>효과적으로 요소의 위치를 swap할 수 있음</td><td>자료구조의 캡슐화가 위배될 수 있음<br/>데이터의 메모리 관리가 힘들<br/>캐싱 효과가 반감됨</td></tr></table>\n\n- 메모리 관리 문제로 여러 자료구조를 결합하여 사용할 때\n  한 자료구조에 실제 데이터를 유지하고, 다른 하나는 주소를\n  유지하는 경우가 종종 있음",
    "source": "ds-slide02_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 19,
      "page_heading": "# 복합 타입의 저장 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0071"
  },
  {
    "type": "강의자료",
    "text": "# 동적 배열 기법 \n\nvoid increaseCapacity(){  if(capacity==0){  capacity = 1;  buf = new int[capacity];  }  else{  capacity *= 2;  T* tmp{new T[capacity]};  std::copy(buf, buf+top, tmp);  delete [] buf;  buf = tmp;  } \n\ndef increaseCapacity(self):  if self.capacity==0:  self.capacity = 1  self.buf = [None]  else:  self.buf += [None]*self.capacity  self.capacity *= 2 \n\nprivate void increaseCapacity() {  if(capacity==0) {  capacity = 1;  buf = (T[])new Object[capacity];  }  else {  capacity *= 2;  buf = Arrays.copyOf(buf, capacity);  }  } \n\n- 동적 배열 기법은 평균 비용과 공간 낭비를 최소화하기 위해 용량이 부족할 때 보통 2배로 확장함\n- 자바는 기존 데이터를 복사하면서 배열 용량 변경하고 싶으면 Arrays.copyOf를 사용함\n- 파이썬은 += 연산자를 통해 구현하는 것이 가장 간결함 (extend를 이용할 수 있음)\n  - a = a + [0,0,0]\n  - a += [0,0,0]    차이점\n  - a.extend([0,0,0])",
    "source": "ds-slide02_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 20,
      "page_heading": "# 동적 배열 기법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0072"
  },
  {
    "type": "강의자료",
    "text": "# 2배로 확장하는 이유 (1/2) \n\n- 분할 상황 분석: 평균 비용 분석 \n\n- 매번 \\(k\\)개씩 확장하는 경우와 2배로 확장하는 경우의 비교 \n\n- 부족할 때 두 배로 확장: \\(O(1)\\) \n\n\\[\n\\text{● } c_i = 1 + \\begin{cases} i - 1 & i - 1 \\mid 2 \\\\ 0 & \\text{나머지 경우} \\end{cases}\n\\]\n\n\\[\n\\text{● 대입 연산 비용 중심} \\\\\n\\text{● 실제 확장할 때는 보통} \\\\\n\\text{매모리 복사 비용 발생}\n\\]\n\n\\[\n\\sum_{i=1}^{n} c_i = n + \\sum_{j=1}^{\\lfloor \\log_2(n-1) \\rfloor} 2^j = n + 2^{\\lfloor \\log_2(n-1) \\rfloor+1} - 1 \\approx n + 2(n-1) - 1\n\\]\n\n- \\(k\\)개씩 확장: \\(O(n)\\) \n\n\\[\n\\text{● } c_i = 1 + \\begin{cases} i - 1 & i - 1 \\mid k \\\\ 0 & \\text{나머지 경우} \\end{cases}\n\\]\n\n\\[\n\\sum_{i=1}^{n} c_i = n + \\sum_{j=1}^{[n/k]} kj = n + \\frac{n^2 + nk}{20}\n\\]",
    "source": "ds-slide02_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 21,
      "page_heading": "# 2배로 확장하는 이유 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0073"
  },
  {
    "type": "강의자료",
    "text": "## 2배로 확장하는 이유 (2/2) \n\n● s(>1)배로 확장하면 평균 비용은 O(1)임 \n\n● 보통 2배로 확장하지만 자바 ArrayList는 1.5배, Python의 list는 1.125배로 확장함 \n\n● 하지만 현재 사용 중인 용량이 클 때 공간 확장 이후 삽입한 데이터의 수가 적으면 많은 공간이 낭비될 수 있음 \n\n● 이 문제 때문에 더 이상 데이터 삽입이 필요 없는 경우에는 불필요한 공간을 반납할 수 있는 메소드를 보통 제공함 \n\n● C++의 std::vector: shrink_to_fit \n\n● 자바의 ArrayList: trimToSize \n\n● 파이썬: del A[numltems:], A = A[:numltems] \n\n● 이 반납은 increaseCapacity와 동일하게 동작함 \n\n● 현재 크기만큼의 새 배열을 확보하고 기존 데이터를 옮긴 후 기존 배열 전체를 반납하는 형태임",
    "source": "ds-slide02_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 22,
      "page_heading": "## 2배로 확장하는 이유 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0074"
  },
  {
    "type": "강의자료",
    "text": "# 동적 배열 기법 사용 자료구조 사용법 \n\n- 자료구조를 생성할 때 저장할 데이터 개수를 미리 알면 그것에 맞는 적절한 용량을 확보해 주어야 더 효과적으로 사용할 수 있음 \n\n- 내부적으로 여러 번 자동 확장하는 것보다 처음에 충분히 확보하는 것이 효과적임 \n\n- 이것은 생성할 때만 적용되는 것은 아닌 \n\n- 특정 시점 이후 많은 데이터를 저장해야 한다면 내부적으로 여러 번 자동 확장하도록 하는 것보다 그 시점에서 충분히 확장한 후에 데이터를 저장하는 것이 효과적인 방법임",
    "source": "ds-slide02_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 23,
      "page_heading": "# 동적 배열 기법 사용 자료구조 사용법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0075"
  },
  {
    "type": "강의자료",
    "text": "# 복합 타입의 반환 (1/2) \n\n- C++는 인자 전달과 마찬가지로 값 반환할 경우에도 무거운 데이터는 복사 비용이 많이 소요될 수 있음 \n\n- 조회 연산은 배열의 요소를 반환하면 되므로 참조 타입으로 반환할 수 있음 \n\n- 그런데 받은 참조를 이용하여 저장된 요소의 상태를 변경할 수 있으므로 수정불가 참조로 반환해야 함 \n\n- 참조로 반환하면 참조로 받아야 비용 절감 효과를 얻을 수 있음 \n\n- 추출 연산은 더 이상 해당 요소를 배열에 유지할 것이 아니므로 참조 타입으로 반환할 수 없음 \n\n- 하지만 RVO 최적화는 적용됨 \n\nconst T& peek() const{\n    if(isEmpty()) throw std::logic_error(\"\");\n    return buf[top-1];\n}\n\nT pop(){\n    if(isEmpty()) throw std::logic_error(\"\");\n    T ret{std::move(buf[top-1]);\n    --top;\n    return ret; // std::move(buf[top]);\n}",
    "source": "ds-slide02_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 24,
      "page_heading": "# 복합 타입의 반환 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0076"
  },
  {
    "type": "강의자료",
    "text": "# 복합 타입의 반환 (2/2) \n\n- 자바와 파이썬은 주소를 유지하고 있으므로 효율성을 걱정할 필요는 없음 \n\n- 하지만 조회 연산의 경우 받은 주소를 이용하여 저장된 요소의 상태를 변경할 수 있으므로 복제하여 반환할 필요가 있음 \n\n- 이 부분도 모든 경우에 필요한 것이 아니므로 자료구조 자체에서 복제하여 반환하는 형태로 구현하지는 않음",
    "source": "ds-slide02_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 25,
      "page_heading": "# 복합 타입의 반환 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0077"
  },
  {
    "type": "강의자료",
    "text": "# 추출과 삭제 연산 \n\n- 배열 기반 자료구조에서 추출 또는 삭제할 경우 \n\n- C++는 크기 정보만 변경하고 실제 배열에 대해서는 어떤 조치도 하지 않음 \n\n- 자바에서 객체 배열의 경우에는 크기 정보뿐만 아니라 해당 배열 요소 값을 null로 바꾸어 쓰레기 수집이 될 수 있도록 함 \n\n- 파이썬도 비슷한 이유로 None으로 바꾸어 줄 수 있음 \n\npublic T pop() {\n    if(isEmpty()) throw new ...;\n    T ret = buf[top-1];\n    buf[top-1] = null;\n    --top;\n    return ret;\n}",
    "source": "ds-slide02_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 26,
      "page_heading": "# 추출과 삭제 연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0078"
  },
  {
    "type": "강의자료",
    "text": "## 반복자 (1/2) \n\n● 자료구조는 보통 자료구조에 저장된 요소를 차례로 방문할 수 있게 해주는 반복자를 제공함 \n\n● C++는 두 개의 객체를 이용한 포인터 개념을 활용한 반복자를 사용함 \n\n● 자바는 hasNext, next를 이용한 반복자를 사용함 \n\n● 파이썬은 next를 이용한 반복자를 사용함 \n\n● 참고. 원래는 hasNext, next, get 3가지 연산을 사용해야 역할 분리가 확실하게 이루어진 형태임 (함수의 응집성, command-query 분리) \n\n● C++는 일반 반복자, 수정불가 반복자, 거꾸로 반복자 등 해당 자료구조 특성에 맞는 다양한 반복자를 만들어 제공함 \n\n● 정의하는 방법이 상대적으로 복잡함 \n\n● 스택은 보통 반복자를 제공하지 않는 자료구조임",
    "source": "ds-slide02_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 27,
      "page_heading": "## 반복자 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0079"
  },
  {
    "type": "강의자료",
    "text": "# 반복자 (2/2) \n\n- C++와 자바는 보통 내부 클래스로 반복자 클래스를 구현함 \n\n  - 응집성 측면에서 바람직한 방법 \n\n  - 파이썬도 내부 클래스로 구현 가능하지만 C++와 마찬가지로 자동으로 외부 클래스 데이터를 접근할 수 없음 \n\n- 자바는 반복자를 제공하는 클래스는 Iterable<T> interface를 구현하며, 반복자는 Iterator<T> interface를 구현함 \n\n- 파이썬에서 반복자를 제공하는 클래스는 __iter__를 구현해야 하며, 반복자는 __next__ 메소드를 구현해야 함 (collections의 Iterator) \n\nclass StackIterator:\n    def __init__(self, toplndex, buf):\n    self.it = toplndex\n    self.buf = buf\n    def __next__(self):\n    if self.it<0: raise StopIteration\n    self.it -= 1\n    return self.buf[self.it+1]",
    "source": "ds-slide02_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 28,
      "page_heading": "# 반복자 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0080"
  },
  {
    "type": "강의자료",
    "text": "C++ 반복자 \n\n○ C++는 2개의 객체를 이용하기 때문에\n특정 구간을 반복하기 용이함 \n\ntemplate <typename U> \n\nclass StackIterator: public std::iterator<std::input_iterator_tag, U>{\n    U* p;\npublic:\n    explicit StackIterator(U* p): p{p} {}\n    const StackIterator& operator++() noexcept {-p; return *this;}\n    StackIterator operator++(int) noexcept {\n        auto retval{\"this\"; ++(*this); return retval;}\n        bool operator==(const StackIterator& other) const noexcept {\n            return p == other.p;}\n        bool operator!=(const StackIterator& other) const noexcept {\n            return p != other.p;}\n        U& operator*() noexcept {return *p;}\n    }; \n\nauto begin() {return StackIterator<T>(buf+top-1);}\nauto end() {return StackIterator<T>(buf-1);}\nconst auto begin() const {return StackIterator<const T>(buf+top-1);}\nconst auto end() const {return StackIterator<const T>(buf-1);}\nauto cbegin() const {return StackIterator<const T>(buf+top-1);}\nauto cend() const {return StackIterator<const T>(buf-1);}",
    "source": "ds-slide02_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 29,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0081"
  },
  {
    "type": "강의자료",
    "text": "# 자바/파이썬 반복자 \n\nprivate class StackIterator implements Iterator<T>{\n    int curr = top-1;\n    @Override public boolean hasNext() {\n    return curr>=0;\n    }\n    @Override public T next() {\n    T ret = buf[curr];\n    --curr;\n    return ret;\n    }\n} \n\n@Override public Iterator<T> iterator() {\n    return new StackIterator();\n} \n\n- 자바에서 반복자를 내부 클래스로 정의하면 데이터가 유지된 외부클래스 멤버 변수에 접근하기가 용이함 \n\ndef __iter__(self):\n    self.it = self.top-1\n    return self \n\ndef __next__(self):\n    if self.it<0: raise StopIteration\n    self.it -= 1\n    return self.buf[self.it+1]",
    "source": "ds-slide02_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 30,
      "page_heading": "# 자바/파이썬 반복자",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0082"
  },
  {
    "type": "강의자료",
    "text": "# 단위 테스팅 (1/2) \n\n- **C++는 googletest, 자바는 JUnit5, 파이썬은 unittest로 모듈을 이용함** \n\n- **단위 테스트는 함수 단위로 코드를 검증하는 것임** \n\n- **테스트 기반 개발하기 위해서는 단위 테스팅 도구 사용이 필요함** \n\n- **각 함수를 검증할 테스트 함수를 작성함** \n\n- **한 함수를 검증하기 위한 여러 테스트 함수를 작성할 수 있음** \n\n- **이 테스트 함수는 아래 assertion을 이용하여 기대하는 값과 결과 값이 같은지 확인함** \n\n<table><tr><td>C++</td><td>자바</td><td>파이썬</td></tr><tr><td>ASSERT_EQ</td><td>assertEquals</td><td>assertEquals</td></tr><tr><td>ASSERT_TRUE</td><td>assertTrue</td><td>assertTrue</td></tr><tr><td>ASSERT_FALSE</td><td>assertFalse</td><td>assertFalse</td></tr><tr><td>ASSERT_THROW</td><td>assertThrow</td><td>assertRaises</td></tr></table>",
    "source": "ds-slide02_page_31",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 31,
      "page_heading": "# 단위 테스팅 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0083"
  },
  {
    "type": "강의자료",
    "text": "단위 테스팅 (2/2) \n\n<table><tr><td>C++</td><td>자바</td><td>파이썬</td></tr><tr><td>ASSERT_PREDn</td><td>assertArrayEquals<br/>assertAll<br/>assertIterableEquals<br/>assertNotEqual<br/>assertNull<br/>assertNotNull<br/>assertSame<br/>assertNotSame<br/>assertTimeout</td><td>assertIn<br/>assertNotIn<br/>assertIsNone<br/>assertIsNotNone<br/>assertSameElements<br/>assertSequenceEqual<br/>assertDictEqual<br/>assertSetEqual<br/>assertListEqual<br/>assertTupleEqual</td></tr></table>\n\n- Googletest는 EXPECT와 ASSERT 두 종류가 있음 \n\n- EXPECT은 실패하여도 그 이후 테스트를 계속 검사하지만\n  ASSERT는 실패하면 테스트를 중단함 \n\n- 테스트를 skip 하는 방법 \n\n<table><tr><td>C++</td><td>자바</td><td>파이썬</td></tr><tr><td>테스트 이름 앞에<br/>DISABLED_ 추가</td><td>@Disabled<br/>@Test를 주석 처리</td><td>@unittest.skip</td></tr></table>",
    "source": "ds-slide02_page_32",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 32,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0084"
  },
  {
    "type": "강의자료",
    "text": "## 기타 (1/5) \n\n● C++는 연산자를 다중 정의할 수 있으므로 이를 이용하여 자료구조 연산을 많이 제공함 \n\n● 예) 리스트 자료구조에서 색인 연산자 \n\n● 색인 연산자는 일반 메소드와 const 메소드 두 버전을 정의해야 함 \n\nconst T& operator[](size_t index) const{  if(index>=size) throw std::out_of_range(\"\");  return buf[index];  } \n\nT& operator[](size_t index){  return const_cast<T&>(std::as_const(*this)[index]);  } // C++17 코드 중복 제거 버전 \n\n● 파이썬은 __len__, __getitem__, __setitem__, __contains__ 등의 dunder 메소드를 재정의하여 함수 호출 대신에 연산자를 이용하여 자료구조를 조작할 수 있음",
    "source": "ds-slide02_page_33",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 33,
      "page_heading": "## 기타 (1/5)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0085"
  },
  {
    "type": "강의자료",
    "text": "## 기타 (2/5) \n\n● find 연산 (스택은 제공하지 않는 연산) \n\n● 보통 자료구조는 저장된 요소 중에 찾고자 하는 요소가 있는지 여부를 알려주는 find 연산을 제공함 \n\n● 찾고자 하는 요소가 있는지 여부는 find 뿐만 아니라 remove 등 다른 연산에서도 필요함 \n\n● 이를 위해 요소가 있는지 여부를 반환하는 것이 아니라 있으면 그것의 위치를 반환하는 버전을 만들어 코드 중복을 많이 제거함 \n\n● 찾고자 하는 요소가 있는 위치를 반환하는 연산의 경우에는 요소가 없을 때 반환해야 하는 값을 결정하기 어려울 수 있음 \n\n● 배열은 음의 색인을 가질 수 없고 용량보다 클 수 없으므로 -10이나 capacity를 반환할 수 있음 \n\n● 각 자료구조마다 없을 때 반환하는 값의 일관성을 유지하기 힘들 \n\n● 이때 C++는 std::optional, 자바는 Optional 범용 클래스를 활용하면 효과적으로 구현할 수 있음 \n\n● 파이썬은 항상 None을 이용할 수 있음",
    "source": "ds-slide02_page_34",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 34,
      "page_heading": "## 기타 (2/5)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0086"
  },
  {
    "type": "강의자료",
    "text": "## 기타 (3/5) \n\nstd::optional<int> search(const T& item){  for(size_t i{0}; i<numItems; ++i)  if(items[i]==item) return std::optional<int>(i);  return std::nullopt;  } \n\nOptional<Integer> search(T item){  for(int i=0; i<numItems; ++i)  if(items[i].equals(item)) return Optional.of(i);  return Optional.empty();  } \n\n Optional의사용은가독성향상에도움이됨  반환값에대한고민이없어짐  자바는함수프로그래밍과결합하면매우효과적으로 프로그래밍할수있음  값자체가C++의경우nullptr, 자바의경우null일 수있으면이들을이용하기힘들",
    "source": "ds-slide02_page_35",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 35,
      "page_heading": "## 기타 (3/5)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0087"
  },
  {
    "type": "강의자료",
    "text": "## 기타 (4/5) \n\n● 이전슬라이드의선형검색의경우 \n\n● C++: == 연산자를 이용함 \n\n● 자바: equals 메소드를 이용함 \n\n● 해당타입이equals 메소드를올바르게재정의하고있어야함 \n\n● 파이썬: == 연산자를 이용하여 구현함 \n\n● 해당타입이__eq__ 메소드를올바르게재정의하고있어야함 \n\n● 참고. ==(equality) vs. is(identity, 주소 비교) \n\n● C++는 순위 비교가 필요한 연산자를 이용하고, 파이썬도 동일함 \n\n● 파이썬은 해당 타입이 __It__와 같은 dunder 메소드가 구현되어 있어야 함 \n\n● 자바는 해당 타입이Comparable interface를 구현하고 있어야 하며, compareTo 메소드를 이용함",
    "source": "ds-slide02_page_36",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 36,
      "page_heading": "## 기타 (4/5)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0088"
  },
  {
    "type": "강의자료",
    "text": "## 기타 (5/5) \n\n● 자바의 경우 내부 클래스를 정의할 때 static 내부 클래스로 정의할 수 있으며, 이 경우에는 자동으로 외부 클래스의 타입 매개변수를 내부 클래스에서 사용할 수 없음 \n\n● static 내부 클래스에서 외부 클래스의 타입 매개변수를 그대로 사용하고 싶으면 내부 클래스도 범용 클래스로 정의해야 함 \n\nprivate static class Node<T>{\n    T item;\n    Node<T> next;\n} \n\n● 자바에서 범용 자료구조를 정의할 때 정렬 리스트처럼 타입 인자를 Comparable interface를 구현하고 있는 타입으로 제한할 필요가 있음 \n\npublic class SortedArrayList<T extends Object & Comparable<? super T>> implements Iterable<T>{\n// \n} \n\n● Dog이 Pet의 자식 클래스이고, Pet이 Comparable<Pet>을 구현하고 있으면 Dog도 Comparable<Dog>이 아니라 Comparable<Pet>를 구현하고 있음",
    "source": "ds-slide02_page_37",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 37,
      "page_heading": "## 기타 (5/5)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0089"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide02_page_38",
    "meta_data": {
      "tables": [],
      "lecture_title": "자료구조의 구현",
      "page_no": 38,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0090"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n## 리스트: 배열 기반 \n\nNOTE 03 \n\n![](images/0_2.jpg)\n\n## 한국기술교육대학교 컴퓨터공학부  김상진 \n\n![](images/0_3.jpg)\n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide03_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 1,
      "page_heading": "## 리스트: 배열 기반",
      "images": [
        "ds-slide03/images/0_0.jpg",
        "ds-slide03/images/0_1.jpg",
        "ds-slide03/images/0_2.jpg",
        "ds-slide03/images/0_3.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0091"
  },
  {
    "type": "강의자료",
    "text": "# 교육목표 \n\n- 배열 \n\n- C++, 자바, 파이썬3 \n\n- 배열 기반 리스트 \n\n- 비정렬, 정렬리스트 \n\n- 순환 배열 \n\n- C++ vector, Java ArrayList, Python3 list",
    "source": "ds-slide03_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 2,
      "page_heading": "# 교육목표",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0092"
  },
  {
    "type": "강의자료",
    "text": "## 배열 \n\n● 원시타입(primitive type)은 값을 하나만 유지함 \n\n● 같은 종류의 여러 개의 값을 하나의 데이터로 취급(하나의 이름을 이용하여 접근)할 수 있도록 해주는 타입을 배열(array)이라 함 \n\n![](images/2_0.jpg)\n\n● 배열처럼 여러 개의 값으로 구성될 수 있는 타입을 복합 타입 (composite type)이라 함 \n\n● 40명 학생의 성적을 처리하기 위해 40개의 정수 변수를 사용할 수 있지만 이렇게 하는 것은 번거로움 \n\n● 대신 정수 40개로 구성된 배열을 선언하여 사용하는 것이 편리함 \n\n![](images/2_1.jpg)",
    "source": "ds-slide03_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 3,
      "page_heading": "## 배열",
      "images": [
        "ds-slide03/images/2_0.jpg",
        "ds-slide03/images/2_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0093"
  },
  {
    "type": "강의자료",
    "text": "## 배열의 특성 \n\n● 동질 구조(homogeneous structure): 구조에 있는 모든 요소는 같은 타입임 \n\n● 예) 일차원 배열의 첫 슬롯에 개수를 유지하고 나머지 슬롯에 정수 값을 저장한 배열, C언어에서 문자열 \n\n● 물리적으로 동질 구조이지만 논리적으로는 동질 구조가 아님 \n\n● 요소 간의 순서가 존재함 (ordered) \n\n● 배열의 요소는 위치에 의해 접근됨 (index: 0부터 시작) \n\n● 배열의 용량은 컴파일 시간에 정해짐 \n\n● 배열의 모든 슬롯에 유효한 요소가 들어있을 필요는 없음 \n\n● 배열의 용량을 변경할 수 없음 \n\n● 있는 그 자리에서는 절대 확장할 수 없음 \n\n● 임의 접근 제공: 모든 요소를 바로 접근할 수 있음 \n\n● 용량이 고정되어 있고 연속된 공간에 유지되며, 동질 구조(각 요소의 크기가 같음)이기 때문에 가능한 것임 \n\n● 용량(capacity): 배열에 저장할 수 있는 최대 요소의 개수\n● 크기(size): 배열에 현재 저장되어 있는 요소의 개수",
    "source": "ds-slide03_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 4,
      "page_heading": "## 배열의 특성",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0094"
  },
  {
    "type": "강의자료",
    "text": "## C++ 배열 (1/2) \n\nvoid foo(int nums[], int size); void foo(int (&nums)[10]); \n\n● 자동 배열, 동적 배열 두 종류가 존재함 \n\n● 자동 배열 변수는 상수 포인터임 \n\n● 초깃값 목록을 이용하여 배열을 초기화할 때 용량보다 적은 수의 초깃값을 제시할 수 있음 \n\n● 보통 배열을 인자로 전달할 때는 주소 전달 방식을 사용함 \n\n● 주소 전달 방식의 이점. 하나의 함수로 같은 타입의 다양한 용량의 배열을 전달할 수 있음 \n\n● 참고. 참조 전달도 가능 \n\n● 정해진 용량의 배열만 전달할 수 있지만 해당 함수에서 인자를 배열로 인식함 \n\n● 주소 전달 방식을 사용하면 배열의 크기나 용량을 함께 전달해야 함 \n\n● 강건성을 위해 수정이 필요 없는 경우 매개변수에 const 사용이 필요함 \n\n● 동적 배열을 반납할 경우에는 delete []를 사용해야 함 \n\n● 다차원 배열의 동적 할당은 문법이 복잡함",
    "source": "ds-slide03_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 5,
      "page_heading": "## C++ 배열 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0095"
  },
  {
    "type": "강의자료",
    "text": "# C++ 배열 (2/2) \n\n## ● 동적 배열 \n\nint* a = new int[4];\ndelete [] a; \n\n## ● 2차원 동적배열 \n\nint** list = new int*[5];\nfor(int i=0; i<5; i++)\n    list[i] = new int[10];\n...\nfor(int i=0; i<5; i++)\n    delete [] list[i];\ndelete [] list; \n\nint (*list)[10](new int[5][10]);\n...\ndelete [] list;\nauto list(new int[5][10]);\n...\ndelete [] list; \n\n포인터 배열을 이용 \n\nint (*list)[10] = reinterpret_cast<int*>(10)->(new int[50]0); // C++03\n...\ndelete [] list; \n\n강제 타입 변환 활용",
    "source": "ds-slide03_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 6,
      "page_heading": "# C++ 배열 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0096"
  },
  {
    "type": "강의자료",
    "text": "# 장간. \n\nint &a[5]\nint (&a)[5] \n\nint *a[5]\nint (*a)[5] \n\nPrecedence \n\n1 \n\n2 \n\na \n\na[1] \n\n. -> \n\n+ \n\n+ \n\n+ \n\n! \n\n( \n\n( \n\n* \n\n& \n\nsizeof \n\nco_await \n\nnew_new[1] \n\ndelete_delete[1] \n\nDynamic memory deallocation \n\nPrecedence \n\n1 \n\n2 \n\na \n\na[1] \n\n. -> \n\n+ \n\n+ \n\n+ \n\n! \n\n( \n\n( \n\n* \n\n& \n\nsizeof \n\nco_await \n\nnew_new[1] \n\ndelete_delete[1] \n\nDynamic memory deallocation \n\nAssociativity \n\nLeft-to-right \n\nLeft-to-right \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\nint (*a)[5] \n\n1 \n\n2 \n\n3 \n\na \n\na[1] \n\n. -> \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n+ \n\n선언에서 기호는 연산자가 아님 \n\n하지만 해석할 때 기호를 대응되는 연산자의 우선순위를 \n\n고려하여 해석함 \n\n단항 연산자는 postfix 연산자가 prefix 연산자보다 \n\n우선순위가 높음 \n\n① 연산자가 &, *보다 우선순위가 높음 \n\n② int *a[5] >> [5]부터 해석 >> 용량이 5인 배열 \n\n>> int* 해석 >> 정수 포인터를 유지하는 배열 \n\n③ int (*a)[5] >> *부터 해석하도록 괄호 사용 \n\n>> a는 포인터 >> int[5] 해석 \n\n>> a는 정수 배열을 가리키는 포인터 \n\n④ int new int*[5] >> [5]부터 해석 >> 배열 >> int* 해석 \n\n>> 정수 포인터를 유지하는 배열을 동적 생성 \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left \n\nRight-to-left",
    "source": "ds-slide03_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 7,
      "page_heading": "# 장간.",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0097"
  },
  {
    "type": "강의자료",
    "text": "## 자바 배열 \n\n● 자바 배열은 항상 동적으로 생성함  ● 직접 반납할 필요는 없음  ● 용량과 크기가 가급적 일치하도록 프로그래밍함  ● 초깃값 목록을 사용할 때 용량을 지정할 수 없음  ● 생성할 때 변수를 이용하여 용량을 지정할 수 있음  ● 함수에서 배열을 반환할 수 있음  ● 자바 배열은 객체임  ● 용량 정보를 멤버 변수(length)로 유지함. 용량이 0인 배열도 가능  ● 배열의 인자 전달은 다른 객체의 인자 전달과 차이가 없음  ● 전달받은 함수에서 배열로 인식함  ● 배열 간 대입이 가능함  ● 다차원 배열의 공간은 연속 공간으로 확보하지 않음  ● C/C++처럼 const를 이용하여 배열을 받은 함수에서 수정을 못하도록  제한할 수 없음",
    "source": "ds-slide03_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 8,
      "page_heading": "## 자바 배열",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0098"
  },
  {
    "type": "강의자료",
    "text": "## 파이썬3 \n\n● 파이썬은 배열 타입이 없음 \n\n● 배열 대신 사용하는 것이 list임 \n\n● 파이썬의 list는 이 노트에서 살펴보는 리스트 자료구조임 \n\n● C++의 vector, 자바의 ArrayList와 유사 \n\n● 참고. 원시타입 배열은 array module의 array를 사용할 수 있음 \n\n● array는 동질 구조임 \n\n● 파이썬을 이용하여 자료구조를 구현할 때는 list를 배열처럼 사용하여 구현함 \n\n● list를 배열처럼 사용하여 리스트 자료구조를 구현하는 것은 적절하지 않지만 자료구조 내부 동작 원리를 이해하는데 도움이 됨 \n\n● list 타입을 배열로 생각하고 다른 언어와 비교하면 자바의 배열과 유사함 \n\n● 동적 자료구조 \n\n● 파이썬은 duck typing이기 때문에 동질 구조로 제한되지 않음",
    "source": "ds-slide03_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 9,
      "page_heading": "## 파이썬3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0099"
  },
  {
    "type": "강의자료",
    "text": "# 배열을 이용한 자료구조의 구현 \n\n- 장점 \n\n- 임의 접근 제공 \n\n- 연속 공간으로 유지되므로 캐싱에 유리함 \n\n- 자바의 객체 배열, 파이썬의 리스트는 캐싱에 유리하다고 보기 힘들 \n\n- 단점 \n\n- 용량이 고정 \n\n- 공간 부족 또는 낭비 \n\n- 동적 배열로 극복 가능하지만 중간에 확장하는 과정에서 비용이 발생함 \n\n- 중간에 데이터 추가나 데이터 제거가 번거로움",
    "source": "ds-slide03_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 10,
      "page_heading": "# 배열을 이용한 자료구조의 구현",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0100"
  },
  {
    "type": "강의자료",
    "text": "# 2  \n\n## LeetCode 283. Move zeros  \n\n## 283. Move Zeroes  \n\nEasy 2260 82 Favorite Share  \n\nGiven an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non- zero elements.  \n\n## Example:  \n\nInput: [0,1,0,3,12]  Output: [1,3,12,0,0]  \n\n## Note:  \n\n1. You must do this in-place without making a copy of the array.  \n2. Minimize the total number of operations.",
    "source": "ds-slide03_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 11,
      "page_heading": "# 2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0101"
  },
  {
    "type": "강의자료",
    "text": "## 리스트 ADT \n\n● 동질 구조: 구조에 있는 모든 요소가 같은 타입 \n\n● 요소 간의 선형 관계가 존재함 \n\n● 첫 번째 요소를 제외한 모든 요소는 유일 선행 요소가 있으며, \n\n● 마지막 요소를 제외한 모든 요소는 유일 후속 요소가 있음 \n\n● 리스트에 있는 요소의 개수를 리스트의 크기라 함 \n\n● 리스트는 정렬하여 유지할 수 있고, 그렇지 않을 수 있음 \n\n● 비정렬(un sorted) 리스트, 정렬(sorted) 리스트 \n\n● 라이브러리에서 제공하는 리스트는 대부분 비정렬 리스트임 \n\n● 정렬 리스트에서 요소가 복합 타입일 경우에는 정렬의 기준이 되는 키가 존재함 \n\n● 예) 학생 기록부: 학번, 학생 이름, 나이, ... 키는 다양하게 결정할 수 있음",
    "source": "ds-slide03_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 12,
      "page_heading": "## 리스트 ADT",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0102"
  },
  {
    "type": "강의자료",
    "text": "## 정렬 vs. 비정렬 (1/2) \n\n## ● 비정렬 리스트 \n\n● 데이터를 추가할 때 데이터를 저장할 위치에 대한 제약이 없다고 생각할 수 있음 \n\n● 하지만 응용에 따라 데이터의 삽입과 추출이 쌍으로 연관되어 동작해야 하는 경우가 많음 \n\n● 에) pushBack, popBack: 이 둘은 서로 영향을 받아야 하며, 데이터가 충분히 있으면 이들은 pushFront, popFront에 영향을 받지 않아야 함 \n\n## ● 정렬 리스트 \n\n● 데이터의 삽입 위치가 데이터 값에 의해 결정됨 \n\n● 삽입은 삽입할 위치부터 찾아야 함. 이 비용은 정렬되어 있어 저렴할 수 있지만 기존 데이터의 이동이 필요하면 실제 삽입은 저렴하지 않음 \n\n● 저장된 값의 범위, 최댓값/최솟값, k번째 요소, 요소의 순위 등과 같은 정보를 효과적으로 얻을 수 있음",
    "source": "ds-slide03_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 13,
      "page_heading": "## 정렬 vs. 비정렬 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0103"
  },
  {
    "type": "강의자료",
    "text": "## 정렬 vs. 비정렬 (2/2) \n\n● 정렬 리스트가 제공할 수 있는 추가 정보를 얻는 연산을 자주 수행해야 하는 응용은 정렬 리스트를 사용하는 것이 효과적일까? \n\n● 빈번한 삽입과 삭제가 이루어지는 응용은 삽입 비용 때문에 정렬 리스트를 사용하기 힘듦 \n\n● 이와 같은 동적 데이터는 정렬 리스트보다 Note 08에서 살펴보는 비선형 자료구조인 균형이진검색트리에 데이터를 유지하는 것이 더 효과적임 \n\n● 정적 데이터이면 비정렬 리스트에 삽입하고 한번 정렬하는 것이 정렬 리스트에 데이터를 삽입하는 것보다 효과적임 \n\n● 결론. 리스트는 보통 비정렬 리스트로 사용함\n\n● 보통 언어의 라이브러리는 정렬 리스트를 제공하지 않음",
    "source": "ds-slide03_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 14,
      "page_heading": "## 정렬 vs. 비정렬 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0104"
  },
  {
    "type": "강의자료",
    "text": "## 중복 허용 여부 \n\n● 중복을 허용하지 않으면 요소를 삽입하기 전에 요소가 이미 리스트에 있는지 검색해야 함 \n\n● 비정렬 리스트는 0(n), 정렬 리스트는 0(log n)에 할 수 있음 \n\n● 비정렬 리스트의 이점은 삽입을 0(1)에 할 수 있다는 것이므로 중복을 허용하지 않으면 이 이점이 사라짐 \n\n● 정렬 리스트는 중복 허용 여부와 상관없이 항상 삽입 위치를 찾아야 하기 때문에 중복을 허용하지 않을 경우 추가로 소요되는 비용이 없음 \n\n● 정렬 리스트는 중복을 허용할 경우 중복된 요소가 인접해 유지됨 \n\n● 중복 허용 여부에 따라 제공하는 연산의 차이가 있을 수 있음 \n\n● 예) 중복을 허용할 경우 중복된 모든 요소를 삭제하는 연산의 제공이 필요할 수 있음",
    "source": "ds-slide03_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 15,
      "page_heading": "## 중복 허용 여부",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0105"
  },
  {
    "type": "강의자료",
    "text": "## 리스트 ADT 구현시 고려사항 \n\n● 정렬 vs. 비정렬 \n\n● 중복 허용 여부 \n\n● 저장하는 요소가 복합타입인 경우 (Note 02 참조) \n\n● 복사본 유지, 포인터(참조) 유지 \n\n● 포인터를 유지할 경우 이점과 단점은? \n\n● C++11: emplace \n\n● 제공해야 하는 연산의 형태 \n\n● 보통 자료구조는 산입, 삭제, 검색, 추출 연산을 제공함 \n\n● 각 연산의 형태는 정해져 있지 않으며, 응용에 따라 다를 수 있음 \n\n● 예) 삭제 \n\n● 주어진 키 값을 가진 요소를 삭제 \n\n● 자료구조 내에 특정 위치에 저장된 요소를 삭제 \n\n● 리스트는 매우 다양한 연산을 제공하는 것이 특징",
    "source": "ds-slide03_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 16,
      "page_heading": "## 리스트 ADT 구현시 고려사항",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0106"
  },
  {
    "type": "강의자료",
    "text": "## 실습 순서 \n\n● 버전 U1. 비정렬 정수 리스트, 용량 고정, 중복 허용, 순서 유지  ● 코드 중복 고려 없이 각 메소드를 독립적으로 구현  ● 리팩토링  ● 버전 U2. 비정렬 정수 리스트, 용량 고정, 중복 허용  ● 버전 U3. 비정렬 정수 리스트, 동적 배열, 중복 허용, 순서 유지  ● 버전 U4. 비정렬 리스트, 범용, 중복 허용, 순서 유지  ● 버전 S1. 정렬 정수 리스트, 용량 고정, 중복 허용  ● 버전 S2. 정렬 정수 리스트, 용량 고정, 중복 허용하지 않음  ● 버전 S3. 정렬 리스트, 범용, 동적 배열",
    "source": "ds-slide03_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 17,
      "page_heading": "## 실습 순서",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0107"
  },
  {
    "type": "강의자료",
    "text": "# UnsortedArrayList \n\n- 상태 관련 메소드 \n\n- isEmpty, isFull, size \n\n- 삽입, 추출 \n\n- pushFront: O(n) / pushBack: O(1) \n\n- popFront: O(n) / popBack: O(1) \n\n- *addAfter: O(n) \n\n- *addBefore: O(n) \n\n- 배열의 특성\n- 직접 구현하지 않지만 나중에 연결구조와 비용 비교 필요 \n\n- 열람 \n\n- peekFront: O(1) \n\n- peekBack: O(1) \n\n- 검색: find: O(n) \n\n- 비정렬 특성. 선형 검색만 할 수 있음 \n\n- 삭제: remove: O(n): find+remove \n\n- 순서를 유지하지 않아도 되면 remove 자체는 O(1). How? \n\n- removeAll: O(n²)",
    "source": "ds-slide03_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 18,
      "page_heading": "# UnsortedArrayList",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0108"
  },
  {
    "type": "강의자료",
    "text": "class UnsortedArrayList{ private: const static inline size_t MAX{10}; size_t numItems{0}; int items[MAX]; // }; \n\nclass UnsortedArrayList{ private static final int MAX = 10; int numItems = 0; int[] items = new int[MAX]; // } \n\nclass UnsortedArrayList{ private: size_t capacity{0}; size_t numItems{0}; int* items{nullptr}; // }; // 동적 배열 \n\nclass UnsortedArrayList{ int capacity{0}; int numItems{0}; int[] items = null; // } // 동적 배열 \n\nclass UnsortedArrayList: MAX = 10 def __init__(self): self.numItems = 0 self.items = [0]*UnsortedArrayList.MAX # \n\nclass UnsortedArrayList: def __init__(self, capacity = 0): self.capacity = capacity self.numItems = 0 self.items = None #",
    "source": "ds-slide03_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 19,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0109"
  },
  {
    "type": "강의자료",
    "text": "# 상태 조회 메소드 \n\nisEmpty(): return numItems==0 \n\nisFull(): return numItems==MAX \n\nisFull(): return false \n\nsize(): return numItems \n\n- 동적 배열 기법에서는 isFull이 필요 없음\n- 하지만 데이터를 삽입하기 전에 numItems==capacity인지 확인하고 필요하면 용량을 확장해야 함",
    "source": "ds-slide03_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 20,
      "page_heading": "# 상태 조회 메소드",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0110"
  },
  {
    "type": "강의자료",
    "text": "# 색인 기반 접근 (1/2) \n\nget(index):\nif index<1 or index>numItems: throw IndexOutOfBoundsException\nreturn items[index] \n\n- 의사코드는 1색인으로 서술 \n\nset(index, item):\nif index<1 or index>numItems: throw IndexOutOfBoundsException\nitems[index] := item \n\n- 배열 기반 리스트는 임의 접근이 가능하므로 색인 기반 접근을 효과적으로 제공할 수 있음\n- 색인 기반 접근은 항상 인자가 유효한 범위인지 검사를 해야 함",
    "source": "ds-slide03_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 21,
      "page_heading": "# 색인 기반 접근 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0111"
  },
  {
    "type": "강의자료",
    "text": "# 세인 기반 접근 (2/2) \n\ninsert(index, item):\nif index<1 or index>numItems then throw IndexOutOfBoundsException\nfor i:=numItems to index do\n    items[i+1] := items[i]\nitems[index] := item \n\n- 세인 기반 삽입, 삭제 연산도 제공할 수 있음\n  remove(index), removeRange(from, to) 등\n- 이들 연산은 순서 유지가 필요하면 기존 데이터의 이동이 필요하므로 효과적으로 제공할 수 없음\n- 특정 위치에 있는 요소를 하나씩 앞으로 또는 뒤로 이동하는 것은 다른 연산에서도 필요하므로 모듈화하여 사용할 필요가 있음\n- 순서 유지가 필요 없으면?",
    "source": "ds-slide03_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 22,
      "page_heading": "# 세인 기반 접근 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0112"
  },
  {
    "type": "강의자료",
    "text": "# 찾기 연산 \n\n<table><tr><td>5</td><td>2</td><td>9</td><td>7</td><td>4</td><td></td><td></td><td></td></tr></table>\n\n<table><tr><td>size</td><td>5</td></tr></table>\n\n<table><tr><td>5</td><td>2</td><td>9</td><td>7</td><td>4</td><td></td><td></td><td></td></tr></table>\n\n<table><tr><td>find(9): 순차검색</td></tr></table>\n\n<table><tr><td>9</td><td>9</td><td>9</td></tr></table>\n\nfind(item): \n\nfor i:=1 to numItems do \n\nif items[i]==item then return true \n\nreturn false \n\nfind(item): \n\nreturn search(item)!=1 \n\n- 비정렬 리스트는 선형 순차 검색만 가능함 \n\n- 제시된 찾기 연산은 주어진 item에 리스트에 유지되어 있는지 여부만 알려줌 \n\n- 찾기 연산은 삭제 연산에서도 필요함 \n\n- 모듈화하기 위해서는 요소가 있는 경우 해당 위치를 반환하여 주는 연산을 만들어 활용할 필요가 있음 \n\n- 없을 경우에 반환하는 값은? Note 02 (std::optional, Optional)",
    "source": "ds-slide03_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 23,
      "page_heading": "# 찾기 연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0113"
  },
  {
    "type": "강의자료",
    "text": "# pushFront, pushBack \n\n5 2 9 7 \n\nnumItems 4 \n\n1 5 2 9 7 \n\npushFront(1) \n\n5 2 9 7 1 \n\npushBack(1) \n\n예외 case:\n1) isFull \n\n- 데이터의 삽입과 추출은 서로 독립적이지 않음. 따라서 보통 순서 유지가 필요함 \n\n- 순서를 유지하지 않는 방법: O(1) \n\n1 2 9 7 5 \n\nitems[numItems] := list[1]\nitems[1] := item\n++numItems",
    "source": "ds-slide03_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 24,
      "page_heading": "# pushFront, pushBack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0114"
  },
  {
    "type": "강의자료",
    "text": "pushback(item):\nitems[numItems+1] := item\n++numItems \n\npopback():\nif isEmpty() then throw InvalidStateException\nret := items[numItems]\n--numItems\nreturn ret \n\npushfront(item):\nfor i:=numItems downto 1 do\nitems[i+1] := items[i]\nitems[1] := item\n++numItems \n\n- 삼입은 용량이 고정된 상태에서는\n  isFull에 대한 검사가 필요하고,\n  동적 배열 기법에서는 용량 확장이\n  필요할 수 있음 \n\npopfront(item):\nif isEmpty() then throw InvalidStateException\nret := items[1]\nfor i:=2 to numItems do\nitems[i-1] := items[i]\n--numItems\nreturn ret",
    "source": "ds-slide03_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 25,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0115"
  },
  {
    "type": "강의자료",
    "text": "removeFirst \n\n<table><tr><td>5</td><td>2</td><td>7</td><td>4</td><td></td><td></td><td></td></tr><tr><td>9</td><td>9</td><td>9</td><td></td><td></td><td></td><td></td></tr></table>\n\nremove(9) \n\n예외 case:\n1) isEmpty \n\nremoveFirst(item):\nindex := search(item)\nif index!=-1 then\nfor i:=index+1 to numItems do\nitems[i-1] := items[i]\n--numItems \n\n- 순서가 중요하지 않으면\n이동하지 않고 맨 마지막 요소를\n삭제 요소 위치로 옮길 수 있음 \n\n<table><tr><td>5</td><td>2</td><td>4</td><td>7</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>\n\nitems[loc] := items[numItems];\n--size",
    "source": "ds-slide03_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 26,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0116"
  },
  {
    "type": "강의자료",
    "text": "removeAll \n\n- 중복을 허용하면 해당 요소를 모두 삭제하는 removeAll 연산을 제공할 수 있음 \n\nremoveAll(item):\nindex := search(item)\nwhile index!=-1 do\n    for i:=index+1 to numItems do\n    items[i-1] := items[i]\n    --numItems\n    index := search(item, index) \n\n- search 호출 루프 밖과 안에 중복되어 있는 것이 싫으면 다르게 구현 가능 \n\nremoveAll(item):\nindex := 1\nwhile true do\n    index := search(item, index)\n    if index==-1 then break\n//",
    "source": "ds-slide03_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 27,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0117"
  },
  {
    "type": "강의자료",
    "text": "# SortedArrayList \n\n- 내림차순, 오름차순? \n\n- 상태 관련 메소드 \n\n- isEmpty, isEmpty, size \n\n- 삽입 \n\n- add: O(n) \n\n- pushFront, pushBack은 의미 없음 \n\n- 추출: popFront O(n), popBack O(1) \n\n- 열람 \n\n- peekFront: O(1) \n\n- peekBack: O(1) \n\n- 검색: find: O(log n) \n\n- 이진 검색을 할 수 있음 \n\n- 삭제: remove: O(n)",
    "source": "ds-slide03_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 28,
      "page_heading": "# SortedArrayList",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0118"
  },
  {
    "type": "강의자료",
    "text": "## 비정렬 리스트 구현과 차이점 \n\n● 정렬 리스트는 중복을 허용하지 않을 수 있음 \n\n● 색인 기반 연산 중 set, insert 등은 정렬을 보장할 수 없으므로 보통 제공하지 않음 \n\n● find와 같은 찾기 연산은 이진 검색을 할 수 있음 \n\n● pushBack, pushFront 등도 정렬을 보장할 수 없으므로 보통 제공하지 않음 \n\n● 정렬 위치에 삽입해 주는 add 연산 하나만 제공함 \n\n● 중복 허용할 경우 중복된 요소가 인접해 유지되어 있기 때문에 removeAll 연산은 이를 고려하여 구현해야 함",
    "source": "ds-slide03_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 29,
      "page_heading": "## 비정렬 리스트 구현과 차이점",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0119"
  },
  {
    "type": "강의자료",
    "text": "# 정렬 배열 리스트 지원 연산 \n\n- 검색: \\(O(\\log n)\\) \n\n- 선택 (\\(k\\)번째 요소): \\(O(1)\\) \n\n- \\(\\min/\\max\\): \\(O(1)\\) \n\n- Predecessor, Successor: \n\n- 요소의 위치를 알면 \\(O(1)\\) \n\n- 요소의 위치를 모르면 검색을 먼저 해야 함: \\(O(\\log n)\\) \n\n- rank: 주어진 요소보다 같거나 작은 요소의 개수 \n\n- 요소의 위치를 알면 \\(O(1)\\) \n\n- 요소의 위치를 모르면 검색을 먼저 해야 함: \\(O(\\log n)\\) \n\n- 이처럼 다양한 연산을 저렴하게 제공하지만 문제는 삽입과 삭제가 저렴하지 않음. 대부분의 데이터는 정적이 아니라 동적임 \n\n- 정렬 배열 리스트가 문제 해결에 좋을 것 같고 데이터가 동적이면 후반부에 학습할 균형 유지 이진 검색 트리가 더 효과적인 자료구조임",
    "source": "ds-slide03_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 30,
      "page_heading": "# 정렬 배열 리스트 지원 연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0120"
  },
  {
    "type": "강의자료",
    "text": "## 이진 검색 (1/2) \n\n![](images/30_0.jpg)\n\n \n\nfind(11): 이진검색 \n\nL=1\nH=7\nM=(L+H)/2 = 4\nL=M+1=5\nH=7\nM=(L+H)/2 = 6 \n\nfind(item): \n\nlo := 1 \n\nhi := numItems \n\nwhile lo<=hi do \n\nmid := lo + (hi-lo)/2 \n\nif items[mid]==item then return true \n\nelse if items[mid]<item then lo := mid+1 \n\nelse hi := mid-1 \n\nreturn false \n\n배열 크기에 따라 mid 계산 과정에서 \n\n오버플로우 발생 가능 \n\n열처럼 mid를 계산하면 오버플로우가\n발생하지 않음",
    "source": "ds-slide03_page_31",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 31,
      "page_heading": "## 이진 검색 (1/2)",
      "images": [
        "ds-slide03/images/30_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0121"
  },
  {
    "type": "강의자료",
    "text": "# 이진 검색 (2/2) \n\nsearch(item): \n\nlo := 1 \n\nhi := numItems \n\nwhile lo<=hi do \n\nmid := lo + (hi-lo)/2 \n\nif items[mid]==item then return mid \n\nelse if items[mid]<item then lo := mid+1 \n\nelse hi := mid-1 \n\nreturn lo // hi \n\n● 색인을 반환할 때 lo 아니면 hi? \n\n<table><tr><td>2</td><td>3</td><td>5</td><td>7</td><td>9</td><td>11</td><td>13</td></tr></table>\n\n● lo는 기존 최솟값보다 작은 경우에만 문제 \n\n● hi는 기존 최솟값보다 작은 경우를 \n\n제외하고 hi+1이 삽입 위치 \n\n● 보통 최솟값보다 같거나 작은 경우와\n최댓값보다 같거나 큰 경우는\n검색 없이 최적화가 가능하므로 lo를\n이용하는 것이 효과적임 \n\n● 찾는 것이 있을 경우 요소가 있는 색인을 반환 \n\n<table><tr><td>search(6)</td><td>lo</td><td>1</td><td>1</td><td>3</td><td>4</td></tr><tr><td></td><td>hi</td><td>7</td><td>3</td><td>3</td><td>3</td></tr><tr><td></td><td>mid</td><td>4</td><td>2</td><td>3</td><td></td></tr></table>\n\n<table><tr><td>search(1)</td><td>lo</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td></td><td>hi</td><td>7</td><td>3</td><td>1</td><td>0</td></tr><tr><td></td><td>mid</td><td>4</td><td>2</td><td>1</td><td></td></tr></table>\n\n<table><tr><td>search(14)</td><td>lo</td><td>1</td><td>5</td><td>7</td><td>8</td></tr><tr><td></td><td>hi</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td></td><td>mid</td><td>4</td><td>6</td><td>7</td><td></td></tr></table>",
    "source": "ds-slide03_page_32",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 32,
      "page_heading": "# 이진 검색 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0122"
  },
  {
    "type": "강의자료",
    "text": "## add \n\nadd(item):  insertLoc := -1  if isEmpty() or items[numsltem]<=item then  insertLoc := numsltem+1  else if items[1]>=item then insertLoc := 1  else insertLoc := search(item)  for i:=numltems downto insertLoc do  items[i+1] := items[i]  items[insertLoc] := item  ++numltems \n\n 빈 경우. 최솟값보다 같거나 작은 경우 최댓값보다 같거나 큰 경우는 검색 없이 최적화가 가능함",
    "source": "ds-slide03_page_33",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 33,
      "page_heading": "## add",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0123"
  },
  {
    "type": "강의자료",
    "text": "removeAll \n\n중복된 요소가 인접해 있기 때문에 구간을 찾아야 함 \n\nremoveAll(item): \n\ninsertLoc := search(item) \n\nif insertLoc is valid and items[insertLoc]==item then \n\nlo := hi := insertLoc \n\nwhile lo-1>=1 and items[lo-1]==item do --lo \n\nwhile hi+1<=numItems and items[hi+1]==item do ++hi \n\ncount := hi-lo+1 \n\nfor i:=hi+1 to numItems do \n\nitems[lo] = items[i] \n\n++lo \n\nnumItems -= count \n\nsearch 연산을 수정하여 항상 중복 요소 중 가장 첫 번째 요소의 위치를 반환하도록 하면 첫번째 while문을 제거할 수 있음 (removeAll에서만 필요한 요소이므로 이 수정은 큰 효과가 없음)",
    "source": "ds-slide03_page_34",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 34,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0124"
  },
  {
    "type": "강의자료",
    "text": "# 순환 배열 (1/4) \n\n- 일반적으로 배열은 맨 뒤에 데이터를 추가하는 것만 \\(O(1)\\) 비용으로 처리할 수 있음 \n\n- head, tail 두 개의 색인을 사용하면 기존 순서를 유지한 상태에서 맨 앞에 데이터를 \\(O(1)\\) 비용으로 추가할 수 있음 \n\n![](images/34_0.jpg)",
    "source": "ds-slide03_page_35",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 35,
      "page_heading": "# 순환 배열 (1/4)",
      "images": [
        "ds-slide03/images/34_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0125"
  },
  {
    "type": "강의자료",
    "text": "# 순환 배열 (2/4) \n\n- head, tail의 초깃값? \n\n- head: 첫 번째 요소가 저장된 위치 \n\n- tail: 마지막 요소가 저장된 위치 또는 다음 요소가 저장될 위치 \n\n- 보통 후자를 사용함 \n\n- 후보 1. head: 0, tail: 1 (1색인) \n\n- 후보 2. head: 1, tail: 1 \n\n- head와 tail을 리스트의 상태를 조회할 때 활용하지 않으면 head의 초깃값은 중요하지 않음 \n\n- 기존처럼 numItems을 이용하는 것이 더 효과적임 \n\n- pushFront은 head-1 위치에 저장하는 형태이므로 0보다는 1로 초기화하는 것이 더 효과적임",
    "source": "ds-slide03_page_36",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 36,
      "page_heading": "# 순환 배열 (2/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0126"
  },
  {
    "type": "강의자료",
    "text": "# 순환 배열 (3/4) \n\n- head 1, tail 1로 초기화하였을 때 빈 상태, 팍찬 상태, 요소의 개수는 어떻게 계산할 수 있나? \n\n![](images/36_0.jpg)\n\n \n\n- 빈 상태와 팍찬 상태가 동일함 \n\n- 이 문제는 공간을 하나 사용하지 않으면 해결할 수 있음 \n\n- C++ 반복자 구현 측면에서도 end() 위치를 처리하기 효과적임 \n\n- 크기는 (tail+(capacity-head))%capacity로 계산할 수 있음 \n\n- 팍찬 상태에서는 위 식으로 크기를 계산할 수 없음 \n\n- 반복자는 항상 개수를 이용하여 구현할 수 있음",
    "source": "ds-slide03_page_37",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 37,
      "page_heading": "# 순환 배열 (3/4)",
      "images": [
        "ds-slide03/images/36_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0127"
  },
  {
    "type": "강의자료",
    "text": "# 순환 배열 (4/4) \n\n## ● 동적 배열 구현은 어떻게? \n\n![](images/37_0.jpg)",
    "source": "ds-slide03_page_38",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 38,
      "page_heading": "# 순환 배열 (4/4)",
      "images": [
        "ds-slide03/images/37_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0128"
  },
  {
    "type": "강의자료",
    "text": "# C++, std::vector (1/2) \n\n## ● 배열 대신에 가장 쉽게 사용할 수 있는 것 \n\n<table><tr><td>std::vector&lt;int&gt; list1;</td></tr><tr><td>std::vector&lt;int&gt; list2(5);</td></tr><tr><td>std::vector&lt;int&gt; list3(5, 1);</td></tr><tr><td>std::vector&lt;int&gt; list4;</td></tr><tr><td>list4.reserve(100);</td></tr><tr><td>std::vector&lt;int&gt; list5{1, 2, 3, 4, 5};</td></tr></table>\n\n<table><tr><td></td><td>용량</td><td>크기</td><td>초기화</td></tr><tr><td>list1</td><td>0</td><td>0</td><td>-</td></tr><tr><td>list2</td><td>5</td><td>5</td><td>모두 0</td></tr><tr><td>list3</td><td>5</td><td>5</td><td>모두 1</td></tr><tr><td>list4</td><td>100<br/>(reserve 실행 후)</td><td>0</td><td>-</td></tr><tr><td>list5</td><td>5</td><td>5</td><td>1,2,3,4,5</td></tr></table>\n\n## ● 용량 부족 걱정없이 사용 \n\n### ● 하지만 필요한 용량을 알면 미리 확보하여 사용하는 것이 바람직함 \n\n### ● push_back, pop_back, emplace_back \n\n### ● front, back, at, [] \n\n### ● empty, capacity, size, resize, assign, shrink_to_fit \n\n### ● <algorithm>에 있는 다양한 함수 활용 가능 \n\n#### ● std::find(list.begin(), list.end(), item) != list.end()",
    "source": "ds-slide03_page_39",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 39,
      "page_heading": "# C++, std::vector (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0129"
  },
  {
    "type": "강의자료",
    "text": "C++, std::vector (2/2) \n\n● 생성한 방법에 따라 사용 방법이 달라짐 \n\nstd::vector<int> list;\nlist.reserve(N);\nfor(int i{0}; i<N; ++i){\n    int v;\n    std::cin >> v;\n    list.push_back(v);\n} \n\nstd::vector<int> list(N, 0);\nfor(int i{0}; i<N; ++i){\n    std::cin >> list[i];\n} \n\n● Rvalue를 전달할 때에는 emplace_back이 조금 더 효과적임 \n\nlist.push_back(Student{\"홍길동\", 20}); \n\nlist.emplace_back(\"홍길동\", 20);",
    "source": "ds-slide03_page_40",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 40,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0130"
  },
  {
    "type": "강의자료",
    "text": "# Java, ArrayList \n\n## import java.util.ArrayList; \n\npublic class Test {\n    public static void main(String[] args) {\n        // 용량 10, 크기 0\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(5);\n        list.add(3);\n        list.add(7);\n        System.out.println(list.get(0)); // 5\n        list.set(0, 0);\n        System.out.println(list.get(0)); // 0\n        list.remove(Integer.valueOf(7)); // list.remove(2);\n        System.out.println(list.size()); // 2\n        // max, min, shuffle, sort\n        System.out.println(Collections.max(list)); // 3\n    }\n} \n\n- ArrayList도 초기 용량 확보가 성능에 중요한 요소임\n- 용량이 부족할 때 1.5배로 확장 \n\n- 자바는 색인 연산자를 이용하여 처리할 수 없으므로 사전에 저장할 데이터 개수를 알고 있으면 ArrayList를 사용하지 않고 배열을 사용함\n- ArrayList와 유사한 Vector도 있음 (Vector는 동기화 지원하므로 일반적 상황에서는 ArrayList를 사용해야 함)",
    "source": "ds-slide03_page_41",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 41,
      "page_heading": "# Java, ArrayList",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0131"
  },
  {
    "type": "강의자료",
    "text": "# Python3, List \n\nlist = [5,3,7]\nprint(list[2])    # 7\nlist.append(4)    # [5, 3, 7, 4]\nlist.sort()    # [3, 4, 5, 7]\nlist.reverse()    # [7, 5, 4, 3]\nprint(list.index(3))  # 3 (3이 있는 위치)\nlist.remove(7)    # [5, 4, 3]\nlist.pop()    # [5, 4]\nlist.insert(0,0)    # [0, 5, 4]\nlist[0] = 1    # [1, 5, 4]\na = list[:2]    # [1, 5]\nb = list[2:]    # [4] \n\n- 파이썬에서 slicing은 새 리스트를 만들기 때문에 무분별한 slicing은 피해야 함\n- 용량이 부족할 때 1.125배로 확장 \n\nlist = []\nfor i in range(0, N, 2):\n    list.append(Point(data[i], data[i+1])) \n\nlist = [Point(x, y) for x, y in zip(data[0::2], data[1::2])] \n\n- 반복문으로 처리하기보다는 list comprehension을 활용해야 성능에 더 효과적임",
    "source": "ds-slide03_page_42",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트: 배열 기반",
      "page_no": 42,
      "page_heading": "# Python3, List",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0132"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n## 리스트 – 단일 연결 구조 \n\nNOTE 04 \n\n![](images/0_2.jpg)\n\n## 한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide04_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 1,
      "page_heading": "## 리스트 – 단일 연결 구조",
      "images": [
        "ds-slide04/images/0_0.jpg",
        "ds-slide04/images/0_1.jpg",
        "ds-slide04/images/0_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0133"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 연결구조 ● 연결구조 vs. 배열 ● 비정렬 단일 연결구조 ● 정렬 단일 연결구조 ● C++, Java, Python 라이브러리 \n\n![](images/1_0.jpg)\n\n![](images/1_1.jpg)",
    "source": "ds-slide04_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide04/images/1_0.jpg",
        "ds-slide04/images/1_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0134"
  },
  {
    "type": "강의자료",
    "text": "## 연결 구조 \n\n● 연결구조란 고정된 공간을 미리 확보하여 사용하지 않고, 필요할 때마다 동적으로 확보하여 사용하는 구조를 말함 \n\n● 배열은 필요한 공간을 미리 확보하며, 확보된 공간은 고정됨. 따라서 공간이 낭비되거나 부족할 수 있음 \n\n● 동적배열 기법을 사용하여 용량이 부족할 때 확장할 수 있음 \n\n● 이 방식은 공간이 부족할 때 많은 비용이 소요됨 \n\n● 연결구조는 하나의 요소를 저장할 때마다 공간을 확보함 \n\n● 배열과 달리 공간 부족이나 낭비가 발생하지 않음 \n\n● 이렇게 확보한 공간은 연속적이지 않기 때문에 연결하지 않으면 저장된 요소를 접근하기 어렵기 때문에 배열과 달리 하나의 요소를 저장할 때마다 추가 공간이 필요함 \n\n![](images/2_0.jpg)\n\n![](images/2_1.jpg)\n\n배열 방식 \n\n연결 구조 방식",
    "source": "ds-slide04_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 3,
      "page_heading": "## 연결 구조",
      "images": [
        "ds-slide04/images/2_0.jpg",
        "ds-slide04/images/2_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0135"
  },
  {
    "type": "강의자료",
    "text": "![](images/3_0.jpg)\n\n<center>연결구조에서 데이터와 다음 연결정보(link)의 쌍을 노드라 함</center>",
    "source": "ds-slide04_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 4,
      "page_heading": "",
      "images": [
        "ds-slide04/images/3_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0136"
  },
  {
    "type": "강의자료",
    "text": "# 연결구조 vs. 배열 (1/2) \n\n<table><tr><td></td><td>연결구조</td><td>배열을 이용한 구현 방식</td></tr><tr><td>공간부족/낭비 문제</td><td>없음</td><td>있음</td></tr><tr><td>한 요소가 차지하는 공간</td><td>요소+연결</td><td>요소</td></tr><tr><td>공간 확보 비용</td><td>새 요소를 삽입할 때마다 확보해야 함</td><td>자료구조를 처음 생성할 때 한번 확보<br/>*동적 배열 기법</td></tr><tr><td>공간 형태</td><td>연속적이지 않음</td><td>연속 공간에 유지함<br/>캐싱에 유리함</td></tr><tr><td>각 요소 접근 방식</td><td>순차<br/>정렬 구조의 경우에도<br/>이진 검색을 할 수 없음</td><td>임의<br/>정렬 구조이면<br/>이진 검색 가능</td></tr><tr><td>중간에 요소 삽입/삭제</td><td>연결만 변경 (상수 시간)</td><td>순서를 유지해야 하면 후속 요소를 모두 이동해야 함</td></tr></table>\n\n- 중간까지 가는 비용은?",
    "source": "ds-slide04_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 5,
      "page_heading": "# 연결구조 vs. 배열 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0137"
  },
  {
    "type": "강의자료",
    "text": "## 연결구조 vs. 배열 (2/2) \n\n● 어떤 경우 어떤 방식을 선호해야 하는가? \n\n● 고려할 사항 \n\n● C1. 유지해야 할 요소의 개수를 사전에 알 수 있는가? \n\n● 알 수 있으면 배열이 효과적임. 데이터가 초기에 모두 제공되는 것이 아니면 효과적이지 않을 수 있음 \n\n● C2. 어떤 방식의 데이터 삽입과 추출이 필요한가? \n\n● 앞 뒤에서 주로 접근하면 연결구조도 좋은 대안이 될 수 있음 \n\n● 한쪽으로만 이루어지면 C1에 따라 결정해야 함 \n\n● 색인 기반 연산을 주로 사용하면 배열 기반이 더 효과적임 \n\n● C3. 저장된 데이터를 이용하여 어떤 작업을 주로 수행해야 하는가? \n\n● 위치에 의한 접근이 많이 필요한면 무조건 임의 접근이 가능한 배열이 더 좋은 방법임 \n\n● 중간에 있는 데이터의 삭제가 자주 일어나면 연결구조+맵을 생각해 볼 수 있음",
    "source": "ds-slide04_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 6,
      "page_heading": "## 연결구조 vs. 배열 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0138"
  },
  {
    "type": "강의자료",
    "text": "# UnsortedLinkedList \n\n- 상태 관련 메소드 \n\n- isEmpty, isEmpty \n\n- 삽입/추출 \n\n- 비정렬이므로 기본적으로 중복 허용 \n\n- pushFront(value): O(1), popFront(): O(1) \n\n- pushBack(value): O(n), with tail O(1), popBack: O(n) \n\n- addAfter(node, newNode): O(n) \n\n- addBefore(node, newNode): O(n) \n\n- 활용할 용도가 특별히 없음 \n\n- 열람 \n\n- peekFront: O(1) \n\n- peekBack: O(n), with tail O(1) \n\n- 검색: find: O(n) \n\n- 삭제: remove: O(n), removeAll: O(n)",
    "source": "ds-slide04_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 7,
      "page_heading": "# UnsortedLinkedList",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0139"
  },
  {
    "type": "강의자료",
    "text": "# Head, Tail \n\n- 연결구조는 보통 맨 앞 노드를 가리키는 head 포인터만 유지 \n\n- 맨 앞과 맨 뒤에 대한 접근이 필요한 경우에는 맨 마지막 노드를 가리키는 tail 포인터도 유지 가능 \n\n- tail 포인터의 한계는? \n\n![](images/7_0.jpg)",
    "source": "ds-slide04_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 8,
      "page_heading": "# Head, Tail",
      "images": [
        "ds-slide04/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0140"
  },
  {
    "type": "강의자료",
    "text": "## 연결구조프로그래밍 \n\n● 포인터(연결정보)를 갱신하는 순서가 매우 중요 \n\n● 보통 prev, curr 두 개의 포인터를 이동하면서 처리 \n\n● 이중연결구조를사용하면두개의포인터를이용하지않고 처리가능함 \n\n● 단일연결구조에서도한개의포인터만사용하여처리할수있음 \n\n● prev 위치에서 작업 처리 \n\n● 보통 맨 앞, 중간, 맨 뒤 3가지 경우에 대해 고려해야 함 \n\n● 빈 상태에서 추가, 노드가 하나 남아 있을 때 삭제와 같은 예외적 상황도 있음 (corner case) \n\n● dummy 노드를 통해 맨 앞 처리를 중간 처리와 동일하게 처리할 수 있음 \n\n● 주의. nullptr인 포인터를 사용해 문제가 발생할 수 있음",
    "source": "ds-slide04_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 9,
      "page_heading": "## 연결구조프로그래밍",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0141"
  },
  {
    "type": "강의자료",
    "text": "# 연결구조의 구현 \n\nclass LinkedList{\n    struct Node{\n    int item{0};\n    Node* next{nullptr};\n    };\n    Node* head{nullptr};\n}; \n\nclass LinkedList{\n    struct Node{\n    int item{0};\n    Node* next{nullptr};\n    };\n    Node head{};\n    // Node* head = new Node();\n}; \n\n![](images/9_0.jpg)\n\n \n\n![](images/9_1.jpg)\n\n \n\n- 이와 같은 노드를 dummy 노드라 함\n- 이것의 이점은?",
    "source": "ds-slide04_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 10,
      "page_heading": "# 연결구조의 구현",
      "images": [
        "ds-slide04/images/9_0.jpg",
        "ds-slide04/images/9_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0142"
  },
  {
    "type": "강의자료",
    "text": "class LinkedList{  private static class Node{  int item = 0;  Node next = null;  Node(int item){ this(item, null); }  Node(int item, Node next) { this.item = item; this.next = next; }  };  Node head = null;  } \n\nclass LinkedList:  class Node:  def __init__(self, item=0, next=None):  self.item = item  self.next = next  def __init__(self):  self.head = None",
    "source": "ds-slide04_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 11,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0143"
  },
  {
    "type": "강의자료",
    "text": "## 소멸자 \n\n● C++ 언어처럼 동적 생성한 것을 직접 반납해 주어야 하면 소멸자를 만들어야 함 \n\n● 동적 배열 기법처럼 빅5를 모두 만들어 주어야 함 \n\n● 동적 배열 기법은 동적 배열 하나만 반납하면 되지만 연결 구조는 머리 노드부터 꼬리 노드까지 하나씩 차례로 반납해 주어야 함 \n\n● 배열 기반 리스트와 달리 소멸 비용이 쾌 고가임",
    "source": "ds-slide04_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 12,
      "page_heading": "## 소멸자",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0144"
  },
  {
    "type": "강의자료",
    "text": "# 상태 조회 매소드 \n\nisEmpty(): return numItems == 0 \n\nisEmpty(): return head == 1 \n\nisFull(): return false \n\nsize(): return numItems",
    "source": "ds-slide04_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 13,
      "page_heading": "# 상태 조회 매소드",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0145"
  },
  {
    "type": "강의자료",
    "text": "# 색인 기반 접근 (1/2) \n\nget(index):\nif index<1 or index>numItems: throw IndexOutOfBoundsException\ncurr := head\nfor i:=1 to index do\n    curr := curr.next\nreturn curr.item \n\nset(index, item):\nif index<1 or index>numItems: throw IndexOutOfBoundsException\ncurr := head\nfor i:=1 to index do\n    curr := curr.next\nreturn item := item \n\n- 배열 기반 리스트는 임의 접근이 가능하지만 연결구조는 순차 접근을 해야 하므로 색인 기반 접근이 효과적이지 못함\n- index 위치의 노드를 반환해 주는 getNode(index)를 만들어 모듈화하면 색인 기반의 중복 코드를 모두 제거할 수 있음",
    "source": "ds-slide04_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 14,
      "page_heading": "# 색인 기반 접근 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0146"
  },
  {
    "type": "강의자료",
    "text": "# 섹인 기반 접근 (2/2) \n\ninsert(index, item): \n\nif index<1 or index>numItems then throw IndexOutOfBoundsException \n\nnewNode := allocate Node(item, ⊥) \n\nif index==1 then pushFront(item) \n\nelse: \n\ncurr := head \n\nfor i:=1 to index-1 do \n\ncurr := curr.next \n\nnewNode.next := curr.next \n\ncurr.next := newNode \n\n++numItems \n\n- 특정 노드 다음에 새 노드를 추가하는\n  addAfter(node, newNode)를 만들어\n  모듈화할 수 있음 \n\n- 예외적 상황: 맨 앞에 삽입해야 하는 경우 ⇒ head의 갱신이 필요 \n\n- 일반적인 경우 해당 위치 바로 전 노드로 이동해야 함 \n\n![](images/14_0.jpg)",
    "source": "ds-slide04_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 15,
      "page_heading": "# 섹인 기반 접근 (2/2)",
      "images": [
        "ds-slide04/images/14_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0147"
  },
  {
    "type": "강의자료",
    "text": "## 찾기 연산 \n\nfind(item):  curr := head  while curr do  if curr.item == item then return true  curr := curr.next  return false \n\n 연결구조는 항상 선형 순차 검색만 가능  배열 기반에서는 색인을 반환하여 주는 함수를 이용하여 코드 중복을 제거하였음  단일 연결구조는 값이 포함되어 있는 노드를 반환하여 주는 함수를 만들어 코드 중복을 제거하기 힘듦  삭제의 경우 노드뿐만 아니라 이전 노드까지 필요함",
    "source": "ds-slide04_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 16,
      "page_heading": "## 찾기 연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0148"
  },
  {
    "type": "강의자료",
    "text": "# pushFront \n\n![](images/16_0.jpg)\n\n \n\npushfront(item):\nnewNode := allocate Node(item, head)\nhead := newNode\n++numItems \n\n특이상황\n1) 기존에 요소가 하나도 없는 경우\n\n있는 경우와 차이가 있나?",
    "source": "ds-slide04_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 17,
      "page_heading": "# pushFront",
      "images": [
        "ds-slide04/images/16_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0149"
  },
  {
    "type": "강의자료",
    "text": "# pushBack \n\n- tail 포인터가 없는 경우에는 리스트 끝까지 이동: O(n) \n\n- tail 포인터가 있으면 바로 추가 가능 \n\n- 특이상황: 리스트가 비어 있는 경우 head의 변경 필요 \n\npushback(item): \n\nnewNode := allocate Node(item, ⊥) \n\nif isEmpty() then head := newNode \n\nelse \n\ntail := getTail() \n\ntail.next := newNode \n\n++numItems \n\ngetTail(): \n\ncurr := head \n\nwhile curr.next != ⊥ do \n\ncurr := curr.next \n\nreturn curr \n\n단계 1. 노드의 생성 \n\n단계 2. 리스트 empty 여부 검사 \n\n단계 2-1. 리스트가 empty이면 pushFront \n\n단계 2-2. 리스트가 empty가 아니면 \n\n1) tail 노드 확보 \n\n2) addAfter(tail, newNode) \n\n3) numItems 증가 \n\n- getTail()은 getNode(numItems)로 대체 가능",
    "source": "ds-slide04_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 18,
      "page_heading": "# pushBack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0150"
  },
  {
    "type": "강의자료",
    "text": "# popFront, popBack \n\n- popFront \n\n- 특이상황: 1) isEmpty, 2) 유일노드 \n\n- popBack \n\n- 특이상황: 1) isEmpty, 2) 유일노드 \n\n- tail 바로 이전 노드 필요 \n\n- tail 유지하여도 popBack은 도움이 되지 않음 \n\n단계 1. 리스트 empty 여부 검사\n단계 1-1. 리스트가 empty이면 예외발생\n단계 1-2. 리스트가 empty가 아니면\n1) deleteNode := head\n2) head := head.next\n3) 반환할 값 확보 후 deleteNode 반납\n4) 리스트가 empty이면 head := ⊥\n5) numItems 감소 \n\n단계 1. 리스트 empty 여부 검사\n단계 1-1. 리스트가 empty이면 예외발생\n단계 1-2. 리스트가 empty가 아니면\n1) tail과 tail 이전 노드 확보\n2) deleteNode := tail\n3) tail이 유일노드 여부 판단\n3-1) 유일노드이면 head := ⊥\n3-2) 유일노드가 아니면\nprev.next := ⊥\n4) 반환할 값 확보 후 deleteNode 반납\n5) numItems 감소",
    "source": "ds-slide04_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 19,
      "page_heading": "# popFront, popBack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0151"
  },
  {
    "type": "강의자료",
    "text": "popfront(): if isEmpty() then throw InvalidStateException ret := head.item delNode := head head := head.next free delNode --numItems return ret \n\n- 더미 노드는 동적 생성할 필요가 없음\n- 동적 생성하면 반납해야 함 \n\npopback(): if isEmpty() then throw InvalidStateException dummy := Node(⊥, head) prev := address of dummy curr := head while curr.next do prev := curr curr := curr.next ret := curr.item prev.next := ⊥ head := dummy.next free curr --numItems return ret \n\npopback(): if isEmpty() then throw InvalidStateException if numItems == 1 then return popfront() prev := head curr := head.next // head := dummy.next //",
    "source": "ds-slide04_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 20,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0152"
  },
  {
    "type": "강의자료",
    "text": "removeFirst \n\n![](images/20_0.jpg)\n\n \n\n단계 1. isEmpty이면 중단\n단계 2. 삭제할 노드와 그 노드의 이전 노드 찾기\n단계 3-1. 첫 노드 또는 유일 노드의 삭제\nhead = head→next;\n단계 3-2. 노드의 제거\nprev→next = curr→next;\n단계 4. 노드 반납\n단계 5. numItems 감소 \n\n예외적인 경우\n1) isEmpty\n2) 첫 번째 노드의 삭제\n3) 중간 노드의 삭제\n4) 끝 노드의 삭제\n5) 유일 노드의 삭제",
    "source": "ds-slide04_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 21,
      "page_heading": "",
      "images": [
        "ds-slide04/images/20_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0153"
  },
  {
    "type": "강의자료",
    "text": "removeFirst \n\nremoveFirst(item):\ndummy := Node(⊥, head)\nprev := address of dummy\ncurr := head\nwhile curr do\n    if curr.item == item then break\n    prev := curr\n    curr := curr.next\nif curr then\n    prev.next := curr.next\n    free curr\n    --nextItem\n    head := dummy.next \n\nremoveAll(item):\ndummy := Node(⊥, head)\nprev := address of dummy\ncurr := head\nwhile curr do\n    if curr.item == item then\n    next := curr.next\n    prev.next := next\n    free curr\n    --nextItem\n    curr := next\nelse\n    prev := curr\n    curr := curr.next\nhead := dummy.next \n\n- 노드를 삭제하였을 때 prev는 그대로, curr는 삭제한 노드의 후속 노드를 가리킨 상태에서 계속 진행해야 함",
    "source": "ds-slide04_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 22,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0154"
  },
  {
    "type": "강의자료",
    "text": "## 실습순서 \n\n● 실습 1. 비정렬 단일 연결구조: 중복 허용, head만 유지, prev, curr 두 개 포인터 이용하여 메소드 구현, 코드 중복 고려없이 구현, dummy 노드 활용하지 않음 \n\n● 실습 2. 실습 1+ 코드 중복 해소, dummy 노드 활용 \n\n● 실습 3. 실습 2 + 한 개의 포인터만 이용하여 모든 메소드 구현 \n\n● 실습 4. 실습 2 + tail 추가 \n\n● 실습 5. 실습 2 + 범용 \n\n● 실습 6. 실습 2 + 다양한 메소드(reverse 등) 추가 \n\n● 실습 7. 정렬 단일 연결구조: 중복 허용, head만 유지, prev, curr 두 개 포인터 이용하여 메소드 구현, dummy 노드 활용 \n\n● 실습 8. 실습 7 + tail 추가 \n\n● 실습 9. 실습 8 + 중복을 허용하지 않음",
    "source": "ds-slide04_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 23,
      "page_heading": "## 실습순서",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0155"
  },
  {
    "type": "강의자료",
    "text": "## 꼬리 포인터의 추가 \n\n 삼입의 경우 \n\n 빈 상태: head 뿐만 아니라 tail도 갱신 \n\n pushback은 tail을 이용하여 간단히 구현할 수 있음 \n\n 꼬리 포인터 추가의 유일한 이점: pushback, peekback \n\n 삭제의 경우 \n\n 유일 노드의 삭제: head, tail을 모두 널포인터로 갱신 \n\n tail 노드가 삭제될 경우 tail 갱신 필요 \n\n popback은 꼬리 포인터를 추가하여도 여전히 head부터 이동하여 tail 이전 노드를 확보해야 함",
    "source": "ds-slide04_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 24,
      "page_heading": "## 꼬리 포인터의 추가",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0156"
  },
  {
    "type": "강의자료",
    "text": "popback(): if isEmpty() then throw InvalidStateException dummy := Node(_, head) prev := address of dummy curr := head while curr.next do prev := curr curr := curr.next ret := curr.item prev.next := 1 head := dummy.next free curr --numItems return ret \n\npopback(): if isEmpty() then throw InvalidStateException dummy := Node(_, head) prev := address of dummy while prev.next!=tail do prev := prev.next ret := curr.item prev.next := 1 head := dummy.next free tail tail := if head!=1 then prev else 1 --numItems return ret",
    "source": "ds-slide04_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 25,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0157"
  },
  {
    "type": "강의자료",
    "text": "## 연습문제 심화 \n\n● LeetCode 206. Reverse Linked List \n\n● LeetCode 876. Middle of the Linked List \n\n● LeetCode 19. Remove nth Node From End of List \n\n● 876, 19는 모두 size를 이용하지 않고 할 수 있음 \n\n● 뒤에서 n번째이면 앞에서 size-n+1번째 \n\n● sort",
    "source": "ds-slide04_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 26,
      "page_heading": "## 연습문제 심화",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0158"
  },
  {
    "type": "강의자료",
    "text": "![](images/26_0.jpg)",
    "source": "ds-slide04_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 27,
      "page_heading": "",
      "images": [
        "ds-slide04/images/26_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0159"
  },
  {
    "type": "강의자료",
    "text": "## Middle \n\n● numltems를 이용하면 쉽게 중간 위치까지 이동할 수 있음 \n\n● numltems를 이용하지 않고 가장 효과적으로 중간으로 이동하는 방법은? \n\n● 힌트. 두 개의 포인터 이용 \n\n![](images/27_0.jpg)",
    "source": "ds-slide04_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 28,
      "page_heading": "## Middle",
      "images": [
        "ds-slide04/images/27_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0160"
  },
  {
    "type": "강의자료",
    "text": "# SortedLinkedList \n\n- 내림차순, 오름차순? \n\n- 상태 관련 메소드 \n\n- isEmpty, isEmpty, size \n\n- 삽입 \n\n- add: O(n) \n\n- 추출 \n\n- popFront: O(1) \n\n- popBack: O(n) \n\n- 열람 \n\n- peekFront: O(1) \n\n- peekBack: O(1) \n\n- 검색: find: O(n), 중간에 중단 가능 \n\n- 삭제: remove: O(n), removeAll: O(n), 중간에 중단 가능",
    "source": "ds-slide04_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 29,
      "page_heading": "# SortedLinkedList",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0161"
  },
  {
    "type": "강의자료",
    "text": "# 찾기 연산 \n\n- 정렬되어 있어도 이진 검색을 할 수 없음 \n\n- 하지만 중간에 중단할 수 있음 \n\nfind(item):\n    curr := head\n    while curr do\n        if curr.item == item then return true\n        else if curr.item>item then return false\n        curr := curr.next\n    return false",
    "source": "ds-slide04_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 30,
      "page_heading": "# 찾기 연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0162"
  },
  {
    "type": "강의자료",
    "text": "## add (1/2) \n\n![](images/30_0.jpg)\n\n단계 1. 노드 생성 단계 2. 추가할 위치 찾기 단계 3-1. empty 또는 맨 앞의 추가 newNode.next := head.next head := newNode 단계 3-2. 중간 노드 또는 끝에 추가 prev.next := newNode newNode.next := curr 단계 4. numItems 증가 \n\n경우의 수 1) isEmpty 2) 맨 앞에 추가 head.item과 비교 3) 중간에 추가 4) 끝에 추가 tail.item과 비교",
    "source": "ds-slide04_page_31",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 31,
      "page_heading": "## add (1/2)",
      "images": [
        "ds-slide04/images/30_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0163"
  },
  {
    "type": "강의자료",
    "text": "## add (2/2) \n\nadd(item):  newNode := allocate Node(item, ⊥)  if isEmpty() or head.item >= item then  newNode.next := head  head := newNode  else  prev := head  curr := head.next  while curr != ⊥ and curr.item < item then  prev := curr  curr := curr.next  prev.next := newNode  newNode.next := curr  +++numItems \n\n 맨 앞에 추가와 나머지를 구분  이 구분 때문에 더미 노드의 사용이 필요 없음  tail을 유지하면 tail.item보다 큰 경우에 대한 최적화가 가능",
    "source": "ds-slide04_page_32",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 32,
      "page_heading": "## add (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0164"
  },
  {
    "type": "강의자료",
    "text": "removeAll \n\nremoveAll(item):\nif isEmpty() then return\ndummy := Node(⊥, head)\nprev := address of dummy\ncurr := head\nwhile curr != ⊥ and curr.item <= item do\n    if curr.item==item then\n        while curr != ⊥ and curr.item == item do\n            next := curr.next\n            free curr\n            curr := next\n            --numItems\n        prev.next := curr\n        head := dummy.next\n        break\n    prev := curr\n    curr := curr.next \n\n- remove는 찾기 과정에서 중간에 중단할 수 있다는 것을 제외하고 비정렬과 차이가 없음\n- removeAll은 중복된 값이 인접해 있다는 것을 활용해야 함",
    "source": "ds-slide04_page_33",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 33,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0165"
  },
  {
    "type": "강의자료",
    "text": "# 정렬 연결구조에서 tail 포인터 \n\n- 정렬 연결구조에서 tail 포인터 유지할 경우의 장점\n  - 가장 큰 값과 가장 작은 값을 알 수 있음\n  - 리스트의 범위를 알 수 있음",
    "source": "ds-slide04_page_34",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 34,
      "page_heading": "# 정렬 연결구조에서 tail 포인터",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0166"
  },
  {
    "type": "강의자료",
    "text": "# 연습문제 \n\n- **LeetCode 21. Merge Two Sorted Lists** \n\n- **LeetCode 83. Remove Duplicates from Sorted List**",
    "source": "ds-slide04_page_35",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 35,
      "page_heading": "# 연습문제",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0167"
  },
  {
    "type": "강의자료",
    "text": "비교 \n\n<table><tr><td rowspan=\"3\"></td><td rowspan=\"2\">Array</td><td colspan=\"4\">Linked List</td></tr><tr><td colspan=\"2\">Unsorted</td><td colspan=\"2\">Sorted</td></tr><tr><td>Unsorted</td><td>Sorted</td><td>With tail</td><td></td><td>With tail</td></tr><tr><td>find</td><td>O(n)</td><td>O(logn)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>pushFront</td><td>O(1)*</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td></tr><tr><td>pushBack</td><td>O(1)</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td></tr><tr><td>add</td><td>-</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td></tr><tr><td>popFront</td><td>O(1)*</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>popBack</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>remove</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n</td></tr></table>\n\n* 순서를 유지할 필요가 없으면 또는 순환 배열 리스트를 사용하면 \n\n![](images/35_0.jpg)\n\n \n\n- 배열리스트는 동적배열을 사용하였을 때 확장에 따른 추가 비용 발생 \n\n![](images/35_1.jpg)\n\n \n\n- 비정렬 배열리스트에서는 삽입 위치를 유지하지 않아야 저렴한 비용으로 추가, 삭제 가능",
    "source": "ds-slide04_page_36",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 36,
      "page_heading": "",
      "images": [
        "ds-slide04/images/35_0.jpg",
        "ds-slide04/images/35_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0168"
  },
  {
    "type": "강의자료",
    "text": "## skiplist \n\n● 연결구조는 정렬이 되어 있어도 이진검색을 할 수 없다는 문제를 극복하기 위해 설계된 자료구조 \n\n![](images/36_0.jpg)\n\n● 정렬 구조 ● 균일하게 높이를 조절할 수 없기 때문에 각 노드의 높이는 확률적으로 결정함",
    "source": "ds-slide04_page_37",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 37,
      "page_heading": "## skiplist",
      "images": [
        "ds-slide04/images/36_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0169"
  },
  {
    "type": "강의자료",
    "text": "![](images/37_0.jpg)\n\n \n\n<center>https://en.wikipedia.org/wiki/Skip_list</center>",
    "source": "ds-slide04_page_38",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 38,
      "page_heading": "",
      "images": [
        "ds-slide04/images/37_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0170"
  },
  {
    "type": "강의자료",
    "text": "C++ \n\n● forward_list: <forward_list> \n\n○ 단일 연결구조 (참고. list는 이중 연결구조임) \n\n○ 단일 연결구조가 효과적인 곳에서는 list보다 효율적임 \n\n● 문제는 size 메소드가 없음 \n\nstd::forward_list<int> linkedList; \n\nlinkedList.push_front(5); \n\nlinkedList.push_front(3); \n\nlinkedList.push_front(7); \n\nstd::cout << linkedList.front() << \"\\n\"; \n\nlinkedList.pop_front(); \n\nlinkedList.push_front(1); \n\nlinkedList.remove(3); \n\nfor(auto i: linkedList) \n\nstd::cout << i << \", \"; \n\nstd::cout << std::endl;",
    "source": "ds-slide04_page_39",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 39,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0171"
  },
  {
    "type": "강의자료",
    "text": "## Java \n\n● 단일 연결구조는 라이브러리를 통해 제공하지 않음 ● java.util.LinkedList는 이중 연결구조임",
    "source": "ds-slide04_page_40",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 40,
      "page_heading": "## Java",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0172"
  },
  {
    "type": "강의자료",
    "text": "# Python3 \n\n- **llist package**: 추가 설치 필요 \n\n- **단일 연결구조**: sllist \n\n**from llist import sllist** \n\n**list = sllist()** \n\n**list.appendleft(1)** \n\n**list.appendleft(2)** \n\n**list.appendleft(3)** \n\n**list.appendright(4)** \n\n**print(list) # [3,2,1,4]** \n\n**print(len(list)) # 4** \n\n**list.extendright([7,8,9])** \n\n**node = list.nodeat(1)** \n\n**list.remove(node)** \n\n**x = list.popleft()** \n\n**y = list.popright()** \n\n**print(list) # [1,4,7,8]** \n\n**list.clear()**",
    "source": "ds-slide04_page_41",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 41,
      "page_heading": "# Python3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0173"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide04_page_42",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 – 단일 연결 구조",
      "page_no": 42,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0174"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n## 리스트 –  이중 연결구조 및  연결구조의 변형 \n\nNOTE 05 \n\n한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide05_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 1,
      "page_heading": "## 리스트 –  이중 연결구조 및  연결구조의 변형",
      "images": [
        "ds-slide05/images/0_0.jpg",
        "ds-slide05/images/0_1.jpg",
        "ds-slide05/images/0_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0175"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 이중 연결구조  ● 각 노드마다 선행과 후속 노드에 대한 연결 유지  ● 단일 연결구조와 달리 양방향으로 이동 가능  ● Without tail, With tail  ● 연결구조의 변형  ● 순환 연결구조  ● head, tail 두 개 대신 하나만  ● 배열을 이용한 연결구조  ● 동적 배열 기법을 사용하지 않으면 용량이 고정됨  ● 하지만 매번 노드의 생성이 불필요함  ● C++, Java, Python Library \n\n![](images/1_0.jpg)",
    "source": "ds-slide05_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide05/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0176"
  },
  {
    "type": "강의자료",
    "text": "## 이중 연결구조 \n\n● 다음 노드에 대한 연결뿐만 아니라 이전 노드에 대한 연결을 유지하는 구조 \n\n● 각 노드가 유지하는 정보가 많음 \n\n● 하지만 단일 연결구조와 달리 주어진 노드에서 이전 노드를 얻을 수 있기 때문에 하나의 포인터만 이용하여 모든 연산을 효과적으로 구현할 수 있음 \n\n● 노드에 대한 포인터만 있으면 해당 노드를 삭제할 수 있고, 앞/뒤로 노드를 추가할 수 있음 \n\n● tail 포인터를 유지하면 앞에 추가, 추출, 뒤에 추가, 추출을 모두 상수 시간에 할 수 있음 \n\n● 단일 연결구조: tail 포인터를 유지하더라도 뒤에서 추출은 O(1)에 할 수 없음 \n\n● 결론. 단일 연결구조는 head만, 이중 연결구조는 tail까지 \n\n● FIFO 큐는 단일 연결구조 with tail \n\n![](images/2_0.jpg)",
    "source": "ds-slide05_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 3,
      "page_heading": "## 이중 연결구조",
      "images": [
        "ds-slide05/images/2_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0177"
  },
  {
    "type": "강의자료",
    "text": "# 단일 연결구조 구현과 차이점 \n\n- 기본적으로 단일 연결구조에 비해 갱신해야 하는 연결 정보가 늘어난 형태임 \n\n  - **널포인터에 대한 검사가 더 늘어남** \n\n  - **isEmpty, size는 차이가 없음** \n\n  - 색인 기반 연산 중 **get, set**은 차이가 없음 \n\n  - 색인 기반 삽입, 삭제는 단일 연결구조와 달리 **getNode(index)**를 이용하여 모두 구현할 수 있음 (코드 중복 제거) \n\n  - 두 개의 포인터를 사용하여 연산을 구현할 필요가 없음 \n\n**Node:**\nitem: data type\nnext: Node address type \n\n**Node:**\nitem: data type\nprev: Node address type\nnext: Node address type",
    "source": "ds-slide05_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 4,
      "page_heading": "# 단일 연결구조 구현과 차이점",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0178"
  },
  {
    "type": "강의자료",
    "text": "# pushFront \n\n단일 연결구조에 비해 처리해야 하는 연결이 많음 \n\n![](images/4_0.jpg)\n\n \n\npushfront(item):\nnewNode := allocate Node(item, head)\nif head != ⊥ then head.prev := newNode\nhead := newNode\n++numItems \n\n특이상황\n1. 기존에 요소가 하나도 없는 경우 있는 경우 차이가 있나? \n\n단일 연결구조와 차이가 있나? \n\n단계 1. 노드의 생성 \n\n단계 2. newNode.next := head \n\n단계 3. head.prev := newNode \n\n단계 4. head := newNode \n\n단계 5. numItems 증가",
    "source": "ds-slide05_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 5,
      "page_heading": "# pushFront",
      "images": [
        "ds-slide05/images/4_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0179"
  },
  {
    "type": "강의자료",
    "text": "## addAfter \n\n![](images/5_0.jpg)\n\n특이상황 1. 첫 노드, 중간노드, 마지막 노드 단일 연결구조와 차이가 있나? \n\n단계 1. 노드의 생성  nextNode := curr.next  prevNode := curr  단계 2. newNode.next := nextNode  newNode.prev := prevNode  nextNode.prev := newNode  prevNode.next := newNode  단계 3. numItems := numItems + 1",
    "source": "ds-slide05_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 6,
      "page_heading": "## addAfter",
      "images": [
        "ds-slide05/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0180"
  },
  {
    "type": "강의자료",
    "text": "# pushBack \n\n- tail을 유지하지 않으면 tail 노드까지 먼저 이동해야 함. O(n) \n\n- tail 포인터 확보 후에는 addAfter 연산임 \n\npushback(item):\n  newNode := allocate Node(item, ⊥)\n  if isEmpty() then head := newNode\n  else\n    tail := getTail()\n    tail.next := newNode\n    newNode.prev := tail\n  ++numItems",
    "source": "ds-slide05_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 7,
      "page_heading": "# pushBack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0181"
  },
  {
    "type": "강의자료",
    "text": "# popFront \n\n![](images/7_0.jpg)\n\n \n\npopfront():\nif isEmpty() then throw InvalidStateException\nret := head.item\npopNode := head\nhead := head.next\nif head != ⊥ then head.prev := ⊥\nfree popNode\n--numItems\nreturn ret \n\n특이상황\n1. 요소가 하나도 없을 때\n2. 요소가 하나만 있을 때 \n\n단계 1. popNode := head\n단계 2. head := head.next\n단계 3. head.prev := ⊥\n단계 4. --numItems\nfree popNode",
    "source": "ds-slide05_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 8,
      "page_heading": "# popFront",
      "images": [
        "ds-slide05/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0182"
  },
  {
    "type": "강의자료",
    "text": "# popBack \n\n![](images/8_0.jpg)\n\n \n\npopback(): if isEmpty() then throw InvalidStateException tail := getTail() ret := tail.item if tail.prev != tail.prev.next := ⊥ else head := ⊥ free tail --numltems return ret \n\n특이상황\n1. 요소가 하나도 없을 때\n2. 요소가 하나만 있을 때 \n\n단계 1. popNode := tail\n단계 2. tail := tail.prev\n단계 3. tail.next := ⊥\n단계 4. --numltems\nfree popNode",
    "source": "ds-slide05_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 9,
      "page_heading": "# popBack",
      "images": [
        "ds-slide05/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0183"
  },
  {
    "type": "강의자료",
    "text": "remove \n\nremoveFirst(item): \n\ncurr := head \n\nwhile curr != ⊥ do \n\nif curr.item == item then \n\nif curr.prev != ⊥ then curr.prev.next = curr.next; \n\nif curr.next != ⊥ then curr.next.prev := curr.prev; \n\nif curr==head then head := curr.next \n\nfree curr \n\n--nextItem \n\nbreak \n\ncurr := curr.next \n\nremoveAll(item): \n\ncurr := head \n\nwhile curr != ⊥ do \n\nnext := curr.next \n\nif curr.item == item then \n\nif curr.prev != ⊥ then curr.prev.next = curr.next; \n\nif curr.next != ⊥ then curr.next.prev := curr.prev; \n\nif curr==head then head := curr.next \n\nfree curr \n\n--nextItem \n\ncurr := next \n\n- 더미 노드 사용하면 형광 부분을 제거할 수 있음",
    "source": "ds-slide05_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 10,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0184"
  },
  {
    "type": "강의자료",
    "text": "## 기타 \n\n● 꼬리 포인터의 추가 \n\n● 이중 연결구조는 장점을 극대화하기 위해서는 꼬리 포인터가 필수 \n\n● 보통 꼬리 노드의 제거 때문에 꼬리 포인터의 갱신은 다음을 이용함 \n\ntail := if curr == head then 1 else curr.prev \n\n● 이중연결 구조 기반 정렬 리스트 \n\n● 단일연결 구조 기반 정렬 리스트와 비교하여 갱신해야 하는 것만 많아질 뿐 특별히 고려할 것은 없음",
    "source": "ds-slide05_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 11,
      "page_heading": "## 기타",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0185"
  },
  {
    "type": "강의자료",
    "text": "# 순환 연결구조 \n\n- 단일 연결구조에서는 head 외에 tail을 유지하면 리스트 앞에 뿐만 아니라 끝에 추가를 상수 시간에 할 수 있음 \n\n- 끝에서 추출은 상수 비용으로 불가능 \n\n- 순환 연결구조(circular linked list)는 마지막 노드의 next 포인터가 널포인터가 아니라 시작 노드를 가리키는 연결구조를 말함 \n\n- head 대신에 tail만 유지하면 시작과 끝에 대한 접근을 상수 시간에 할 수 있음 \n\n- 어떤 노드에서 출발하던 모든 노드를 방문할 수 있음 \n\n- 단일 연결구조에서 head, tail 두 개를 유지하는 비용을 하나로 줄임 \n\n- 이것의 효과는 별로 없음. 구현의 재미 \n\n![](images/11_0.jpg)",
    "source": "ds-slide05_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 12,
      "page_heading": "# 순환 연결구조",
      "images": [
        "ds-slide05/images/11_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0186"
  },
  {
    "type": "강의자료",
    "text": "# 순환 연결구조: pushFront \n\n## 단계 1. 추가할 노드 생성\n### 단계 2. 현재 상태가 empty인지 아닌지 구분\n#### 단계 2-1. empty인 경우\n- **tail := newNode**\n- **tail.next := newNode**\n#### 단계 2-2. empty가 아닌 경우\n- **newNode.next := tail.next**\n- **tail.next := newNode**\n#### 단계 3. ++numItems \n\n![](images/12_0.jpg)",
    "source": "ds-slide05_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 13,
      "page_heading": "# 순환 연결구조: pushFront",
      "images": [
        "ds-slide05/images/12_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0187"
  },
  {
    "type": "강의자료",
    "text": "# 순환 연결구조: pushBack \n\n단계 1. 추가할 노드 생성\n단계 2. 현재 상태가 empty인지 아닌지 구분\n단계 2-1. empty인 경우\n    tail := newNode\n    tail.next := newNode\n단계 2-2. empty가 아닌 경우\n    newNode.next := tail.next\n    tail.next := newNode\n    tail := newNode\n단계 3. ++numItems \n\n![](images/13_0.jpg)",
    "source": "ds-slide05_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 14,
      "page_heading": "# 순환 연결구조: pushBack",
      "images": [
        "ds-slide05/images/13_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0188"
  },
  {
    "type": "강의자료",
    "text": "# 순환 연결구조: popFront, popBack \n\n## 단계 1. 현재 상태가 empty인지 아닌지 구분 \n\n### 단계 2. 현재 numItems 고려 \n\nhead, ret := tail.next, tail.next.item \n\n### 단계 2-1. numItems==1 \n\ntail := 1 \n\n### 단계 2-2. numItems>1 \n\ntail.next := head.next \n\n### 단계 3. head 반납 및 ret 반환 \n\n--numItems \n\n## 이중연결구조? \n\n### 단계 1. 현재 상태가 empty인지 아닌지 구분 \n\n### 단계 2. 현재 size 고려 \n\npopNode, ret := tail, tail.item \n\n### 단계 2-1. 하나인 경우 \n\ntail := 1 \n\n### 단계 2-2. 하나가 아닌 경우 : O(n) \n\ntail.next를 시작으로 tail의 이전 노드 prev 찾음 \n\nprev.next := tail.next \n\ntail := prev \n\n### 단계 3. popNode 반납 및 ret 반환 \n\n--numItems",
    "source": "ds-slide05_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 15,
      "page_heading": "# 순환 연결구조: popFront, popBack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0189"
  },
  {
    "type": "강의자료",
    "text": "# 순환 연결구조 구현의 문제점 \n\n- dummy 사용이 힘들 \n\n- 검색 \n\n- 보통 일반 연결구조에서는 head부터 시작하여 검색 포인터가 넓포인터일 때까지 반복 \n\n- 순환 연결구조에서는? \n\n- 방법 1. numItems 이용한 for 문 \n\n- 다른 방법은 없나? \n\n- 반복자 \n\n- C++의 경우 보통 begin은 head, end는 1 \n\n- 순환 연결구조는? \n\n- 보통 numItems의 활용 필요",
    "source": "ds-slide05_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 16,
      "page_heading": "# 순환 연결구조 구현의 문제점",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0190"
  },
  {
    "type": "강의자료",
    "text": "# 배열을 이용한 연결구조 \n\n<table><tr><td>색인</td><td>item</td><td>next</td></tr><tr><td>0</td><td>David</td><td>2</td></tr><tr><td>1</td><td>null</td><td>5</td></tr><tr><td>2</td><td>John</td><td>4</td></tr><tr><td>3</td><td>Peter</td><td>6</td></tr><tr><td>4</td><td>Mary</td><td>3</td></tr><tr><td>5</td><td>null</td><td>-1</td></tr><tr><td>6</td><td>Robert</td><td>-1</td></tr></table>\n\n<table><tr><td>head</td><td>0</td><td>freeHead</td><td>1</td><td>numItems</td><td>5</td></tr></table>\n\n**Node:** \n\n**item: data type** \n\n**next: array index type** \n\n**ArrayList:**\n\n**capacity: array size type** \n\n**numItems: array size type** \n\n**nodes: array of Node** \n\n**head: array index type** \n\n**freeHead: array index type** \n\n**for i:=1 to capacity do** \n\n**nodes[i].next := i+1** \n\n**nodes[capacity] := 1** \n\n**freeHead := 1** \n\n**head := 1**",
    "source": "ds-slide05_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 17,
      "page_heading": "# 배열을 이용한 연결구조",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0191"
  },
  {
    "type": "강의자료",
    "text": "![](images/17_0.jpg)",
    "source": "ds-slide05_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 18,
      "page_heading": "",
      "images": [
        "ds-slide05/images/17_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0192"
  },
  {
    "type": "강의자료",
    "text": "# pushBack, popBack \n\npushBack(item):\nif numItems == capacity then\n    increaseCapacity()\nif isEmpty() then pushFront(item)\nelse\n    newNodeIdx := freeHead\n    freeHead := nodes[freeHead].next\n    tail := getNode(numItems)\n    nodes[newNodeIdx].item := item\n    nodes[tail].next := newNodeIdx\n    nodes[newNodeIdx].next := ↓\n    ++numItems \n\npopBack():\nif isEmpty() then\n    throw InvalidStateException\nprev := ↓\ncurr := head\nwhile nodes[curr].next != ↓ do\n    prev := curr\n    curr := nodes[curr].next\nret := nodes[curr].item\nif prev != ↓ then nodes[prev].next := ↓\nelse head := ↓\nnodes[curr].next := freeHead\nfreeHead := curr\n--numItems\nreturn ret",
    "source": "ds-slide05_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 19,
      "page_heading": "# pushBack, popBack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0193"
  },
  {
    "type": "강의자료",
    "text": "# 배열을 이용한 연결구조의 장단점 \n\n## ● 장점 \n\n- 매번 삽입할 때마다 공간 할당이 이루어지지 않음 \n\n- 동적 메모리 할당을 제공하지 않는 프로그래밍 환경에서는 이 방법이 유일한 대안임 \n\n## ● 단점 \n\n- 일반적인 연결구조 방식과 달리 삽입 연산의 경우 리스트가 꽉 찬 경우를 고려해야 함 ⇒ 동적 배열 사용 \n\n- 더미 노드 이용이 번거로움???",
    "source": "ds-slide05_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 20,
      "page_heading": "# 배열을 이용한 연결구조의 장단점",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0194"
  },
  {
    "type": "강의자료",
    "text": "비교 \n\n<table><tr><td rowspan=\"3\"></td><td colspan=\"2\">ArrayList</td><td colspan=\"4\">SingleLinkedList</td><td colspan=\"4\">DoubleLinkedList</td></tr><tr><td rowspan=\"2\">비정렬</td><td rowspan=\"2\">정렬</td><td colspan=\"2\">비정렬</td><td colspan=\"2\">Sorted</td><td colspan=\"2\">비정렬</td><td colspan=\"2\">정렬</td></tr><tr><td>With tail</td><td>With tail</td><td>With tail</td><td>With tail</td><td>With tail</td><td>With tail</td><td></td><td>With tail</td></tr><tr><td>find</td><td>O(n)</td><td>O(logn)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>Push Front</td><td>O(1)*</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td>O(1)</td></tr><tr><td>Pop Front</td><td>O(1)*</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td></td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>add</td><td>-</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(1)</td></tr><tr><td>Push Back</td><td>O(1)</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td>O(1)</td></tr><tr><td>Pop Back</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>remove</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n</td><td></td></tr></table>\n\n- 배열리스트는 동적배열을 사용하였을 때 확장에 따른 추가 비용 발생 \n\n- *비정렬 배열리스트에서는 삽입 위치를 유지하지 않아야 저렴한 비용으로 추가, 삭제 가능 또는 순환 배열 리스트이면 O(1) \n\n- 배열리스트는 색인에 의한 O(1) 접근이 가능",
    "source": "ds-slide05_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 21,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0195"
  },
  {
    "type": "강의자료",
    "text": "● list <list> \n\nstd::list<int> llist;\nllist.push_back(5);\nllist.push_front(3);\nllist.push_front(1);\nstd::cout << llist.front() << \", \" << llist.back() << '\\n'; // 1,5\nllist.pop_front();\nllist.pop_back();\nstd::cout << llist.size() << '\\n';",
    "source": "ds-slide05_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 22,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0196"
  },
  {
    "type": "강의자료",
    "text": "# Java \n\n- java.util.LinkedList<T>: 이중연결구조 \n\n- get(index) 연산은 색인 위치에 따라 앞에서 또는 뒤에서 이동함 \n\nLinkedList<Integer> list = new LinkedList<>(); \n\nlist.addLast(5); // list.add(5)와 동일 \n\nlist.addFirst(3); \n\nlist.addFirst(1); \n\nSystem.out.printf(\"%d,%d\\n\",list.getFirst(), list.getLast()); // 1,5 \n\nint n = list.removeFirst(); \n\nn = list.removeLast(); \n\nSystem.out.println(list.size()); \n\n<table><tr><td rowspan=\"2\"></td><td colspan=\"2\">head</td><td colspan=\"2\">tail</td></tr><tr><td>예외발생</td><td>특수값 반환</td><td>예외발생</td><td>특수값 반환</td></tr><tr><td>insert</td><td>addFirst</td><td>offerFirst</td><td>addLast</td><td>offerLast</td></tr><tr><td>remove</td><td>removeFirst</td><td>pollFirst</td><td>removeLast</td><td>pollLast</td></tr><tr><td>examine</td><td>getFirst</td><td>peekFirst</td><td>getLast</td><td>peekLast</td></tr></table>\n\n- LinkedList에서 예외적 상황은 비어 있는 경우 peek 또는 pop하는 경우",
    "source": "ds-slide05_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 23,
      "page_heading": "# Java",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0197"
  },
  {
    "type": "강의자료",
    "text": "Python3 \n\n● llist package \n\nfrom llist import dllist \n\nlist = dllist() \n\nlist.appendleft(1) \n\nlist.appendleft(2) \n\nlist.appendleft(3) \n\nlist.appendright(4) \n\nprint(list) # [3,2,1,4] \n\nprint(len(list)) # 4 \n\nlist.extendright([7,8,9]) \n\nnode = list.nodeat(1) \n\nlist.remove(node) \n\nprint(list) # [3,1,4,7,8,9] \n\nx = list.popleft() \n\nprint(list) \n\ny = list.popright() \n\nprint(list) # [1,4,7,8] \n\nlist.clear() \n\nprint(list)",
    "source": "ds-slide05_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "리스트 –  이중 연결구조 및  연결구조의 변형",
      "page_no": 24,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0198"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n## 스택, 큐, 택 \n\nNOTE 06 \n\n한국기술교육대학교 컴퓨터공학부 김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide06_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 1,
      "page_heading": "## 스택, 큐, 택",
      "images": [
        "ds-slide06/images/0_0.jpg",
        "ds-slide06/images/0_1.jpg",
        "ds-slide06/images/0_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0199"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 스택: LIFO  ● push, pop, top(peek)  ● 큐: FIFO  ● add(enqueue), poll(dequeue), peek  ● 덱(deck, deque)  ● 양쪽으로 push와 pop이 모두 효과적인 큐",
    "source": "ds-slide06_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0200"
  },
  {
    "type": "강의자료",
    "text": "## 스태 \n\n## ● 스태의 특성 \n\nNote 02에서 구현한 자료구조 \n\n● 순서가 있는 동질 구조 \n\n● 가장 최근에 추가된 요소가 맨 위(top)에 있고, 가장 오래 전에 추가된 요소가 맨 밑(bottom)에 있음 \n\n● LIFO(Last-In-First-Out) 구조: 요소의 제거 또는 추가는 스택의 top에서만 이루어짐 \n\n## ● 연산 \n\n● push: 요소를 추가하는 연산 \n\n● pop: 요소를 스택에서 제거하고, 맨 위 요소를 반환해주는 연산 \n\n● top (peek): 스택의 변화 없이 맨 위 요소를 반환해주는 연산 \n\n![](images/2_0.jpg)",
    "source": "ds-slide06_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 3,
      "page_heading": "## 스태",
      "images": [
        "ds-slide06/images/2_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0201"
  },
  {
    "type": "강의자료",
    "text": "## 스태 구현 방법 \n\n● 배열 기반 리스트  ● pushBack, popBack, peekBack을 push, pop, top으로  ● 단일 연결구조 기반 리스트  ● pushFront, popFront, peekFront을 push, pop, top으로  ● 둘 다 모든 연산은 상수 비용  ● 배열 기반 리스트: 동적 배열 기법을 사용해야 함",
    "source": "ds-slide06_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 4,
      "page_heading": "## 스태 구현 방법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0202"
  },
  {
    "type": "강의자료",
    "text": "## 스텍 응용 \n\n## ● 괄호 검사 \n\n● “()({[]})”와 같이 3종류 괄호를 구성된 문자열이 있을 때 올바르게 되어 있는지(balanced) 검사하는 방법 \n\n## ● 알고리즘 \n\n● 열린 괄호 만나면 스택에 push \n\n● 닫힌 괄호 만나면 스택에서 pop하여 비교 \n\n● 일치하지 않으면 문제 \n\n● 전체 문자열을 검사하였는데 스택이 empty가 아니면 unbalanced \n\n● 괄호 종류를 사용하는 순서까지 고려해야 한다면 \n\n● 열린 괄호를 만나 스택에 push할 때 스택에 있는 열린 괄호를 검사해야 함 \n\n● 예) 열린 중괄호를 만났는데 스택 top에 괄호가 있으면 순서에 문제가 있는 경우",
    "source": "ds-slide06_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 5,
      "page_heading": "## 스텍 응용",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0203"
  },
  {
    "type": "강의자료",
    "text": "식 평가하기 \n\n● “3+4*2”와 같은 정수와 사칙연산으로 구성된 표현식을 평가하기 \n\n○ 곱셈 계열은 덧셈 계열보다 우선순위가 높음 \n\n○ 괄호를 이용하여 표현할 수 있음. 예) (3+4)*2 \n\n● 이와 같은 형태의 표현식을 infix 방식의 표현식이라 함 \n\n○ Infix 방식의 표현식을 postfix 방식으로 바꾸면 보다 쉽게 평가할 수 있음 \n\n● 예) 3+4*2 → 3 4 2 * + \n\n● 예) (3+4)*2 → 3 4 + 2 * \n\n● 특징 \n\n○ Infix 표현에서 피연산자의 순서와 postfix 표현에서 피연산자의 순서는 바뀌지 않음 \n\n○ 우선 순위가 높은 또는 먼저 수행해야 하는 연산자는 postfix에서는 먼저 나타나야 함",
    "source": "ds-slide06_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 6,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0204"
  },
  {
    "type": "강의자료",
    "text": "## Infix to Postfix \n\n<table><tr><td rowspan=\"8\">● 스택을 이용한 알고리즘 ● 단계 1. #를 만나면 postfix 문자열에 추가 ● 단계 2. ● 왼쪽괄호: 스택에 추가 ● 오른쪽 괄호: ● 왼쪽 괄호를 만날 때까지 스택에 있는 연산자를 postfix 문자열에 추가 ● 스택에서 왼쪽 괄호 제거 ● 연산자: ● 왼쪽 괄호를 만나거나, 자신보다 낮은 우선순위 연산자를 만나거나, 스택이 empty가 될 때까지 스택에 있는 연산자를 postfix 문자열에 추가 ● 연산자를 스택에 추가 ● 모든 입력을 처리하였으면 스택에 남은 모든 연산자를 postfix 문자열에 추가</td><td>None</td></tr><tr><td>None</td></tr><tr><td>None</td></tr><tr><td>None</td></tr><tr><td>None</td></tr></table>",
    "source": "ds-slide06_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 7,
      "page_heading": "## Infix to Postfix",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0205"
  },
  {
    "type": "강의자료",
    "text": "![](images/7_0.jpg)",
    "source": "ds-slide06_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 8,
      "page_heading": "",
      "images": [
        "ds-slide06/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0206"
  },
  {
    "type": "강의자료",
    "text": "# Postfix 평가하기 \n\n- 스택을 이용한 알고리즘 \n\n  - 단계 1. #을 만나면 스택에 추가 \n\n  - 단계 2. 연산자를 만나면 스택에서 두 개의 #를 뽑아 계산하고 결과를 다시 스택에 추가함 \n\n  - 단계 3. 스택에 남은 최종 값이 결과 값 \n\n![](images/8_0.jpg)",
    "source": "ds-slide06_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 9,
      "page_heading": "# Postfix 평가하기",
      "images": [
        "ds-slide06/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0207"
  },
  {
    "type": "강의자료",
    "text": "## 1 \n\n 큐(queue)의 특성  순서가 있는 동질 구조   가장 최근에 추가된 요소가 맨 뒤(rear)에 있고, 가장 오래 전에 추가된 요소가 맨 앞(front)에 있음   FIFO(First-In-First-Out) 구조: 요소의 추가는 큐의 끝에 이루어지고, 요소의 제거는 앞에서 이루어짐 (FCFS)  연산   enqueue: 요소를 큐의 끝에 추가하는 연산   dequeue: 큐의 맨 앞에 있는 요소를 제거하고, 그 요소를 반환해주는 연산   peek: 큐의 변화 없이 큐의 맨 앞에 있는 요소를",
    "source": "ds-slide06_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 10,
      "page_heading": "## 1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0208"
  },
  {
    "type": "강의자료",
    "text": "## 큐의 구현 \n\ntail을 유지하는 단일 연결구조 pushBack, popFront, peekFront를 enq, deq, peek으로 사용 배열 기반 리스트 순환 배열 방식의 리스트를 사용해야 함 \n\n참고. 우선순위 큐는 전혀 다르게 구현되어야 함 정렬 리스트로 구현할 수 있지만 훨씬 더 효율적으로 구현할 수 있음",
    "source": "ds-slide06_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 11,
      "page_heading": "## 큐의 구현",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0209"
  },
  {
    "type": "강의자료",
    "text": "## Deque \n\n● 특수 형태의 큐 (deck, double ended queue)  ● 요소를 앞과 뒤로 추가 및 제거할 수 있는 자료구조  ● 연결구조 기반 리스트로 구현하면 head-tail linked list라고도 함  ● 뒤로 추가 및 제거하기 위해서는 이중 연결구조이어야 함  ● 응용 예) 브라우저 방문 목록  ● 새 페이지를 방문할 때마다 방문 페이지 목록 뒤에 추가되어야 함  ● 이전 페이지로 이동하면 방문 페이지 목록에서 기존 저장된  페이지가 제거되어야 함  ● 일정 시간이 지난면 오래된 페이지들은 제거되어야 함  ● 앞 삭제, 뒤 추가 및 삭제 필요 ⇒ deque",
    "source": "ds-slide06_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 12,
      "page_heading": "## Deque",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0210"
  },
  {
    "type": "강의자료",
    "text": "![](images/12_0.jpg)",
    "source": "ds-slide06_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 13,
      "page_heading": "",
      "images": [
        "ds-slide06/images/12_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0211"
  },
  {
    "type": "강의자료",
    "text": "## 연습문제 \n\n● LeetCode 225. Implement Stack using Queue \n\n○ Using two queues \n\n○ Using single queue \n\n● LeetCode 933. Number of Recent Calls \n\n● Palindrome을 스택과 큐를 이용하여 해결 \n\n● 그래프 탐색 \n\n○ DFS(Depth First Search): stack \n\n○ BFS(Breadth First Search): queue \n\n● 큐는 프로그램링 문제보다 실제 서비스 구현할 때 많이 사용됨 \n\n○ 예) 프린터 큐, 메시지 큐, 스레드 큐",
    "source": "ds-slide06_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 14,
      "page_heading": "## 연습문제",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0212"
  },
  {
    "type": "강의자료",
    "text": "C++ \n\n- C++는 스택을 생성할 때 사용할 container를 지정할 수 있음 \n\n- Container를 지정하지 않으면 std::deque를 사용함 \n\n- 사용 가능한 container: std::deque, std::vector, std::list, std::forward_list 등 \n\n#include <stack> \n\nstd::stack<int> myStack; \n\nmyStack.push(5); \n\nmyStack.push(3); \n\nstd::cout << myStack.top() << '\\n'; // 3 \n\nstd::cout << myStack.size() << '\\n'; // 2 \n\nmyStack.pop(); \n\nstd::cout << myStack.top() << '\\n'; // 5 \n\n- top은 참조로 반환함 \n\n- pop은 제거만 하고 값을 반환하지 않음. Why? \n\nstd::stack<int, std::vector<int>> s(std::vector<int>(10)); \n\nstd::vector<int> vec; \n\nvec.reserve(10); \n\nstd::stack<int, std::vector<int>> s(vec); \n\n- 둘의 차이는? \n\nstd::stack<int, std::forward_list<int>> s \n\n- 가장 간단한 container",
    "source": "ds-slide06_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 15,
      "page_heading": "#include <stack>",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0213"
  },
  {
    "type": "강의자료",
    "text": "C++ \n\nqueue \n\n#include <queue> \n\nstd::queue<int> myQueue; \n\nmyQueue.push(5); \n\nmyQueue.push(3); \n\nstd::cout << myQueue.front() << '\\n'; // 5 \n\nstd::cout << myQueue.size() << '\\n'; // 2 \n\nmyStack.pop(); \n\nstd::cout << myQueue.front() << '\\n'; // 3 \n\nContainer를 지정하지 않으면 스택과 마찬가지로 std::deque를 사용함 \n\n![](images/15_0.jpg)",
    "source": "ds-slide06_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 16,
      "page_heading": "#include <queue>",
      "images": [
        "ds-slide06/images/15_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0214"
  },
  {
    "type": "강의자료",
    "text": "C++ \n\ndeque \n\n#include <deque> \n\nstd::deque<int> myDeque; \n\nmyDeque.push_back(5); \n\nmyDeque.push_front(3); \n\nmyDeque.push_front(1); \n\nstd::cout << myDeque.front() << '\\n'; // 1 \n\nstd::cout << myDeque.back() << '\\n'; // 5 \n\nstd::cout << myDeque.size() << '\\n'; // 3 \n\nmyDeque.pop_back(); \n\nmyDeque.pop_front(); \n\nstd::cout << myDeque.front() << '\\n'; // 3",
    "source": "ds-slide06_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 17,
      "page_heading": "#include <deque>",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0215"
  },
  {
    "type": "강의자료",
    "text": "# Java Stack \n\n- java.util.stack<T> \n\n**import java.util.Stack;** \n\n**public class Test {**\n**public static void main(String[] args) {**\n**Stack<Integer> s = new Stack<Integer>();\ns.add(5);\ns.add(3);\ns.add(7);\nSystem.out.println(s.peek());\nSystem.out.println(s.pop());\nSystem.out.println(s.pop());\nSystem.out.println(s.pop());\n}**\n} \n\n- **Vector 클래스**를 상속하여 구현\n- 하지만 **Vector**와 달리 초기 용량을 지정할 수 있는 생성자가 없음\n- **Vector**는 배열 기반이지만 **chunk** 단위로 용량을 확장함 (기본 용량 10)\n- **Thread-safe** 기능을 포함하고 있음\n- **Stack**은 얼마든지 **ArrayList**나 **LinkedList**를 대신 사용할 수 있음",
    "source": "ds-slide06_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 18,
      "page_heading": "# Java Stack",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0216"
  },
  {
    "type": "강의자료",
    "text": "# Java Queue \n\n- java.util.Queue<T> \n\n- 구현: ArrayDeque, LinkedList \n\nimport java.util.ArrayDeque; \n\npublic class Test { \n\npublic static void main(String[] args) { \n\nQueue<Integer> q = new ArrayDeque<Integer>(); \n\nq.add(5); \n\nq.add(3); \n\nq.add(7); \n\nSystem.out.println(q.element()); \n\nSystem.out.println(q.remove()); \n\nSystem.out.println(q.remove()); \n\n} \n\n} \n\n} \n\n<table><tr><td></td><td>예외발생</td><td>특수값 반환</td></tr><tr><td>insert</td><td>add</td><td>offer</td></tr><tr><td>remove</td><td>remove</td><td>poll</td></tr><tr><td>examine</td><td>element</td><td>peek</td></tr></table>\n\n- ArrayDeque 배열 기반 구현이므로\n초기 용량 설정이 중요 \n\n- 기본 용량 16",
    "source": "ds-slide06_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 19,
      "page_heading": "# Java Queue",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0217"
  },
  {
    "type": "강의자료",
    "text": "# Java Deque \n\n- java.util.Deque<T> \n\n- 구현: ArrayDeque (순환 배열), LinkedList (이중 연결구조) \n\n<table><tr><td rowspan=\"2\"></td><td colspan=\"2\">head</td><td colspan=\"2\">tail</td></tr><tr><td>예외발생</td><td>특수값 반환</td><td>예외발생</td><td>특수값 반환</td></tr><tr><td>insert</td><td>addFirst</td><td>offerFirst</td><td>addLast</td><td>offerLast</td></tr><tr><td>remove</td><td>removeFirst</td><td>pollFirst</td><td>removeLast</td><td>pollLast</td></tr><tr><td>examine</td><td>getFirst</td><td>peekFirst</td><td>getLast</td><td>peekLast</td></tr></table>",
    "source": "ds-slide06_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 20,
      "page_heading": "# Java Deque",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0218"
  },
  {
    "type": "강의자료",
    "text": "# Python3 \n\n- Stack \n\n- list의 append, pop을 이용 \n\n- Queue \n\n- FIFO queue: list의 append, pop(0), get(0)을 이용 \n\n- from collections import deque \n\n- append, appendleft, pop, popleft \n\n- 별도 queue 라이브러리도 있음 \n\n- from queue import Queue, LifoQueue, PriorityQueue \n\n- Queue(), LifoQueue(), PriorityQueue() \n\n- 이 구현은 다중 쓰레드를 지원하므로 일반적인 경우에는 deque를 사용해야 함 \n\nqueue = []\nqueue.append(10)\nqueue.append(5)\nqueue.append(7)\nprint (queue.pop(0))\nprint (len(queue))\nprint (queue[0])",
    "source": "ds-slide06_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 21,
      "page_heading": "# Python3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0219"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide06_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "스택, 큐, 택",
      "page_no": 22,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0220"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n## 도리 \n\nNOTE 07 \n\n한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide07_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 1,
      "page_heading": "## 도리",
      "images": [
        "ds-slide07/images/0_0.jpg",
        "ds-slide07/images/0_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0221"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 트리 ● 관련 개념 및 용어 ● 일반 트리의 구현 ● Composite Pattern ● 그래프 탐색 알고리즘: BFS, DFS ● 이진 트리: 자식 노드의 수가 최대 2인 트리 ● 이진 트리 순회(탐색) 방법: preorder, inorder, postorder \n\n● 순회: 트리에 있는 모든 노드를 방문 ● 탐색(검색); 트리에 특정 노드가 있는지 찾는 것 찾기 위해서는 순회가 필요함 \n\n![](images/1_0.jpg)",
    "source": "ds-slide07_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide07/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0222"
  },
  {
    "type": "강의자료",
    "text": "## 그래프와 트리 \n\n● 트리는 그래프의 한 종류 \n\n● 그래프는 노드와 간선으로 이루어짐 \n\n○ 간선은 방향이 있을 수 있고, 없을 수 있음 \n\n○ 트리는 보통 간선의 방향을 표시하지 않음 \n\n● 경로(path): 두 개의 노드를 연결하는 일련의 노드 \n\n○ 노드보다는 연결하는 일련의 간선을 통해 나타낸 \n\n● 간선 (a, v₁), (v₁, v₂), ..., (vₖ, b)가 존재하면 노드 a에서 노드 b까지 경로가 존재하는 것임 \n\n● 주기(cycle): 경로의 시작과 끝 노드가 같은 경로 \n\n● 연결 그래프: 모든 노드에서 다른 모든 노드로 경로가 존재하는 그래프 \n\n● 참고. 단일 연결구조도 트리의 한 종류임 \n\n![](images/2_0.jpg)",
    "source": "ds-slide07_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 3,
      "page_heading": "## 그래프와 트리",
      "images": [
        "ds-slide07/images/2_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0223"
  },
  {
    "type": "강의자료",
    "text": "## 트리 (1/2) \n\n● 트리: 주기가 없는 연결된 그래프 \n\n● 각 노드에서 다른 노드로 가는 경로가 유일한 그래프 \n\n○ 트리는 크게 루트가 있는 트리와 루트가 없는 트리로 구분되며, 우리가 주로 접하는 대부분의 트리는 루트가 있음 \n\n○ 루트는 부모가 없는 노드를 말함 \n\n○ 트리는 보통 간선에 방향을 표시하지 않음. 하지만 부모에서 자식으로 방향이 있다고 생각해도 됨 \n\n○ 주기가 없지만 간선을 하나 추가하면 주기가 만들어진 \n\n![](images/3_0.jpg)\n\n![](images/3_1.jpg)",
    "source": "ds-slide07_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 4,
      "page_heading": "## 트리 (1/2)",
      "images": [
        "ds-slide07/images/3_0.jpg",
        "ds-slide07/images/3_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0224"
  },
  {
    "type": "강의자료",
    "text": "## 트리 (2/2) \n\n● 루트가 있는 트리의 특성 \n\n○ 루트(root)라고 하는 유일한 시작 노드를 가지며, \n\n○ 각 노드는 여러 개의 자식 노드를 가질 수 있는 구조로서, \n\n○ 루트에서 각 노드까지의 경로가 유일한 구조를 말함 \n\n● 각 노드에서 다른 노드까지의 경로도 유일함 \n\n○ 비고. 노드가 하나도 없는 빈 트리(empty tree) 개념도 있고, 간선이 하나도 없는 루트 노드 하나만 있는 트리도 트리임 \n\n● 루트가 있는 트리는 재귀 구조(recursive structure)임 \n\n○ 각 노드를 기준으로 그 노드가 루트가 되는 부분트리(subtree)를 만들 수 있음 \n\n● 트리의 노드 수가 n(> 0)이면 간선의 수는 n – 1임",
    "source": "ds-slide07_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 5,
      "page_heading": "## 트리 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0225"
  },
  {
    "type": "강의자료",
    "text": "## 트리 노드의 종류 \n\n![](images/5_0.jpg)",
    "source": "ds-slide07_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 6,
      "page_heading": "## 트리 노드의 종류",
      "images": [
        "ds-slide07/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0226"
  },
  {
    "type": "강의자료",
    "text": "## 트리 용어 \n\n● 루트 노드(root node): 부모가 없는 유일한 노드 \n\n● 단말 노드(leaf node): 자식이 없는 노드 \n\n● 중간 노드(internal, intermediate, interior node, non-leaf node): 단말 노드를 제외한 모든 노드 \n\n● 형제 노드(sibling node): 부모가 같은 노드 \n\n● 조상 노드(ancestor node): 노드의 부모 노드부터 루트 노드까지 경로 상에 있는 모든 노드 \n\n● 후손 노드(descendant node): 노드의 자식 노드부터 단말 노드까지 경로 상에 있는 모든 노드",
    "source": "ds-slide07_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 7,
      "page_heading": "## 트리 용어",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0227"
  },
  {
    "type": "강의자료",
    "text": "# 노드의 레벨, 깊이, 높이 \n\n- 깊이(depth): 루트에서 어떤 노드까지의 경로 길이(간선의 수)\n- 높이(height): 노드와 그 노드의 후손 단말까지 가장 긴 경로 길이\n- 레벨(level): 1+루트에서 어떤 노드까지의 간선의 수 (루트부터의 거리) \n\n- 노드의 높이와 그 노드가 루트가 되는 트리의 높이는 같음\n- 일관성을 위해 빈 트리의 높이는 중중 -1이라고 함 \n\n- 위키피디아는 level과 depth를 같은 것으로 정의하고 있음. 루트 노드의 레벨은 0. \n\n![](images/7_0.jpg)",
    "source": "ds-slide07_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 8,
      "page_heading": "# 노드의 레벨, 깊이, 높이",
      "images": [
        "ds-slide07/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0228"
  },
  {
    "type": "강의자료",
    "text": "# 일반적인 트리노드의 구현 \n\ntemplate <typename T> class TreeNode{ private: T label; std::vector<TreeNode*> children; }; \n\ntemplate <typename T> class TreeNode{ private: T label; TreeNode* parent; std::vector<TreeNode*> children; }; \n\ntemplate <typename T> class TreeNode{ private: T label; // TreeNode* parent; TreeNode* left(nullptr); TreeNode* right(nullptr); }; // binary tree \n\ntemplate <typename T> class Node{ private: T label; Node* next; }; // 연결구조",
    "source": "ds-slide07_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 9,
      "page_heading": "# 일반적인 트리노드의 구현",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0229"
  },
  {
    "type": "강의자료",
    "text": "# 트리와 구현 \n\nclass TreeNode{\nprivate:\n    int label;\n    std::vector<TreeNode*> childs;\n}; \n\n- 노드만 정의하여 트리를 나타낼 수 있음 \n\nclass TreeNode{\nprivate:\n    TreeNode* root;\n    size_t numNodes;\n}; \n\n- 연결구조와 유사하게 트리를 정의하는 방법\n- Note 08. 이진 탐색 트리를 구현할 때 이 방법을 사용함",
    "source": "ds-slide07_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 10,
      "page_heading": "# 트리와 구현",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0230"
  },
  {
    "type": "강의자료",
    "text": "class Node{  private:    std::vector<Node*> children;    int key{-1};    public:        Node() = default;        Node(int key): key{key}{}        virtual ~Node() = default; // ???        void setValue(int key){ this->key = key;}        int getValue(){ return key;}        int numChilds(){ return children.size(); }        void addChild(Node* node){            children.push_back(node);        }        const Node* getChild(int index) const{            if(index<0||index>children.size()) throw std::range_error(\"\");            return children[index];        }        Node* getChild(int index){ ... }        void removeChild(int index){            if(index<0||index>children.size()) throw std::range_error(\"\");            children.erase(children.begin()+index);        }    };",
    "source": "ds-slide07_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 11,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0231"
  },
  {
    "type": "강의자료",
    "text": "class Node{\nprivate:\n    int key;\npublic: \n\nvirtual ~Node() = default;  void setValue(int key){ this->key = key; }  int getValue() const { return key; }  virtual int numOfChilds() const { return 0; }  virtual void addChild(Node* node) = 0;  virtual const Node* getChild(int index) const = 0;  virtual Node* getChild(int index) = 0;  virtual void removeChild(int index) = 0; \n\n 노드가추가, 삭제되면서단말이중간, 중간이단말노드가되는형태는 이방법으로구현하기힘들  원래이패턴은개별객체나객체의 집합을구분하지않고접근할수 있도록해주는패턴임. 예) 한명의군인이나여러명의군인을 구분하지않고처리하게해줌 \n\n객체지향 설계 패턴 중 이것을 composite pattern이라 함 \n\n![](images/11_0.jpg)",
    "source": "ds-slide07_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 12,
      "page_heading": "",
      "images": [
        "ds-slide07/images/11_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0232"
  },
  {
    "type": "강의자료",
    "text": "class NonLeaf: public Node{ \n\nprivate: \n\nstd::vector<Node*> children; \n\npublic: \n\nNonLeaf(int key = -1): Node(key){ \n\nvirtual ~NonLeaf(){ for(auto& node: children) delete node; } \n\nvirtual int numOfChilds() override { return children.size(); } \n\nvoid addChild(const Node* node) override { // \n\n} \n\nconst Node* getChild(int index) const override { // \n\n} \n\nNode* getChild(int index) override { // \n\n} \n\nvoid removeChild(int index) override { // \n\n} \n\n}; \n\nclass Leaf: public Node{ \n\npublic: \n\nLeaf(int key = -1): Node(key){ \n\nvirtual ~Leaf() = default; \n\nvoid addChild(const Node* node) override { \n\nconst Node* getChild(int index) const override { return nullptr; } \n\nNode* getChild(int index) override { return nullptr; } \n\nvoid removeChild(int index) override { \n\n};",
    "source": "ds-slide07_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 13,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0233"
  },
  {
    "type": "강의자료",
    "text": "## 트리 탐색 또는 순회 (1/2) \n\n● 깊이우선탐색(DFS, Depth First Search) \n\n● 리스트나 배열에 대한 정렬처럼 라이브러리에서 제공하지는 않음 \n\n○ 단계 1. 스택에 루트 노드를 push함 \n\n○ 단계 2. 스택이 비어 있으면 종료하고, 비어 있지 않으면 스택에서 노드를 pop하고, 해당 노드 i를 방문함 \n\n○ 단계 3. 노드 i가 중간 노드이면 자식 노드를 모두 스택에 저장함 \n\n○ 단계 4. 단계 2부터 다시 반복함 \n\n![](images/13_0.jpg)\n\n![](images/13_1.jpg)\n\n● 스택을 사용하지 않고 재귀로 구현 가능 트리이므로 visited 배열을 사용하지 않음 \n\n● 방문순서: 스택에서 pop한 시점",
    "source": "ds-slide07_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 14,
      "page_heading": "## 트리 탐색 또는 순회 (1/2)",
      "images": [
        "ds-slide07/images/13_0.jpg",
        "ds-slide07/images/13_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0234"
  },
  {
    "type": "강의자료",
    "text": "## 트리 탐색 또는 순회 (2/2) \n\n● 너비우선탐색(BFS, Breadth First Search) \n\n○ 단계 1. 루트 노드를 FIFO 큐에 push함 \n\n○ 단계 2. 큐가 비어 있으면 종료하고, 아니면 큐에서 노드를 pop하고, 해당 노드 i를 방문함 \n\n○ 단계 3. 노드 i가 중간 노드이면 자식 노드를 모두 큐에 저장함 \n\n○ 단계 4. 단계 2부터 다시 반복함 \n\n![](images/14_0.jpg)",
    "source": "ds-slide07_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 15,
      "page_heading": "## 트리 탐색 또는 순회 (2/2)",
      "images": [
        "ds-slide07/images/14_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0235"
  },
  {
    "type": "강의자료",
    "text": "DFS, BFS의 구해 \n\nDFS \n\nstd::stack<TreeNode*> stack;\nstack.push(root); \n\nwhile(!stack.empty()){\n    TreeNode* curr{stack.top()};\n    stack.pop();\n    // 노드 방문\n    for(auto child: curr->children){\n    stack.push(child);\n    }\n} \n\nvoid dfs(TreeNode* curr){\n    // 노드 방문\n    for(auto child: curr->children)\n    dfs(child);\n} \n\nBFS \n\nstd::queue<TreeNode*> queue;\nqueue.push(root);\nwhile(!queue.empty()){\n    TreeNode* curr{queue.front()};\n    queue.pop();\n    // 노드 방문\n    for(auto child: curr->children){\n    queue.push(child);\n    }\n}",
    "source": "ds-slide07_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 16,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0236"
  },
  {
    "type": "강의자료",
    "text": "# 이진 트리 \n\n- 이진 트리(binary tree): 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 \n\n- 루트 노드를 제외하고는 모두 부모 노드가 있음 \n\n- 각 레벨 l에 있을 수 있는 최대 노드의 수: \\(2^{l-1}\\) \n\n- 높이가 h인 트리에 있을 수 있는 최대 노드의 수: \\(2^{h+1} - 1\\) \n\n\\[2^0 + 2^1 + \\dots + 2^h = \\frac{2^{h+1} - 1}{2 - 1} = 2^{h+1} - 1\\]\n\n![](images/16_0.jpg)\n\n \n\n- 최소 노드의 수: \\(h+1\\) \n\n- 트리의 높이가 h일 때, 노드 수 n의 범위: \\(h+1 \\le n < 2^{h+1}\\) \n\n- \\(\\log_2 n - 1 < h \\le n - 1\\) \n\n- n개 노드로 만들 수 있는 트리의 최대 높이: \\(n-1\\) \n\n- n개 노드로 만들 수 있는 트리 의 최소 높이: \\([\\log_2 n]\\)",
    "source": "ds-slide07_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 17,
      "page_heading": "# 이진 트리",
      "images": [
        "ds-slide07/images/16_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0237"
  },
  {
    "type": "강의자료",
    "text": "## 이진 트리의 종류 (1/2) \n\n● 포화 이진 트리(full binary tree): 모든 노드의 자식 수가 0 또는 2인 경우 \n\n● 완전 이진 트리(complete binary tree): 마지막 레벨을 제외하면 모두 채워져 있고, 마지막 레벨의 단말 노드는 왼쪽에서부터 채워진 형태로 되어 있는 경우 \n\n● 모든 중간 노드의 자식 수가 2일 때 단말 노드의 수가 n이면 전체 노드의 수는 N = 2n - 1일 \n\n![](images/17_0.jpg)",
    "source": "ds-slide07_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 18,
      "page_heading": "## 이진 트리의 종류 (1/2)",
      "images": [
        "ds-slide07/images/17_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0238"
  },
  {
    "type": "강의자료",
    "text": "# 이진 트리의 종류 (2/2) \n\n- **완벽 이진 트리(perfect binary tree)**: 모든 중간 노드의 자식 수가 2이며, 모든 단말은 같은 레벨에 있는 경우 \n\n- **단말 노드의 수가 \\(n(= 2^h)\\)이면**\n  전체 노드의 수는 \\(N = 2n - 1\\)임 \n\n\\[\n\\bullet h = \\log_2(N + 1) - 1\n\\]\n\n- **완벽 이진 트리는 항상**\n  완전 이진 트리이며,\n  포화 이진 트리임 \n\n- **완전 이진 트리는 완벽 이진**\n  트리가 아닐 수 있음 \n\n![](images/18_0.jpg)",
    "source": "ds-slide07_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 19,
      "page_heading": "# 이진 트리의 종류 (2/2)",
      "images": [
        "ds-slide07/images/18_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0239"
  },
  {
    "type": "강의자료",
    "text": "# 균형 이진 트리 \n\n## 균형(balanced) 이진 트리 \n\n- 모든 노드의 왼쪽 부분 트리의 높이와 오른쪽 부분 트리의 높이의 차이가 1이하인 경우 \n\n- 균형 개념은 꼭 이진 트리에만 적용하는 개념은 아님 \n\n- 보통 트리와 관련된 연산은 트리 높이에 비례하는 경우가 대부분임 \n\n- 따라서 균형 트리를 유지할 수 있어야 효과적임 \n\n- 균형 인수(balance factor):\n  오른쪽 부분트리의 높이 – 왼쪽 부분트리의 높이 \n\n![](images/19_0.jpg)",
    "source": "ds-slide07_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 20,
      "page_heading": "# 균형 이진 트리",
      "images": [
        "ds-slide07/images/19_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0240"
  },
  {
    "type": "강의자료",
    "text": "## 이진트리노드번호 \n\n![](images/20_0.jpg)\n\n노드 i의 부모 노드: i/2 노드 i의 왼쪽 자식 노드: 2i 노드 i의 오른쪽 자식 노드: 2i + 1 \n\n노드 i의 부모 노드: (i −1)/2 노드 i의 왼쪽 자식 노드: 2i + 1 노드 i의 오른쪽 자식 노드: 2(i + 1)",
    "source": "ds-slide07_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 21,
      "page_heading": "## 이진트리노드번호",
      "images": [
        "ds-slide07/images/20_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0241"
  },
  {
    "type": "강의자료",
    "text": "## 이진 트리의 구현 \n\n● 방법 1. 왼쪽, 오른쪽 자식에 대한 포인터를 유지 \n\n● 방법 2. 배열을 이용하여 구현 \n\n○ 트리가 항상 완전 이진 트리로 유지된다면 이 방법을 많이 사용 \n\n○ 우선 순위 큐를 사용할 때 사용하는 힙(heap) 자료구조가 이 방법을 사용 (Note 11) \n\n○ 동적 배열 기법이 필요함 \n\n● 최초 용량을 잘 설정하는 것이 필요함 \n\n○ 캐싱에 유리함 \n\n![](images/21_0.jpg)",
    "source": "ds-slide07_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 22,
      "page_heading": "## 이진 트리의 구현",
      "images": [
        "ds-slide07/images/21_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0242"
  },
  {
    "type": "강의자료",
    "text": "## 이진 트리의 순회 \n\n● 순회(traversing): 트리에 있는 모든 노드를 방문하는 것 \n\n○ 보통 BFS 또는 DFS 사용 \n\n● BFS 또는 DFS 대신 다음 방법으로 순회 가능 \n\n○ 전위(preorder) 순회: 루트 노드 → 왼쪽 부분 트리 → 오른쪽 부분 트리 \n\n○ 중위(inorder) 순회: 왼쪽 부분 트리 → 루트 노드 → 오른쪽 부분 트리 \n\n○ 후위(postorder) 순회: 왼쪽 부분 트리 → 오른쪽 부분 트리 → 루트 노드 \n\n● 전위, 중위, 후위 순회 방법의 특징 \n\n○ 루트 노드를 방문하는 순서에 의해 구분되며, 공통적으로 왼쪽 부분 트리는 항상 오른쪽 부분 트리보다 먼저 방문함 \n\n○ 중위 순회는 이진 트리에 대해서만 정의됨. 다른 순회는 이진 트리가 아니어도 적용 가능함 \n\n![](images/22_0.jpg)",
    "source": "ds-slide07_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 23,
      "page_heading": "## 이진 트리의 순회",
      "images": [
        "ds-slide07/images/22_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0243"
  },
  {
    "type": "강의자료",
    "text": "## C++, Java, Python \n\n● 보통 라이브러리에서 트리를 위한 범용 자료구조는 제공하지 않고 있음  ● 그래프도 마찬가지임  ● 트리가 매우 다양한 구조(자식 수의 제한 등)를 가질 수 있기 때문임  ● 특정 트리 구조를 이용하는 자료구조는 보통 제공됨  ● 예) Java의 TreeSet, TreeMap (Red-Black Tree)  ● GUI 라이브러리에서 트리뷰를 제공할 때 사용하는 트리 구조도 있음  ● 예) javax.scene.control.Treeltem<T>",
    "source": "ds-slide07_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "도리",
      "page_no": 24,
      "page_heading": "## C++, Java, Python",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0244"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n![](images/0_3.jpg)\n\n![](images/0_4.jpg)\n\n# 이진 검색 트리 \n\nNOTE 08 \n\n# 한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide08_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 1,
      "page_heading": "# 이진 검색 트리",
      "images": [
        "ds-slide08/images/0_0.jpg",
        "ds-slide08/images/0_1.jpg",
        "ds-slide08/images/0_2.jpg",
        "ds-slide08/images/0_3.jpg",
        "ds-slide08/images/0_4.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0245"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 이진 검색 트리 \n\n● 특징 \n\n● 삽입 순서에 의해 트리 모습이 결정됨 \n\n● 트리가 편향될 수 있음 \n\n● 기본 연산 \n\n● 균형 맞추기 \n\n● 실제 자료구조로 기본 이진 검색 트리를 사용하지 않음 \n\n● 실제 사용하는 자료구조는 균형 이진 검색 트리임 \n\n● 예) set, map (hashing을 이용하지 않는 set과 map은 균형 이진 검색 트리로 구현됨) \n\n![](images/1_0.jpg)",
    "source": "ds-slide08_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide08/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0246"
  },
  {
    "type": "강의자료",
    "text": "# Local Search Data Structures (1/2) \n\n## ● Local Search Data Structure란? \n\n- 어떤 key를 기준으로 순서 집합 데이터를 유지하며, rangeSearch와 nearestNeighbor 연산을 지원하는 자료구조 \n\n- rangeSearch(key x, key y): 저장된 데이터 중 key 값이 x<=key<=y를 만족하는 모든 데이터를 반환하여 줌 \n\n- nearestNeighbor(key z): 저장된 데이터 중 key 값이 z의 선행과 후속 key 값인 데이터를 반환하여 줌 \n\n- 언제 필요? \n\n- 반 학생 중 나와 생일이 가장 가까운 친구는? \n\n- 특정 기간에 수신한 모든 메일 찾기 \n\n- 예) 저장된 값들: {1, 4, 6, 7, 10, 13, 15} \n\n- rangeSearch(5, 12): {6, 7, 10} \n\n- nearestNeighbor(3): {1, 4}, NearestNeighbor(7): {6, 10}.",
    "source": "ds-slide08_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 3,
      "page_heading": "# Local Search Data Structures (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0247"
  },
  {
    "type": "강의자료",
    "text": "# Local Search Data Structures (2/2) \n\n- 대안 1. HashTable (* 검색이 \\(O(1)\\)인 자료구조) \n\n- rangeSearch, nearestNeighbor 연산을 효과적으로 제공하지 못함 \n\n- 반복자를 통해 전체 데이터 확보한 후에 다시 처리해야 함 \n\n- 대안 2. 배열 기반 비정렬리스트 \n\n- rangeSearch, nearestNeighbor: \\(O(n)\\) \n\n- 대안 3. 배열 기반 정렬리스트 (범위의 크기: \\(k\\)) \n\n- rangeSearch: \\(O(\\log n + k)\\), nearestNeighbor: \\(O(\\log n)\\) \n\n- 하지만 추가와 삭제는 \\(O(n) \\rightarrow BST\\)는 이것도 \\(O(\\log n)\\) \n\n- 데이터가 동적인 경우(빈번하게 데이터의 추가와 삭제가 일어남)에도 rangeSearch와 nearestNeighbor 연산을 효과적으로 제공하는 자료구조는? \n\n- 보통 동적 데이터의 순서가 필요하면 균형 이진 검색 트리가 담",
    "source": "ds-slide08_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 4,
      "page_heading": "# Local Search Data Structures (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0248"
  },
  {
    "type": "강의자료",
    "text": "## 이진 검색 트리 \n\n### ● 이진 검색 트리(binary search tree) \n\n- 각 노드의 키 값이 왼쪽 후손 노드들의 키 값보다는 항상 크고, \n\n- 오른쪽 후손 노드들의 키 값보다는 항상 작은 이진 트리를 말함 \n\n![](images/4_0.jpg)\n\n왼쪽 부분 트리의 노드의 키 값<루트 노드의 키 값<오른쪽 부분 트리의 노드의 키 값",
    "source": "ds-slide08_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 5,
      "page_heading": "## 이진 검색 트리",
      "images": [
        "ds-slide08/images/4_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0249"
  },
  {
    "type": "강의자료",
    "text": "![](images/5_0.jpg)",
    "source": "ds-slide08_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 6,
      "page_heading": "",
      "images": [
        "ds-slide08/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0250"
  },
  {
    "type": "강의자료",
    "text": "## 이진 검색 트리의 순회 \n\n![](images/6_0.jpg)\n\n 이진 검색 트리의 경우 중위 순회 방법으로 순회하면 작은 갈부터 순서대로 방문하게 됨 \n\nPreorder: 60 45 41 55 63 65 Inorder: 41 45 55 60 63 65 Postorder: 41 55 45 65 63 60 \n\npreorder 언제 사용? 이진 트리를 원래 모습 그대로 복사하여 새 트리를 만들고 싶거나 트리 모습 그대로 출력하고 싶은 경우 \n\npostorder 언제 사용? 단말부터 차례로 모든 노드를 삭제하고 싶을 경우 \n\nPreorder: 50 40 45 43 47 55 52 62 60 65 Inorder: 40 43 45 47 50 52 55 60 62 65 Postorder: 43 47 45 40 52 60 65 62 55 50",
    "source": "ds-slide08_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 7,
      "page_heading": "## 이진 검색 트리의 순회",
      "images": [
        "ds-slide08/images/6_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0251"
  },
  {
    "type": "강의자료",
    "text": "## 실습 순서 \n\n● 실습 1. 부모 포인터를 유지하지 않음, 재귀적으로 구현  ● 모든 메소드를 독립적으로 구현  ● 모든 메소드를 재귀적으로 구현하는 것은 아님  ● 재귀적으로 구현 가능한 메소드만  ● 실습 2. 실습 1을 리팩토링  ● 실습 3. 부모 포인터를 유지함, 재귀적으로 구현  ● 실습 4. 실습 2 → 비재귀적  ● 실습 5. 실습 3 → 비재귀적",
    "source": "ds-slide08_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 8,
      "page_heading": "## 실습 순서",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0252"
  },
  {
    "type": "강의자료",
    "text": "# 이진 검색 트리의 구현 (1/2) \n\n**TreeNode:**\n**key: key type**\n**// parent: TreeNode address type**\n**left: TreeNode address type**\n**right: TreeNode address type** \n\n**BST:**\n**root: TreeNode addressType**\n**numNodes: integral type** \n\n- **BST는 부모 노드에 대한 연결을 유지하면 활용할 때 편리한 측면이 있지만 반대로 삽입, 삭제할 때 연결을 관리해야 하기 때문에 구현이 번거로운 측면도 있음**",
    "source": "ds-slide08_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 9,
      "page_heading": "# 이진 검색 트리의 구현 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0253"
  },
  {
    "type": "강의자료",
    "text": "# 노드의 수와 높이 \n\nsize(): return size(root) \n\nsize(node):\nif node == ⊥ then return 0\nreturn 1+size(node.left)+size(node.right) \n\n- 트리 구조이므로 재귀 방식으로 구현하는 것이 가장 직관적임\n- size는 단순하게 numNodes를 반환할 수 있음 \n\nheight():\nreturn height(root) \n\nheight(node):\nif node == ⊥ then return -1\nreturn 1+max(height(node.left), height(node.right))",
    "source": "ds-slide08_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 10,
      "page_heading": "# 노드의 수와 높이",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0254"
  },
  {
    "type": "강의자료",
    "text": "# 노드 찾기 \n\nfind(key):\nif isEmpty() then return false;\nreturn findNode(key, root).key == key \n\nfindNode(key, node):\nif node.key == key then return node\nnextNode := if node.key > key then node.left else node.right\nif nextNode != ⊥ then return findNode(key, nextNode)\nelse return node \n\nfindNode(key, node):\nwhile true do\n    if node.key == key then return node;\n    nextNode := if node.key > key then\n    node.left else node.right\n    if nextNode != ⊥ then node := nextNode\n    else return node; \n\n![](images/10_0.jpg)",
    "source": "ds-slide08_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 11,
      "page_heading": "# 노드 찾기",
      "images": [
        "ds-slide08/images/10_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0255"
  },
  {
    "type": "강의자료",
    "text": "# 노드 추가 (1/2) \n\n![](images/11_0.jpg)",
    "source": "ds-slide08_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 12,
      "page_heading": "# 노드 추가 (1/2)",
      "images": [
        "ds-slide08/images/11_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0256"
  },
  {
    "type": "강의자료",
    "text": "# 노드 추가 (2/2) \n\n**add(key):** \n\n**newNode := allocate TreeNode(key)** \n\n**if isEmpty() then root := newNode** \n\n**else** \n\n**parent := findNode(key, root)** \n\n**if parent.key == key then return** \n\n**if parent.key > key then parent.left := newNode** \n\n**else parent.right := newNode** \n\n**++numNodes** \n\n- **BST는 중복 키를 허용하지 않음** \n\n- **BST에서 노드 추가 복잡성: \\(O(h)\\), \\(O(\\log n)\\)**",
    "source": "ds-slide08_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 13,
      "page_heading": "# 노드 추가 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0257"
  },
  {
    "type": "강의자료",
    "text": "# 노드의 삭제 (1/4) \n\n![](images/13_0.jpg)",
    "source": "ds-slide08_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 14,
      "page_heading": "# 노드의 삭제 (1/4)",
      "images": [
        "ds-slide08/images/13_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0258"
  },
  {
    "type": "강의자료",
    "text": "# 노드의 삭제 (2/4) \n\nremove(9) \n\n![](images/14_0.jpg)\n\n \n\n자식이 돌인 노드의 삭제 \n\n왼쪽 부분 트리 중 가장 큰 노드(predecessor)와 교체\n오른쪽 부분 트리 중 가장 작은 노드(successor)와 교체 \n\n알고리즘 \n\n삭제할 노드를 찾는다.\n삭제할 노드가 만들노드이면 노드 삭제\n삭제할 노드가 만들노드가 아닌 경우\n오른쪽 자식 노드가 없으면\n왼쪽 자식 노드를 한 단계 위로\n왼쪽 자식 노드가 없으면\n오른쪽 자식 노드를 한 단계 위로\n자식이 둘 다 있으면\npredecessor를 찾아 이것을\n삭제할 노드의 값과 바꿈\npredecessor 노드를 삭제\n// successor를 찾아 바꾸어도 됨",
    "source": "ds-slide08_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 15,
      "page_heading": "# 노드의 삭제 (2/4)",
      "images": [
        "ds-slide08/images/14_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0259"
  },
  {
    "type": "강의자료",
    "text": "# 노드이 삭제 (3/4) \n\n![](images/15_0.jpg)",
    "source": "ds-slide08_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 16,
      "page_heading": "# 노드이 삭제 (3/4)",
      "images": [
        "ds-slide08/images/15_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0260"
  },
  {
    "type": "강의자료",
    "text": "## C O I 사기 / / / / / / / / / / / / / / / / / / / / \n\nremove(key): \n\nS := empty stack \n\ndelNode := findNode(key, root, S) \n\nif delNode.key != key then return \n\nparent := S.pop() \n\nif delNode.left != ⊥ and delNode.right != ⊥ then \n\nparent := delNode \n\nprevNode := delNode.left \n\nwhile prevNode.right != ⊥ do \n\nparent := prevNode \n\ndelNode := prevNode.right \n\ndelNode.key := prevNode.key \n\ndelNode := prevNode \n\nremoveSingleChild(parent, delNode) \n\n--numNodes \n\nremoveSingleChild(parent, delNode): \n\nif parent == ⊥ then root := ⊥ \n\nelse \n\nchildNode := if delNode.left != ⊥ then delNode.left else delNode.right \n\nif parent.key > key then parent.left := childNode \n\nelse parent.right := childNode \n\nfree delNode \n\n부모 정보를 유지하기 위해 스택 사용 \n\nBST에서 노드 삭제의 복잡성:\n\\(O(h), O(\\log n)\\)",
    "source": "ds-slide08_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 17,
      "page_heading": "## C O I 사기 / / / / / / / / / / / / / / / / / / / /",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0261"
  },
  {
    "type": "강의자료",
    "text": "# 노드이 순회 \n\npreorder(node):\nvisitedOrder.append(node.key);\nif node.left != ⊥ then return inorder(node.left)\nif node.right != ⊥ then return inorder(node.right) \n\ninorder(node):\nif node.left != ⊥ then return inorder(node.left)\nvisitedOrder.append(node.key);\nif node.right != ⊥ then return inorder(node.right) \n\n가장 작은 노드로 이동 (root에서 계속 왼쪽으로)\n이 노드를 node에 유지\n더 이상 노드가 없을 때까지 node ← next(node) 수행 \n\npostorder(node):\nif node.left != ⊥ then return inorder(node.left)\nif node.right != ⊥ then return inorder(node.right)\nvisitedOrder.append(node.key);",
    "source": "ds-slide08_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 18,
      "page_heading": "# 노드이 순회",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0262"
  },
  {
    "type": "강의자료",
    "text": "next (successor) \n\n- 노드가 오른쪽 자식이 있는 경우 \n\n  - **Fact.** \\(T\\)에 있는 모든 노드는 \\(a\\)보다 큼 \n\n  - 1차 후보: \\(T\\)에서 가장 작은 값 \n\n  - \\(a\\)의 부모는? \n\n  - \\(a\\)의 조상들이 모두 왼쪽 부모이면 이 노드들은 \\(a\\)보다 작음 \n\n  - 오른쪽 부모가 있다면 첫 오른쪽 부모 \\(c\\)는 \\(a\\)보다 큼 \n\n  - 이 이후 오른쪽 부모는 \\(c\\)보다 더 큼 \n\n  - 2차 후보: 첫 번째 오른쪽 부모 \n\n  - \\(T\\)에서 가장 작은 값은 \\(c\\)보다는 작음 \n\n- 답. 오른쪽 자식이 있으면 해당 부분 트리에서 가장 작은 값, 없으면 부모 중 첫 오른쪽 부모 \n\n  - 오른쪽 자식이 없고, 오른쪽 부모도 없으면 \\(a\\)가 가장 큰 값 (next 없음) \n\n![](images/18_0.jpg)",
    "source": "ds-slide08_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 19,
      "page_heading": "",
      "images": [
        "ds-slide08/images/18_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0263"
  },
  {
    "type": "강의자료",
    "text": "오른쪽 부분 트리가 있는 경우\n오른쪽 부분 트리에서 가장 작은 값, 예) 5 > 6\nleftDescendant (오른쪽 이후 계속 왼쪽)\n오른쪽 부분 트리가 없는 경우\n자신보다 키 값이 큰 첫 번째 부모노드 예) 6 > 7, 8 > 9\nrightAncestor \n\nnext(key):\nif isEmpty() then throw InvalidStateException\nS := empty stack\nnode := findNode(key, root, S)\nif node.key != key then throw InvalidArgumentException\nnextNode := getNextNode(node, key, S)\nreturn nextNode.key if nextNode != ⊥ else key \n\ngetNextNode(node, key, parents):\nif node != ⊥ and node.right != ⊥ then\n  node := node.right\n  while node.left != ⊥ do node = node.left\n  return node\nelse\n  while parents is not empty do\n    parent := parents.pop()\n    if parent.key > key then return parent\n  return ⊥ \n\n![](images/19_0.jpg)\n\n \n\nBST에서 next() 복잡성:\n\\(O(h)\\), \\(O(\\log n)\\)",
    "source": "ds-slide08_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 20,
      "page_heading": "",
      "images": [
        "ds-slide08/images/19_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0264"
  },
  {
    "type": "강의자료",
    "text": "prev (predecessor) \n\n● 노드가 왼쪽 자식이 있는 경우 \n\n○ Fact. T에 있는 모든 노드는 a보다 작음 \n\n● 1차 후보: T에서 가장 큰 값 \n\n○ a의 부모는? \n\n● a의 조상들이 모두 오른쪽 부모이면\n이 노드들은 a보다 큼 \n\n● 왼쪽 부모가 있다면 첫 왼쪽 부모 c는 a보다 작음 \n\n○ 이 이후 오른쪽 부모는 c보다 더 작음 \n\n● 2차 후보: 첫 번째 왼쪽 부모 \n\n○ T에서 가장 큰 값은 c보다 큼 \n\n● 답. 왼쪽 자식이 있으면 해당 부분 트리에서\n가장 큰 값, 없으면 부모 중 첫 왼쪽 부모 \n\n● 왼쪽 자식이 없고 왼쪽 부모도 없으면\na가 가장 작은 값 (prev 없음) \n\n![](images/20_0.jpg)",
    "source": "ds-slide08_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 21,
      "page_heading": "",
      "images": [
        "ds-slide08/images/20_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0265"
  },
  {
    "type": "강의자료",
    "text": "prev \n\n왼쪽 부분트리가 있는 경우\n왼쪽 부분트리에서 가장 큰 값, 예) 5 > 4\nrightDescendant (왼쪽이후 계속 오른쪽)\n왼쪽 부분트리가 없는 경우\n자신보다 키 값이 작은 첫 번째 부모노드 예) 12 > 9, 8 > 7\nleftAncestor \n\n![](images/21_0.jpg)\n\n \n\nBST에서 prev() 복잡성: O(h), O(logn)",
    "source": "ds-slide08_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 22,
      "page_heading": "",
      "images": [
        "ds-slide08/images/21_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0266"
  },
  {
    "type": "강의자료",
    "text": "Range Search \n\n● Range Search (low, high) \n\n○ 방법 1. low에 해당하는 값을 찾고, 해당 노드부터 next() 함수를 이용하여 high까지 찾아감 \n\n● 복잡성: 범위에 있는 요소의 개수 x 트리 높이: O(klogn) \n\n○ 방법 2. Inorder로 방문하여 배열을 확보한 후, 정렬 배열에서 범위 검색을 함 \n\n● 복잡성: O(n) + O(logn) + k \n\n● 추가 공간을 사용함 \n\n○ 방법 3. Inorder 탐색 알고리즘을 이용하되 범위에 있는 노드만 방문 \n\n● 복잡성: O(n) \n\n● 복잡성을 비교할 때 n과 k의 차이를 잘 생각해야 함",
    "source": "ds-slide08_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 23,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0267"
  },
  {
    "type": "강의자료",
    "text": "# Nearest Neighbor \n\n## ● Nearest Neighbor: prev, next 호출 \n\nstd::pair<int, int> nearestNeighbor(int key){ \n\nstd::pair<int, int> result; \n\nresult.first = prev(key); \n\nresult.second = next(key); \n\nreturn result; \n\n트리에 없는 노드의 prev, next 값은 어떻게? \n\n가장 작은 값과 가장 큰 값은 어떻게? \n\nnearestNeighbor(2) \n\nnearestNeighbor(13) \n\n![](images/23_0.jpg)\n\n \n\n## ● 변형 문제 \n\n- 가장 가까운 이웃 찾기: prev, next 중 차이가 작은 것",
    "source": "ds-slide08_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 24,
      "page_heading": "# Nearest Neighbor",
      "images": [
        "ds-slide08/images/23_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0268"
  },
  {
    "type": "강의자료",
    "text": "## 트리의 균형 맞추기 \n\n● 기본적인 생각 \n\n● 단계 1. 트리에 유지된 데이터를 배열에 저장한 다음에 \n\n● 세 가지 방법: inorder, preorder, postorder \n\n● 트리의 오른쪽과 왼쪽 부분트리의 높이를 유사하게 만드는 것이 필요 \n\n● 중간 값이 루트가 되어야 함 \n\n● 단계 2. 배열로 옮긴 데이터를 이용하여 트리를 재구성 \n\n● 데이터를 추가할 때마다 균형을 맞추기 위해 트리를 재구성하는 것은 비효율적임 \n\n● 그러면 언제? \n\n● 트리의 현재 높이와 현재 노드의 수로 구성할 수 있는 최적의 트리의 높이의 차이가 너무 크면 \n\n● 기준은 응용에 따라 결정",
    "source": "ds-slide08_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 25,
      "page_heading": "## 트리의 균형 맞추기",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0269"
  },
  {
    "type": "강의자료",
    "text": "# 균형 맞추기 (1/3) \n\n![](images/25_0.jpg)\n\n \n\n<table><tr><td>inorder: 3 5 7 8 10 12</td></tr><tr><td>preorder: 10 5 3 8 7 12</td></tr><tr><td>postorder: 3 7 8 5 12 10</td></tr></table>\n\n![](images/25_1.jpg)",
    "source": "ds-slide08_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 26,
      "page_heading": "# 균형 맞추기 (1/3)",
      "images": [
        "ds-slide08/images/25_0.jpg",
        "ds-slide08/images/25_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0270"
  },
  {
    "type": "강의자료",
    "text": "# 균형 맞추기 (2/3) \n\n- BST에서 균형 맞추기: \\(O(n) + O(nlogn) = O(nlogn)\\) \n\n![](images/26_0.jpg)\n\n \n\ninorder: 3 5 7 8 10 12 \n\n![](images/26_1.jpg)\n\n \n\n방법: inorder에서 중간 노드부터 삽입 \n\n<table><tr><td>3</td><td>5</td><td>7</td><td>8</td><td>10</td><td>12</td><td>low=0, high=6, mid=3</td></tr><tr><td>3</td><td>5</td><td>7</td><td>low=0, high=2, mid=1</td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td><td></td><td>low=4, high=5 → high, low순으로 삽입</td></tr><tr><td>7</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>12</td><td></td><td></td><td></td><td></td><td></td></tr></table>",
    "source": "ds-slide08_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 27,
      "page_heading": "# 균형 맞추기 (2/3)",
      "images": [
        "ds-slide08/images/26_0.jpg",
        "ds-slide08/images/26_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0271"
  },
  {
    "type": "강의자료",
    "text": "# 균형 맞추기 (3/3) \n\nbalanceTree(): visitedOrder.clear() inorder(root) clear() balanceTree(1, n) \n\nbalanceTree(low, high)\nif low == high then add(visitedOrder[low])\nelse if low < high then\n    mid := low + (high-low)/2\n    add(visitedOrder[mid])\n    balanceTree(low, mid-1)\n    balanceTree(mid+1, high)",
    "source": "ds-slide08_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 28,
      "page_heading": "# 균형 맞추기 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0272"
  },
  {
    "type": "강의자료",
    "text": "## 선택 문제와 rank \n\n● 선택(selection) 문제. k번째 요소를 찾는 문제 \n\n● 순위(rank) 문제. 주어진 요소가 몇 번째 요소인지 알아내는 문제 \n\n● 기본적인 BST를 이용하면 두 연산을 효과적으로 제공할 수 없음 \n\n● 각 노드가 트리의 크기를 유지하면 두 연산을 모두 효과적으로 제공할 수 있음 \n\n● 크기를 유지하면 이 데이터도 삽입과 삭제할 때 갱신되어야 함 \n\n● 삽입은 단말에 삽입되므로 그 노드부터 루트노드까지 올라가면서 크기를 갱신하면 됨 \n\n● 삭제는 실제 삭제된 노드부터 루트노드까지 올라가면서 크기를 갱신하면 됨",
    "source": "ds-slide08_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 29,
      "page_heading": "## 선택 문제와 rank",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0273"
  },
  {
    "type": "강의자료",
    "text": "## 비재귀적 구현 (1/2) \n\n● 트리의 전체 노드를 탐색하지 않는 것이면 반복문으로 쉽게 구현 가능 \n\n● 예) 슬라이드 10의 findNode \n\n● 트리의 전체 노드를 탐색해야 하는 경우: BFS나 DFS를 응용 \n\n● 예) 트리의 높이 (BFS 응용) \n\nheight(node): \n\nif isEmpty() then return -1 \n\nQ := empty queue of (TreeNode, height) \n\nQ.push(root, 0) \n\nmaxHeight := 0 \n\nwhile Q is not empty do \n\nnode, height := Q.pop() \n\nmaxHeight := max(maxHeight, height) \n\nif node.right != 1 then Q.push(node.right, height+1) \n\nif node.left != 1 then Q.push(node.left, height+1) \n\nreturn maxHeight \n\n● BFS에 하나의 값이 아니라 구조체 변수를 삽입하여 진행할 수 있음 \n\n● 부모는 항상 자식보다 트리 높이가 하나 큼 \n\n● 여기서 노드와 함께 삽입하는 것이 노드의 높이가 아니라 깊이임",
    "source": "ds-slide08_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 30,
      "page_heading": "## 비재귀적 구현 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0274"
  },
  {
    "type": "강의자료",
    "text": "# 비재귀적 구현 (2/2) \n\n- BFS나 DFS를 이용하여 간단하게 구현할 수 있지만 복잡한 경우도 많음 \n\n- 예) inorder를 비재귀적으로 구현 \n\ninorder(node):\nS := empty stack of TreeNode\nwhile true do\n    while node != ⊥ do\n    S.push(node)\n    node := node.left\n    if S is empty then break\n    else\n    curr := S.pop()\n    visitedOrder.append(curr.key)\n    node := curr.right \n\n- 중위 순회: 왼쪽, 루트, 오른쪽 순서로 방문\n- 가장 먼저 왼쪽으로 이동함.\n- 더 이상 왼쪽으로 갈 수 없으면\n- 이 노드가 부분 트리의 루트가 됨.\n- 그러면 그다음 오른쪽을 처리해야 함",
    "source": "ds-slide08_page_31",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 31,
      "page_heading": "# 비재귀적 구현 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0275"
  },
  {
    "type": "강의자료",
    "text": "# 부모 링크의 유지 (1/2) \n\n- 부모 링크가 필요한 연산 \n\n  - remove, next, prev, nearestNeighbor \n\n  - remove는 부모 노드만 필요함 \n\n- 스택을 이용한 findNode 버전이 불필요함 \n\n- add 연산에서 부모 링크를 추가해 주어야 하고, remove 연산에서 부모 링크를 갱신해 주어야 함 \n\nadd(key): \n\nnewNode := allocate TreeNode(key) \n\nparent := findNode(key, root) \n\nif parent.key == key then return \n\nif parent.key > key then \n\nparent.left := newNode \n\nelse parent.right := newNode \n\nnewNode.parent := parent \n\n++numNodes \n\nremoveSingleChild(parent, delNode): \n\nif parent == ⊥ then root := ⊥ \n\nelse \n\nchildNode := if delNode.left != ⊥ then \n\ndelNode.left else delNode.right \n\nif parent.key > key then \n\nparent.left := childNode \n\nelse parent.right := childNode \n\nif childNode != ⊥ then \n\nchildNode.parent := parent \n\nfree delNode",
    "source": "ds-slide08_page_32",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 32,
      "page_heading": "# 부모 링크의 유지 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0276"
  },
  {
    "type": "강의자료",
    "text": "# 부모 링크의 유지 (2/2) \n\nnext(key):\nif isEmpty() then throw InvalidStateException\nS := empty stack\nnode := findNode(key, root)\nif node.key != key then throw InvalidArgumentException\nnextNode := getNextNode(node, key)\nreturn nextNode.key if nextNode != ⊥ else key \n\ngetNextNode(node, key):\nif node != ⊥ and node.right != ⊥ then\n  node := node.right\n  while node.left != ⊥ do node = node.left\n  return node\nelse\n  node := node.parent\n  while node != ⊥ do\n    if node.key > key then return node\n    node := node.parent\n  return ⊥",
    "source": "ds-slide08_page_33",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 33,
      "page_heading": "# 부모 링크의 유지 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0277"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide08_page_34",
    "meta_data": {
      "tables": [],
      "lecture_title": "이진 검색 트리",
      "page_no": 34,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0278"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n![](images/0_3.jpg)\n\n![](images/0_4.jpg)\n\n# 균형 이진 검색 트리 \n\nNOTE 09 \n\n# 한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide09_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 1,
      "page_heading": "# 균형 이진 검색 트리",
      "images": [
        "ds-slide09/images/0_0.jpg",
        "ds-slide09/images/0_1.jpg",
        "ds-slide09/images/0_2.jpg",
        "ds-slide09/images/0_3.jpg",
        "ds-slide09/images/0_4.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0279"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 균형 이진 검색 트리(self-balancing BST) \n\n● AVL 트리 \n\n● 왼쪽 회전, 오른쪽 회전 \n\n● 이중 회전 \n\n● Red-black 트리 \n\n● Splay 트리 \n\n● 랜덤 검색 트리(RST, Random Search Tree) \n\n● 기타 트리 \n\n![](images/1_0.jpg)",
    "source": "ds-slide09_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide09/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0280"
  },
  {
    "type": "강의자료",
    "text": "# AVL Tree (1/2) \n\n- 항상 균형을 유지하는 이진 검색 트리 \n\n- 어떻게? \n\n- 더 중요한 것은 균형 트리임을 측정할 수 있어야 함 \n\n- 노드의 높이를 이용함 \n\n- (AVL 특성) 왼쪽 부분 트리와 오른쪽 부분 트리의 높이의 차이가 1 이하가 되도록 함 \n\n- 이진 검색 트리의 노드에 높이 정보를 추가함 \n\n- 어떻게 갱신? \n\nstruct TreeNode{\n    int key;\n    TreeNode* left{nullptr};\n    TreeNode* right{nullptr};\n    // TreeNode* parent{nullptr};\n};\n\nstruct TreeNode{\n    int key;\n    TreeNode* parent{nullptr};\n    TreeNode* left{nullptr};\n    TreeNode* right{nullptr};\n    long height;\n    // int balanceFactor;\n};",
    "source": "ds-slide09_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 3,
      "page_heading": "# AVL Tree (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0281"
  },
  {
    "type": "강의자료",
    "text": "## AVL Tree (2/2) \n\n● 이진 검색 트리의 모든 노드가 AVL 특성을 만족하면 트리 높이가 O(log n)임 \n\n● 삽입하면 트리의 균형이 깨질 수 있지만 균형 이진 검색 트리는 다시 균형되도록 트리를 조정하며, 이 비용도 O(log n)임 \n\n● 트리를 전체적으로 재구성하는 것이 아님 \n\n● 참고. 노드 높이: 노드에서 그것의 가장 먼 후손 단말 노드까지의 거리 \n\n● 단말 노드의 높이는 0임 \n\n● 1+max(node->left->height, node->right->height) \n\n● 참고. AVL 트리에서 AVL는 그것을 제안한 Adelson-Velsky와 Landis의 이름에서 따온 것임",
    "source": "ds-slide09_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 4,
      "page_heading": "## AVL Tree (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0282"
  },
  {
    "type": "강의자료",
    "text": "# AVL Tree의 높이와 노드 간 관계 (1/3) \n\n- 정리. 이진 검색 트리에서 AVL 특성을 만족하는 노드 \\(a\\)의 높이가 \\(h\\)이면 이 노드가 루트가 되는 부분 트리의 크기는 최소 피보나치 수 \\(F_{h+1}\\)보다 같거나 크다. \n\n- 참고. 크다는 것은 노드가 많다는 개념 \n\n- 증명) 귀납법 \n\n\\[ \\text{Fact. } k \\ge 6 \\text{이면 } F_k \\ge 2^{k/2} \\text{임} \\]\n\n\\[ \\begin{aligned} n &\\ge F_{h+1} \\ge 2^{\\frac{h+1}{2}} \\\\ h &\\le 2 \\log n - 1 \\end{aligned} \\]\n\n\\[ F_1 = 1 \\text{이므로 성립함} \\]\n\n- 귀납출발. \\(h = 0\\)이면 부분 트리의 크기는 1임. \\(F_1 = 1\\)이므로 성립함 \n\n- 귀납가정. 노드 \\(a\\)의 높이가 \\(h\\)보다 작으면 정리가 성립함 \n\n- 귀납단계. 노드 \\(a\\)의 높이가 \\(h\\)이면 두 자식 부분 트리 중 하나는 \\(h-1\\)이고, 다른 쪽은 최소 \\(h-2\\)임 \n\n![](images/4_0.jpg)",
    "source": "ds-slide09_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 5,
      "page_heading": "# AVL Tree의 높이와 노드 간 관계 (1/3)",
      "images": [
        "ds-slide09/images/4_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0283"
  },
  {
    "type": "강의자료",
    "text": "# AVL Tree의 높이와 노드 간 관계 (2/3) \n\n- 귀납 가정에 의해 높이가 \\(h-1\\)인 부분 트리의 크기는 \\(F_h\\)보다 같거나 크고, 다른 쪽은 최소 \\(F_{h-1}\\)보다 같거나 큼 \n\n- \\(N(a) = N(L) + N(R) + 1\\), \\(N(a)\\): 노드 \\(a\\)의 크기 \n\n- \\(N(L) \\ge F_h\\), \\(N(R) \\ge F_{h-1}\\) (귀납 가정) \n\n- \\(N(a) \\ge F_h + F_{h-1} + 1 = F_{h+1} + 1\\) \n\n- \\(N(a) \\ge F_{h+1}\\) \n\n- 따라서 노드 \\(a\\)가 루트가 되는 부분 트리의 크기는 최소 \\(F_{h+1}\\)보다 같거나 큼 (정리 끝) \n\n- \\(F_n \\ge 2^{n/2}\\)이 성립하므로 높이가 \\(h\\)인 노드 \\(a\\)가 루트가 되는 트리의 크기 \\(N(a) \\ge F_{h+1} \\ge 2^{n/2} \\ge 2^{(h+1)/2}\\)임 \n\n- 따라서 트리의 크기를 \\(n\\)이라 하면 \\(n \\ge 2^{(h+1)/2}\\)이 성립하며, 높이 관계로 정리하면 \n\n- \\(h \\le 2 \\log n - 1 = O(\\log n)\\)",
    "source": "ds-slide09_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 6,
      "page_heading": "# AVL Tree의 높이와 노드 간 관계 (2/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0284"
  },
  {
    "type": "강의자료",
    "text": "# AVL Tree의 높이와 노드 간 관계 (3/3) \n\n![](images/6_0.jpg)\n\n \n\n- **AVL 트리**: 왼쪽, 오른쪽 부분 트리 높이의 차이가 최대 1\n- **트리 T의 크기 N(T) = 1 + N(L) + N(R)**\n- **H(T) = h이면 H(L) = h - 1, H(R) = h - 1 또는 h - 2** \n\n- \\(N_h\\): 높이가 \\(h\\)인 트리의 크기 \n\n- \\(N_h \\ge 1 + N_{h-1} + N_{h-2}\\) \n\n- \\(N_h \\ge 1 + 1 + N_{h-2} + N_{h-3} + N_{h-2} = 2N_{h-2} + N_{h-3} + 2\\) \n\n- \\(N_h > 2N_{h-2} > 2^2N_{h-4} > 2^3N_{h-6} > \\cdots > 2^{2N_0} > 2^{2}\\) \n\n- \\(h < 2 \\log N_h\\)",
    "source": "ds-slide09_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 7,
      "page_heading": "# AVL Tree의 높이와 노드 간 관계 (3/3)",
      "images": [
        "ds-slide09/images/6_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0285"
  },
  {
    "type": "강의자료",
    "text": "# AVL 트리 예 \n\n## ● AVL 트리: 모든 노드의 균형 인자가 -1, 0 또는 1인 이진 트리 \n\n![](images/7_0.jpg)\n\n \n\n- 균형 인자(balance factor):\n  오른쪽 부분트리의 높이 – 왼쪽 부분트리의 높이\n- 높이를 유지해야 균형 인자를 계산할 수 있음 \n\n- https://www.cs.usfca.edu/~galles/visualization/AVLtree.html",
    "source": "ds-slide09_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 8,
      "page_heading": "# AVL 트리 예",
      "images": [
        "ds-slide09/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0286"
  },
  {
    "type": "강의자료",
    "text": "# AVL Tree \n\n- https://visualgo.net/bn/bst \n\n## ● 트리의 균형이 언제 바뀔 수 있나? \n\n### ● 삽입과 삭제 \n\n![](images/8_0.jpg)\n\n \n\n- 삽입된 노드부터 루트까지 경로에 있는 노드의 높이만 변함\n- 원래 균형 트리이었으므로 경로 차이는 최대 2까지만 발생 가능\n- 높이 정보 대신에 균형 인자(오른쪽 부분 트리 높이 – 왼쪽 부분 트리 높이)를 유지하는 형태로 구현할 수 있음\n- 참고. 모든 삽입과 삭제가 균형 특성을 바꾸는 것은 아닐",
    "source": "ds-slide09_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 9,
      "page_heading": "# AVL Tree",
      "images": [
        "ds-slide09/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0287"
  },
  {
    "type": "강의자료",
    "text": "# AVL Tree \n\n## ● 삼입 연산 \n\n**add(key):** \n\n**newNode := allocate TreeNode(key)** \n\n**if isEmpty() then root := newNode** \n\n**else** \n\n**parent := findNode(key, root)** \n\n**if parent.key == key then return** \n\n**if parent.key > key then parent.left := newNode** \n\n**else parent.right := newNode** \n\n**newNode.parent := parent** \n\n**rebalance(parent)** \n\n**++numNodes** \n\n- 일반 BST처럼 삼입 (높이 정보, 균형 인자 갱신 필요) \n\n- 높이 정보를 갱신하면서 균형이 깨진 노드를 찾음 \n\n**rebalance(parent)** \n\n- 균형이 깨진 노드를 기준으로 트리를 재구성하여 균형 성질 복원",
    "source": "ds-slide09_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 10,
      "page_heading": "# AVL Tree",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0288"
  },
  {
    "type": "강의자료",
    "text": "## ● rebalance \n\nrebalance(node):  if node == ⊥ then return  parent := node.parent  leftHeight := node.left.height if node.left != ⊥ else -1  rightHeight := node.right.height if node.right != ⊥ else -1  if abs(rightHeight-leftHeight) == 2 then  if leftHeight > rightHeight then rebalanceRight(node)  else rebalanceLeft(node)  adjustHeight(node)  rebalance(parent)  ●  균형이 깨진 노드를 기준으로 트리를  재구성하는 것으로 끝나는 것이 아님  ●  그 노드부터 루트 노드까지 올라가면서  계속 재구성해야 할 수 있음  ●  이 반복은 O(log n)으로 제한됨 \n\n## ● adjustHeight \n\nadjustHeight(node):  leftHeight := node.left.height if node.left != ⊥ else -1  rightHeight := node.right.height if node.right != ⊥ else -1  node.height := 1 + max(leftHeight, rightHeight) \n\n● 특별한것없음. 왼쪽과오른쪽자식노드의높이를이용하여조정",
    "source": "ds-slide09_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 11,
      "page_heading": "## ● rebalance",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0289"
  },
  {
    "type": "강의자료",
    "text": "# Rebalancing AVL Tree \n\n- 문제가 된 노드부터 시작하여 루트까지 반복함 \n\n- **Fact.** 차이가 최대 2임 \n\n- 노드가 균형이면 그 노드에 대해서는 아무것도 하지 않음 \n\n![](images/11_0.jpg)\n\n \n\nrebalanceLeft(node):\n    rightChild := node.right\n    if rightChild != ⊥ then\n    leftHeight := rightChild.left.height if rightChild.left != ⊥ else -1\n    rightHeight := rightChild.right.height if rightChild.right != ⊥ else -1\n    if leftHeight > rightHeight then rotateRight(rightChild)\n    rotateLeft(node)",
    "source": "ds-slide09_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 12,
      "page_heading": "# Rebalancing AVL Tree",
      "images": [
        "ds-slide09/images/11_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0290"
  },
  {
    "type": "강의자료",
    "text": "# Single rotation \n\n## singleRotateRight \n\nP := A.parent\nB := A.left\nT2 := B.right\nB.parent := P\nP.appropriateChild := B\nB.right := A\nA.left := T2\nT2.parent := A\nA.parent := B \n\n![](images/12_0.jpg)\n\n \n\n## singleRotateLeft \n\nP := B.parent\nA := B.right\nT2 := A.left\nA.parent := P\nP.appropriateChild := A\nA.left := B\nB.right := T2\nT2.parent := B\nB.parent := A \n\n![](images/12_1.jpg)",
    "source": "ds-slide09_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 13,
      "page_heading": "# Single rotation",
      "images": [
        "ds-slide09/images/12_0.jpg",
        "ds-slide09/images/12_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0291"
  },
  {
    "type": "강의자료",
    "text": "![](images/13_0.jpg)",
    "source": "ds-slide09_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 14,
      "page_heading": "",
      "images": [
        "ds-slide09/images/13_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0292"
  },
  {
    "type": "강의자료",
    "text": "![](images/14_0.jpg)",
    "source": "ds-slide09_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 15,
      "page_heading": "",
      "images": [
        "ds-slide09/images/14_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0293"
  },
  {
    "type": "강의자료",
    "text": "# Remove (1/3) \n\n## ● 삭제 연산 \n\ndelete(k, root)\nM := parent of actual deleted node N\nrebalance(M) \n\n- 삭제한 노드가 단말: 그것의 부모 노드는 단말 노드가 됨\n- 삭제한 노드가 한 쪽으로만 부분 트리를 갖고 있는 경우\n  - 부분 트리에 있는 노드의 높이는 변하지 않음 \n\n![](images/15_0.jpg)",
    "source": "ds-slide09_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 16,
      "page_heading": "# Remove (1/3)",
      "images": [
        "ds-slide09/images/15_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0294"
  },
  {
    "type": "강의자료",
    "text": "![](images/16_0.jpg)",
    "source": "ds-slide09_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 17,
      "page_heading": "",
      "images": [
        "ds-slide09/images/16_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0295"
  },
  {
    "type": "강의자료",
    "text": "![](images/17_0.jpg)",
    "source": "ds-slide09_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 18,
      "page_heading": "",
      "images": [
        "ds-slide09/images/17_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0296"
  },
  {
    "type": "강의자료",
    "text": "## Merge/Split (1/2) \n\n● 두 개의 AVL 트리를 하나의 AVL 트리로 합치거나 하나의 AVL 트리를 두 개의 AVL 트리로 분리할 수 있음 \n\n● 일반 정렬 리스트의 합병(merge) \n\n● 정렬된 두 개의 리스트의 결합: 합병 정렬의 합병 연산 이용. O(n) \n\n● 두 리스트가 중첩되지 않으면 쉽게 합병할 수 있음 \n\n● AVL 트리 R1과 R2가 서로 중첩되어 있지 않을 때 합병하는 방법? \n\n● R1의 모든 키는 R2의 가장 작은 값보다 작다고 가정 \n\n● 방법 1. R2에서 가장 작은 값의 자식으로 R1 추가 \n\n● 방법 2. R1에서 가장 큰 값의 자식으로 R2 추가 \n\n● 방법 3. 노드를 하나 추출하여 합병 트리의\n루트 노드로 사용 \n\n● 어떤 노드? R1의 가장 큰 노드\n또는 R2의 가장 작은 노드 \n\n![](images/18_0.jpg)",
    "source": "ds-slide09_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 19,
      "page_heading": "## Merge/Split (1/2)",
      "images": [
        "ds-slide09/images/18_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0297"
  },
  {
    "type": "강의자료",
    "text": "## Merge/Split (2/2) \n\n● 중첩되지 않은 두 AVL 트리를 이전 슬라이드에 제시한 3개 방법 중 하나를 이용하여 합병하면 균형이 유지되지 않음 \n\n![](images/19_0.jpg)",
    "source": "ds-slide09_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 20,
      "page_heading": "## Merge/Split (2/2)",
      "images": [
        "ds-slide09/images/19_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0298"
  },
  {
    "type": "강의자료",
    "text": "## Red-Black Tree (1/4) \n\n● 각 노드는 빨간 또는 검정 노드이어야 함 \n\n● AVL은 노드의 높이를 유지 → Red-Black 트리는 색을 유지 \n\n● Red-Black 트리의 요구사항 \n\n● R1. 각 노드는 빨간 또는 검정 노드이어야 함 \n\n● R2. 루트 노드는 항상 검정 노드이어야 함 \n\n● R3. 두 개가 연속 빨간 노드일 수 없음 (노드가 빨간 노드이면 그것의 자식은 빨간 노드일 수 없음) \n\n● R4. 모든 실패 검색에 대해 루트부터 지나가는 검정 노드의 수는 동일해야 함 \n\n![](images/20_0.jpg)\n\n 균형의 조건 \n\n● 1, 4, 6, 7, 9, 11 검색: 2개의 검정",
    "source": "ds-slide09_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 21,
      "page_heading": "## Red-Black Tree (1/4)",
      "images": [
        "ds-slide09/images/20_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0299"
  },
  {
    "type": "강의자료",
    "text": "# Red-Black-Tree (2/4) \n\n- 왜 트리가 4개의 요구사항을 충족하면 균형 트리가 될까? \n\n  - 균형 트리는 아니지만 그것의 높이는 \\(O(\\log n)\\)임 \n\n  - 4개의 요구사항을 어떻게 계속 충족할 수 있을까? \n\n  - 삽입과 삭제는 어떻게? \n\n  - 두 가지 방법 사용 \n\n  - 노드의 색 변경 \n\n  - AVL과 마찬가지로 오른쪽, 왼쪽 회전 사용 \n\n  - 노드를 추가할 때 빨간 노드로 추가함 (R4 요구사항 충족에 유리) \n\n  - 부모가 빨간 노드가 아니면 아무 문제 없음 \n\n![](images/21_0.jpg)",
    "source": "ds-slide09_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 22,
      "page_heading": "# Red-Black-Tree (2/4)",
      "images": [
        "ds-slide09/images/21_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0300"
  },
  {
    "type": "강의자료",
    "text": "## Red-Black-Tree (3/4) \n\n● AVL 트리는 삽입할 때 노드를 실제 삽입하기 위해 단말까지 탐색해야 하며, 삽입한 이후에는 균형을 유지하기 위해 다시 투트까지 탐색해야 함 \n\n● 삭제도 유사함 \n\n● Red-Black 트리는 단말까지 한번의 탐색만으로 모든 과정을 처리함 \n\n● 주어진 이진 탐색 트리가 유효한 red-black 트리이어도 이 트리는 유효한 AVL 트리가 아닐 수 있을 \n\n● 즉, AVL 트리가 더 균형 트리임 \n\n● 두 트리가 서로 장단점이 있지만 삽입과 삭제 비용이 저렴한 Red-Black 트리를 더 많이 사용하고 있음 \n\n![](images/22_0.jpg)",
    "source": "ds-slide09_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 23,
      "page_heading": "## Red-Black-Tree (3/4)",
      "images": [
        "ds-slide09/images/22_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0301"
  },
  {
    "type": "강의자료",
    "text": "## Red-Black-Tree (4/4) \n\n● 빈 트리: 검정 노드로 추가 \n\n● 빈 트리가 아니면 일반 이진 검색 트레이셔 삽입 과정 수행 \n\n● 수행 과정에서 두 자식이 모두 빨간 노드인 노드를 만나면 모두 색을 변경함. 이때 노드가 루트 노드이면 빨간 노드를 다시 검정 노드로 바꿈 \n\n● 새 노드를 단말로 추가할 때 부모 노드가 검정 노드이면 빨간 노드로 추가하고 종료 \n\n● 반면에 빨간 노드이고 직선 형태이면 왼쪽 또는 오른쪽 회전하고 위로 올라간 노드는 검정 노드로 내려온 노드는 빨간 노드로 색을 변경함 \n\n● 직선이 아니면 먼저 직선으로 바꾼 후 회전을 함 (이중 회전) \n\n![](images/23_0.jpg)",
    "source": "ds-slide09_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 24,
      "page_heading": "## Red-Black-Tree (4/4)",
      "images": [
        "ds-slide09/images/23_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0302"
  },
  {
    "type": "강의자료",
    "text": "● 자주 검색하는 것이 루트에 가까울수록 검색 평균 비용은 향상함 \n\n● 자주 검색하는 것을 루트에 가깝게 유지함 \n\n● Zig-Zig, Zig-Zag, Zig 상황에 따라 노드를 루트에 가깝도록 하는 방법의 차이가 있을 \n\n![](images/24_0.jpg)",
    "source": "ds-slide09_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 25,
      "page_heading": "",
      "images": [
        "ds-slide09/images/24_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0303"
  },
  {
    "type": "강의자료",
    "text": "● RST(Randomized Search Tree), Treap(Tree+Heap) \n\n● 각 노드는 키와 우선순위 값을 유지함 \n\n● 다음 두 요구사항을 충족하는 이진 검색 트리 \n\n○ R1. 노드의 키에 대해서는 이진 검색 트리 조건을 충족해야 함 \n\n○ R2. 노드의 우선순위에 대해서는 힙 특성을 충족해야 함 \n\n● 삽입. 키 기준으로 일반 BST 삽입 후 우선순위를 바탕으로 reheap up 과정을 수행함. 이 과정에서 왼쪽, 오른쪽 회전을 수행함 \n\n● 우선순위는 임의로 결정하면 모든 연산의 평균 비용은 O(log n)이 됨 \n\n![](images/25_0.jpg)\n\n![](images/25_1.jpg)",
    "source": "ds-slide09_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 26,
      "page_heading": "",
      "images": [
        "ds-slide09/images/25_0.jpg",
        "ds-slide09/images/25_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0304"
  },
  {
    "type": "강의자료",
    "text": "# Prefix Tree, Radix Tree \n\n![](images/26_0.jpg)\n\n \n\n- 키가 N개의 문자로 구성된 알파벳을 사용하면 자식의 수가 최대 N개를 가질 수 있음\n- 키 충돌이 발생할 수 없음\n- 유사한 값들은 서로 가깝게 유지됨\n- 키 길이가 길고 키의 앞 부분을 공유하는 다른 값들이 없을 경우 효율성이 떨어짐 \n\n**class TrieNode{**\n**private:**\n**TrieNode* children[26];**\n**int val{-1};**\n**}; // 알파벳 소문자로 키가 구성될 경우**",
    "source": "ds-slide09_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 27,
      "page_heading": "# Prefix Tree, Radix Tree",
      "images": [
        "ds-slide09/images/26_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0305"
  },
  {
    "type": "강의자료",
    "text": "## 다루지 못한 트리 \n\n● B Tree\n● B+ Tree \n\n![](images/27_0.jpg)\n\n 파일 시스템 저장된 데이터에 대한 색인작업을 위해  널리 사용되지만 메모리에 유지하는 검색 구조  측면에서 효과적이지 못함",
    "source": "ds-slide09_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "균형 이진 검색 트리",
      "page_no": 28,
      "page_heading": "## 다루지 못한 트리",
      "images": [
        "ds-slide09/images/27_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0306"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n![](images/0_3.jpg)\n\n![](images/0_4.jpg)\n\n# Set, Map, Hashing \n\nNOTE 10 \n\n# 한국기술교육대학교 컴퓨터공학부 김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide10_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 1,
      "page_heading": "# Set, Map, Hashing",
      "images": [
        "ds-slide10/images/0_0.jpg",
        "ds-slide10/images/0_1.jpg",
        "ds-slide10/images/0_2.jpg",
        "ds-slide10/images/0_3.jpg",
        "ds-slide10/images/0_4.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0307"
  },
  {
    "type": "강의자료",
    "text": "# 교육목표 \n\n![](images/1_0.jpg)\n\n \n\n- 집합(set) \n\n- 맵(map) \n\n- Hashing: 집합과 맵을 구현할 때 주로 사용하는 방법 \n\n  - 기본적으로 O(1)으로 검색 가능 \n\n  - 참고. Hashing 기술 대신에 균형 이진 검색 트리로 집합과 맵을 구현할 수 있음 \n\n  - 균형 이진 검색 트리를 이용한 구현은 저장된 요소에 대한 순서를 효과적으로 얻을 수 있음 (해싱은 이것이 가능하지 않음) \n\n<table><tr><td rowspan=\"2\"></td><td colspan=\"2\">집합</td><td colspan=\"2\">맵</td></tr><tr><td>hashing</td><td>균형BST</td><td>hashing</td><td>균형BST</td></tr><tr><td>C++</td><td>unordered_set</td><td>set</td><td>unordered_map</td><td>map</td></tr><tr><td>자바</td><td>HashMap</td><td>TreeSet</td><td>HashMap</td><td>TreeMap</td></tr><tr><td>파이썬</td><td>set</td><td></td><td>dict</td><td></td></tr></table>",
    "source": "ds-slide10_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 2,
      "page_heading": "# 교육목표",
      "images": [
        "ds-slide10/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0308"
  },
  {
    "type": "강의자료",
    "text": "## 집합(set) \n\n● 수학적 개념이 명확한 자료구조 \n\n● 유지되는 요소 간의 어떤 순서도 존재하지 않음 \n\n● 중복된 요소가 없음 \n\n● 중요 연산 \n\n● add \n\n● contains \n\n● remove \n\n● 집합 간 연산: 합집합, 교집합, 차집합 등 \n\n● 기본 연산을 이용하여 집합 간 연산을 모두 구현 가능 \n\n● 응용) syntax highlighting: keyword 집합",
    "source": "ds-slide10_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 3,
      "page_heading": "## 집합(set)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0309"
  },
  {
    "type": "강의자료",
    "text": "## 구현 방법 \n\n● 방법 1. Lookup Table (direct addressing). 0(1) \n\n● 집합 도메인의 크기만큼 임의 접근 가능한 공간을 확보하여 사용함 \n\n● 예) 도메인이 소문자이면 bool flag[26]을 사용 \n\n● 값을 테이블에 매핑하는 방법이 있어야 하고, 이 방법은 충돌이 발생하지 않아야 함 \n\n● 예) c-'a' \n\n● 집합 자료구조는 실제 데이터를 자료구조에 저장할 필요는 없음 \n\n● 포함되어 있는지 여부만 알려줄 수 있으면 됨 \n\n● 도메인이 크면 사용하기 힘들 \n\n● 대안. 비트 벡터 \n\n● 방법 2. 균형 이진 검색 트리 이용 \n\n● 삽입, 삭제, 검색: O(logn) \n\n● 방법 2와 방법 3은 실제 데이터를 저장함 \n\n● 방법 3. Hashing 이용 (이 노트 후반부에 자세히 설명) \n\n● 도메인 크기만큼의 공간을 사용하지 않음",
    "source": "ds-slide10_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 4,
      "page_heading": "## 구현 방법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0310"
  },
  {
    "type": "강의자료",
    "text": "## 비트 벡터 \n\nC++에서 std::vector<bool>을 사용하면 내부적으로 실제 비트 벡터로 구현되어 있음 \n\n● 비트 벡터: 요소의 존재 여부 기록 \n\n●하나의 비트로 도메인의 특정 값의 존재 여부를 나타낸 \n\n●구현 방법 1. 실제 비트 벡터로 구현 \n\n●구현 방법 2. bool 배열을 이용하여 구현 \n\n●도메인 적은 경우에만 적합 \n\n●예) 1에서 10까지의 수 \n\nC++의 bool, 자바 boolean의 크기: 1byte \n\n●bool flag[10] \n\n●flag[i-1]이 true이면 해당 수가 집합에 포함 \n\n●Lookup 테이블의 문제점 \n\n●저장된 요소의 개수와 무관하게 항상 고정된 공간 필요 \n\n●도메인의 크기에 따라 많은 공간이 요구됨 \n\n●데이터를 색인으로 매핑하는 연산 필요",
    "source": "ds-slide10_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 5,
      "page_heading": "## 비트 벡터",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0311"
  },
  {
    "type": "강의자료",
    "text": "## 비트 벡터의 구현 \n\n● 1byte 크기의 정수형 배열로 구현 \n\n● 색인 11의 위치? \n\n○ vector[0]: 0~7, vector[1]: 8~15, ... \n\n○ vector[1] = xxxx xxxx \n\n● 계산 방법 \n\n○ byte index: 11/8 = 11>>3 = 0000 1011 >> 3 = 0000 0001 = 1 \n\n○ bit index: 11%8 = 0000 1011 & 0000 0111 = 0000 0011 = 3 \n\n● set: 해당 위치를 1로 바꾸는 방법 → OR \n\n○ xxxx xxxx | 0001 0000 = xxx1 xxxx \n\n● unset: 해당 위치를 0으로 바꾸는 방법 → AND \n\n○ xxxx xxxx & 1110 1111 = xxx0 xxxx \n\n● flip: 해당 위치 값을 뒤집는 방법 → XOR \n\n○ xxxx xxxx ^ 0001 0000 = xxx? xxxx \n\n○ C++: \n  unsigned char vector[4] \n  uint8_t vector[4] \n  자바: byte[] vector \n  파이썬3: bytearray() \n\n○ mask = 128>>bitIndex \n\n○ mask = ~(128>>bitIndex)",
    "source": "ds-slide10_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 6,
      "page_heading": "## 비트 벡터의 구현",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0312"
  },
  {
    "type": "강의자료",
    "text": "## 교집합 \n\n● 알고리즘 1. \n\nC = [] for i=1 to A.size() do if B.contains(A[i]) then C.add(A[i]) \n\n● 가정. 색인은 1부터 \n\n● 분석: O(n): Hashing, O(nlogn): BST \n\n● 집합의 contains 연산 비용에 따라 (비트 벡터는?) \n\n● 알고리즘 2. 두 집합이 정렬되어 있고 요소들을 비교할 수 있다고 가정 \n\nC = [] a = b = 1 while a<=A.size() and b<=B.size() do if A[a]==B[b] then C.add(A[a]) a += 1 b += 1 else A[a]<B[b] then a += 1 else b += 1 \n\n● 합병 정렬에서 합병 알고리즘과 유사",
    "source": "ds-slide10_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 7,
      "page_heading": "## 교집합",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0313"
  },
  {
    "type": "강의자료",
    "text": "# 실습 순서 \n\n- 비트 벡터 구현 \n\n- std::vector<bool>을 합집합, 차집합, 교집합 구현 \n\n- Hashing 학습 후 hashing을 이용한 집합 구현",
    "source": "ds-slide10_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 8,
      "page_heading": "# 실습 순서",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0314"
  },
  {
    "type": "강의자료",
    "text": "## Map \n\n● 키와 데이터를 연관하여 유지하는 자료구조 \n\n○ 집합과 마찬가지로 요소 간의 순서가 존재하지 않음 \n\n● 기본 연산 \n\n○ put(K, V) \n\n● 해당 키가 존재하면 연관된 값을 교체함 \n\n○ get(K) \n\n○ containsKey(K) \n\n● 기타연산 \n\n○ containsValue(V) \n\n○ getEntrySet, getKeySet, getValueSet, size, isEmpty \n\n● 구현 \n\n○ 집합과 유사한 방법으로 균형 이진 검색 트리나 해싱을 이용함 \n\n○ 차이점. 키만 저장하는 것이 아니라 데이터를 함께 저장함",
    "source": "ds-slide10_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 9,
      "page_heading": "## Map",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0315"
  },
  {
    "type": "강의자료",
    "text": "# 웹 서비스의 접속 로그 (1/2) \n\n## ● 특정 웹 서비스 운영자 \n\n### ● 다음과 같은 접근 로그를 유지 \n\n<table><tr><td>날짜</td><td>시간</td><td>IP주소</td></tr><tr><td>2019.8.6.</td><td>10:21:22</td><td>166.104.22.91</td></tr><tr><td>2019.8.6.</td><td>10:21:23</td><td>177.122.100.3</td></tr></table>\n\n### ● 원하는 정보 \n\n- **질문 1.** 특정 IP 주소에서 지난 1시간 동안 접속한 적이 있나? \n\n- **질문 2.** 특정 IP 주소에서 지난 1시간 동안 몇 번 접속했나? \n\n- **질문 3.** 몇 개의 IP에서 지난 1시간 동안 접속이 이루어졌나? \n\n- **위와 같은 정보를 얻기 위한 방법은?** \n\n- **특별한 자료구조를 이용하지 않으면** \n\n- **질문 1, 2, 3:** \\(O(n)\\) \n\n- **질문 3은 자료구조를 이용하지 않고 처리하기 힘들**",
    "source": "ds-slide10_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 10,
      "page_heading": "# 웹 서비스의 접속 로그 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0316"
  },
  {
    "type": "강의자료",
    "text": "# 웹 서비스의 접속 로그 (2/2) \n\n## ● 지난 1시간 동안 특정 IP의 접속 수를 유지하는 자료구조 사용 \n\n<table><tr><td>IP주소</td><td>카운터</td></tr><tr><td>166.104.22.91</td><td>1</td></tr><tr><td>177.122.100.3</td><td>3</td></tr></table>\n\n- 특정 ip주소에 대한\n  counter[ip주소]를 접근하는\n  비용에 의해 질문의 비용이 결정됨 \n\n### ● 질문 1. counter[ip주소]>0 \n\n### ● 질문 2. counter[ip주소] \n\n### ● 질문 3. for(all ip주소) if counter[ip주소]>0 then sum += 1 \n\n### ● 위 자료구조는 어떻게 구성 \n\nfor every second do \n\nfor each log entering the interval do \n\nif counter[log.ip]==0 then numIPs += 1 \n\ncounter[log.ip] += 1 \n\nfor each log leaving the interval do \n\ncounter[log.ip] -= 1 \n\nif counter[log.ip]==0 then numIPs -= 1 \n\n- 이와 같은 numIPs를 계속 갱신하면\n  질문 3도 O(1)에 제공 가능",
    "source": "ds-slide10_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 11,
      "page_heading": "# 웹 서비스의 접속 로그 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0317"
  },
  {
    "type": "강의자료",
    "text": "# Counter 자료구조 \n\n## ● Direct addressing \n\n- 2³² 용량의 배열을 이용 \n\n- 여기서 필요한 것은 집합이 아니라 맵임 \n\n- 따라서 비트 벡터를 활용하여 공간을 절약할 수 없음 \n\n- ip주소를 32비트 정수로 변환하여 색인으로 사용: (int)ip \n\n- 질문 1, 2: O(1), 질문 3: O(2³²) \n\n- 문제점. 지난 1시간 동안 5곳에서만 방문 → 공간 낭비 \n\n- 메모리 요구사항: O(2³²) \n\n- 연결구조 방식의 큐 사용: n(지난 1시간 동안 접속한 ip 수) \n\n- 새 접속: queue.pushBack() \n\n- 시간 경과: queue.popFront() \n\n- 메모리 요구사항: O(n) \n\n- 질문 1, 2, 3: O(n) \n\n- Hashing을 이용한 맵: 3질문 모두 O(1) \n\n- 균형이진트리를 이용한 맵: \n\n- 질문 1, 2는 O(log n), 질문 3은 O(1) \n\n- 질문 3은 맵의 size 값: 값이 0이 되면 삭제 필요",
    "source": "ds-slide10_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 12,
      "page_heading": "# Counter 자료구조",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0318"
  },
  {
    "type": "강의자료",
    "text": "## 해싱 (1/3) \n\n● 배열 기반 정렬 리스트, 균형 이진 검색 트리 검색 비용: O(log n) \n\n● Lookup Table 검색 비용: O(1) \n\n● 공간 복잡도는 도메인 크기만큼 필요 \n\n● 예1) 직원이 최대 100명인 회사, 각 직원의 식별번호가 0부터 99이면 용량 100인 배열을 이용하여 O(1)에 접근 가능 \n\n● 예2) 같은 회사에서 직원의 식별번호를 다섯자리 정수를 사용한다면 용량이 100,000인 배열을 이용하는 것은 공간 낭비가 될 수 있음 \n\n● 예3) 예2에서 배열의 용량을 100으로 하고, 식별번호 중 마지막 두 자리만 사용하면? 10734이면 list[33]에 유지 \n\n● 문제는? 21534도 같은 위치 → 충돌(collision) \n\n● 해싱: 해시함수와 해시 테이블을 이용하여 O(1) 접근을 제공하는 기술 \n\n![](images/12_0.jpg)\n\n● 3가지 요소: 해시 테이블, 해시 함수, 충돌 해결 전략",
    "source": "ds-slide10_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 13,
      "page_heading": "## 해싱 (1/3)",
      "images": [
        "ds-slide10/images/12_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0319"
  },
  {
    "type": "강의자료",
    "text": "# 해싱 (2/3) \n\n## ● 기본 용어 \n\n- 해시 테이블: 데이터를 유지하는 임의 접근이 가능한 공간 \n\n- 보통 배열을 이용함 \n\n- 공간 복잡도: 1.3n \n\n- 슬롯(slot): 해시 테이블에서 각 요소를 저장하는 개별 공간 \n\n- 해시함수: 요소의 저장 위치를 찾기 위해 사용하는 함수 \n\n- 키(key): 해시함수의 입력 값 \n\n- 해시함수의 최종 출력: 해시 테이블의 위치 \n\n- 보통 해시함수 결과 값을 테이블 크기로 나머지 연산 수행 \n\n- 충돌이 최소화되는 해시함수가 우수한 해시함수임 \n\n- 접근 비용을 고려할 때 해시값 계산 비용은 포함하지 않음 \n\n- 비용이 기존 저장된 요소의 개수에 비례하지 않음 → 0(1) \n\n- 비용은 저장할 키 값에 좌우함",
    "source": "ds-slide10_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 14,
      "page_heading": "# 해싱 (2/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0320"
  },
  {
    "type": "강의자료",
    "text": "## 해싱 (3/3) \n\n● 해싱의 성능을 높이기 위해 필요한 요소  ● 좋은 해시 함수: 충돌이 최소화되는 함수  ● 입력의 범위보다 확보한 공간이 작으면 완벽한 해시함수를 만들  수 없음  ● 기존 훌륭한 해시함수를 활용하면 됨  ● 해시 테이블의 용량 결정  ● 공간은 적게 사용하고 싶음  ● 최소 저장하고자 하는 요소의 개수보다는 커야 함  ● 충돌 해결 전략: 충돌이 발생하였을 때 그것을 처리하는 방법",
    "source": "ds-slide10_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 15,
      "page_heading": "## 해싱 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0321"
  },
  {
    "type": "강의자료",
    "text": "# 해시함수 \n\n- 해시함수 \\(h\\) \n\n- 가능한 모든 키 값의 집합 \\(S\\)와 \\(m > 0\\)에 대해 \\(h: S \\to \\{0, ..., m-1\\}\\)인 함수를 말함 \n\n- 여기서 \\(m\\)은 \\(h\\)의 차수(cardinality)라 함 \n\n- \\(h\\)의 요구사항 \n\n- R1. 계산 속도가 빨라야 함 \n\n- R2. \\(\\forall s \\in S\\)에 대해 \\(\\Pr[h(s) = i] = \\frac{1}{m}\\)이어야 함 \n\n- \\(s \\neq s'\\)에 대해 \\(\\Pr[h(s)] = \\Pr[h(s')] \\le 1/m\\)이어야 함 \n\n- (충돌불가피성) \\(|S| > |m|\\)이면 \\(s \\neq s'\\)에 대해 \\(h(s) = h(s')\\)는 불가피함 \n\n- 예) mod \\(m\\) \n\n- R2가 충족되는 해시함수를 이용하여 \\(n\\)개의 요소를 해시하면 특정 값으로 해시되는 요소의 개수는 평균 \\(\\frac{n}{m}\\)임 \n\n- \\(n\\)개의 분포가 실제 충돌에 큰 영향을 줌",
    "source": "ds-slide10_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 16,
      "page_heading": "# 해시함수",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0322"
  },
  {
    "type": "강의자료",
    "text": "## 해시함수 예 \n\n<table><tr><td rowspan=\"2\">● 예) 문자열을 저장하고 싶음 ● 사용하는 배열의 용량이 5라 가정함 ● 문자열 길이를 해시함수로 사용 ● elephant는 어디에 저장? ● dog이 저장되어 있을 때 cat은 어디에 저장? ● 참고. 해시함수의 요구사항 R2를 만족하는 해시함수가 아님 ● 예) 문자열의 첫 문자만 이용하고 해시 테이블의 크기로 나머지 연산 ● dog, duck, donut은 모두 같은 위치로 매핑됨 ● 예) 문자열의 모든 문자를 더하고 해시 테이블의 크기로 나머지 연산 ● dog와 god는 같은 위치로 매핑됨 ● 교환법칙이 성립하지 않는 연산을 사용해야 함 ● 예) 문자열의 문자를 전혀 이용하지 않고 랜덤한 수를 생성하여 사용 ● dog에 대한 해시값을 계산할 때마다 값이 달라짐</td><td>None</td></tr><tr><td>None</td></tr></table>",
    "source": "ds-slide10_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 17,
      "page_heading": "## 해시함수 예",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0323"
  },
  {
    "type": "강의자료",
    "text": "# Hashing Integer, Hashing String \n\nHashing Integer: \\(\\mathcal{H}_p = \\{h_p^{a,b}(x) = ((ax + b) \\mod p) \\mod m\\}\\) \n\n- \\(p(>x)\\): 소수, \\(1 \\le a \\le p-1\\), \\(0 \\le b \\le p-1\\), \n\nHashing String: \\(\\mathcal{P}_p = \\{h_p^x(S) = \\sum_{i=0}^{|S|-1} S[i]x^i \\mod p\\}\\) \n\n- \\(p\\): 소수, \\(1 \\le x \\le p-1\\) \n\n- \\(p\\)가 결정되면 총 \\(p-1\\)개 함수를 만들 수 있음\n- 충돌이 발생할 확률은 \\((|S| - 1)/p\\)임 \n\nhash := 0 \n\nfor \\(i := |S| - 1\\) down to 0: \n\nhash := (hash*x + (int)(S[i])) mod p \n\n- Java String 클래스의 hashCode 매소드는 \\(x = 31\\)을 사용하고, \\(p\\)는 사용하지 않음 (꼭 downto를 사용하지 않아도 됨)\n- 문자열 해싱 후 결과 값을 다시 정수 해싱을 하여 최종적 위치 결정\n- 해시값 계산 비용은 문자열 길이에 비례함 \n\n여기에 제시된 두 개의 해시함수는 슬라이드 15에 주어진 해시 요구사항 R1, R2를 모두 만족함",
    "source": "ds-slide10_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 18,
      "page_heading": "# Hashing Integer, Hashing String",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0324"
  },
  {
    "type": "강의자료",
    "text": "# 충돌 처리 방법 – 열린 기법 \n\n- **방법 1.** 다른 빈 곳 (open addressing, closed hashing) \n\n- **방법 1-1.** 선형 조사(linear probing) 방법 \n\n- 배열을 순환 구조로 사용함 \n\n- 기본 linear probing은 +1 형태임 \n\n- +1 대신에 +k를 할 수 있으며, \n\n이때에는 배열의 용량과 k는 \n\n서로 소이어야 함. (아니면 일부 위치만 조사) \n\n- 목적은 배열의 모든 위치를 조사할 수 있어야 함 \n\n- +1은 모든 위치를 조사함 \n\n- 문제. clump \n\n- 근접한 색인값으로 매핑되는\n  키 값들이 뭉쳐 존재하는 현상 \n\nhash \n\ndata \n\n- 열린 기법: 최초 해시값 위치가 아닌 곳에 저장 가능 \n\n- 닫힌 해상: 최초 확보한 공간 내에서 해결",
    "source": "ds-slide10_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 19,
      "page_heading": "# 충돌 처리 방법 – 열린 기법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0325"
  },
  {
    "type": "강의자료",
    "text": "# 선형 조사 방법에서 삭제 \n\n<table><tr><td>8</td><td>16</td><td></td><td>11</td></tr></table>\n\nH(k) = k % 7\n선형조사 사용: (+1) \n\n- find(15) \n\n- H(15) = 10이므로 색인 1 위치를 검사함. 색인 1에 없으면, 그다음을 검사함\n색인 3에 아무것도 없기 때문에 더 이상 검사하지 않고 종료 \n\n<table><tr><td>8</td><td></td><td>15</td><td>11</td></tr></table>\n\n- insert(15), remove(16) 이후 다시 find(15) \n\n- 이전과 동일한 방법으로 처리할 수 없음 \n\n- 전체 검색 방법을 사용하면 효율성이 너무 떨어짐 \n\n- 극복 방법. 삭제 flag (이 플래그 설정되어 있으면 검사를 계속 진행함) \n\n<table><tr><td>8</td><td></td><td>15</td><td>11</td></tr></table>\n\n- 삭제 flag 사용할 경우 \n\n- 새 데이터를 이 플래그가 설정된 공간에 저장할 수 있음 \n\n- 하지만 조사 순서를 모두 검사하여 중복 여부를 확인한 후에 저장해야 함 \n\n- 삭제 flag가 많아지면 성능에 영향을 줌. 전체 rehashing이 필요할 수 \n\n있음 (삭제할 때 15와 삭제 플래그를 swap 하는 방법도 있음)",
    "source": "ds-slide10_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 20,
      "page_heading": "# 선형 조사 방법에서 삭제",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0326"
  },
  {
    "type": "강의자료",
    "text": "# 선형 조사와 clump \n\n- clump(또는 cluster): 근접한 색인값으로 매핑되는 키 값들이 뭉쳐 존재하는 현상 \n\n![](images/20_0.jpg)\n\n \n\n- 특정 키 값을 특정 slot에 삽입할 확률은 20%임 \n\n![](images/20_1.jpg)\n\n \n\n- 색인 0에 키 값이 저장되어 있을 때 색인 1에 삽입될 확률? \n\n- 20%가 아님 \n\n- H(K)==0, H(K)==1이어도 1에 삽입될 → 40% \n\n- 선형조사 방법은 충돌이 발생하면 특정 slot에 다음 키 값이 추가될 확률을 높이는 문제가 있음 \n\n![](images/20_2.jpg)\n\n \n\n- 다른 키로 해상되었지만 같은 위치를 조사하게 되는 문제도 있음 \n\n- 이것을 primary clustering이라 함 (서로 다른 해시값으로 매핑되는 키가 선형 조사 위치를 상당히 많이 공유하는 경우)",
    "source": "ds-slide10_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 21,
      "page_heading": "# 선형 조사와 clump",
      "images": [
        "ds-slide10/images/20_0.jpg",
        "ds-slide10/images/20_1.jpg",
        "ds-slide10/images/20_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0327"
  },
  {
    "type": "강의자료",
    "text": "# Clump 해결방법 \n\n![](images/21_0.jpg)\n\n \n\n- **방법 1-2. Random probing** \n\n  - 실제 랜덤값을 사용할 수는 없음 \n\n  - 결정적으로 찾아갈 수 있어야 하기 때문 \n\n  - 의사난수발생 함수를 이용하여 일련의 위치(1, ..., m - 1)를 사전에 결정 \n\n  - 원래 위치에서 \\(r_i\\)를 더해 다음 위치를 결정함 \n\n  - 예) \\(m = 10: 4, 5, 7, 1, 6, 9, 8, 3, 2\\) \n\n  - 모든 키 값이 같은 일련의 위치를 사용함 \n\n- **방법 1-3. Quadratic probing: \\(p(i) = c_1 i^2 + c_2 i + c_3\\) 형태의 2차 함수를 이용하여 다음 위치를 결정함** \n\n  - 보통 많이 사용하는 것은: \\(p(i) = i^2\\) \n\n  - 예) 원래 충돌이 발생한 위치가 \\(x\\)이면 \\(x + 1, x + 4, x + 9\\) 형태로 조사하는 방식임 \n\n  - 모든 위치를 조사하지 못하는 문제가 있음",
    "source": "ds-slide10_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 22,
      "page_heading": "# Clump 해결방법",
      "images": [
        "ds-slide10/images/21_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0328"
  },
  {
    "type": "강의자료",
    "text": "# Clump 해결방법 \n\n- 랜덤 조사나 2차 함수 조사 방법 모두 같은 위치로 해상되는 키에 대해서는 항상 같은 위치를 조사함 \n\n- 이 문제를 secondary clustering라 함 \n\n- 조사 위치는 키 값에 의존하지 않고 최초 해시값에 의존하기 때문 \n\n- 따라서 이 문제를 해결하기 위해서는 조사 위치 계산에 키 값을 활용해야 함 \n\n- 방법 1-4. 이중 해상(double hashing) \n\n- 두 개의 해시함수 사용: \\(H_1, p(K, i) = i \\times H_2(K)\\) \n\n- \\(H_2(K)\\) 요구사항 \n\n- 0을 반환하지 않아야 함 (무한루프) \n\n- \\(m\\)과 서로 소이어야 함 \n\n- 방법 1. \\(m\\)을 소수로 사용 \n\n- Random hashing: \\(K\\)를 seed로 일련의 난수를 발생하여 조사 순서로 사용함\n- 문제점. 해상 비용이 고가 \n\n- 방법 2. \\(m = 2^r\\)을 사용하고, 1에서 \\(2^r\\) 사이의 홀수를 반환하도록 함 \n\n\\[H_2(K) = \\left( \\left( \\left( \\frac{K}{m} \\right) \\mod \\left( \\frac{m}{2} \\right) \\right) \\times 2 \\right) + 1\\]",
    "source": "ds-slide10_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 23,
      "page_heading": "# Clump 해결방법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0329"
  },
  {
    "type": "강의자료",
    "text": "# 충돌 처리 방법 - 닫힌 기법 \n\n- **방법 2-1. Bucket 방법 (closed addressing, open hashing)** \n\n- 하나의 해시값에 여러 요소를 유지할 수 있도록 각 슬롯에 \\(b\\)개의 버킷을 준비함 \n\n<table><tr><td></td><td></td><td></td></tr><tr><td>data</td><td>data</td><td>data</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></table>\n\n- 공간 낭비 문제도 있음 \n\n- 한 슬롯에 있는 \\(b\\)개의 버킷을 모두 사용하면 충돌 처리를 해야 함 \n\n- 별도 넘침 버킷(overflow bucket)을 사용할 수 있음 \n\n- 넘침 버킷을 사용하지 않으면 닫힌 해싱에 해당함 \n\n- 접근 비용: \\(O(b)\\), 공간복잡도: \\(O(bm)\\) \n\n- 닫힌 기법: 최초 해시값 위치에만 저장 \n\n- 열린 해싱: 추가 공간을 사용",
    "source": "ds-slide10_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 24,
      "page_heading": "# 충돌 처리 방법 - 닫힌 기법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0330"
  },
  {
    "type": "강의자료",
    "text": "# 충돌 처리 방법 – 닫힌 기법 \n\n- **방법 2-2. Separate Chaining 방법 (closed addressing, open hashing)** \n\n- **충돌이 발생할 때마다 연결구조를 이용하여 연결** \n\n![](images/24_0.jpg)\n\n \n\n- **특정 색인에 충돌이 지속적으로 발생하면 해당 색인의 연결 구조가 길어질 수 있음** \n\n- **접근 비용: \\(O(c)\\)** \n\n- \\(c\\): 가장 긴 체인의 길이 (최악의 경우: \\(O(n)\\)) \n\n- **메모리 요구사항: \\(O(m + n)\\)** \n\n- \\(n\\)개의 요소를 차수가 \\(m\\)인 해시 테이블에 저장한 경우",
    "source": "ds-slide10_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 25,
      "page_heading": "# 충돌 처리 방법 – 닫힌 기법",
      "images": [
        "ds-slide10/images/24_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0331"
  },
  {
    "type": "강의자료",
    "text": "## 엘린 방법 vs. 닫힌 방법 \n\n● 엘린 방법의 경우 충돌이 발생하면 두 가지 측면에서 성능에 나쁜 영향을 줌 \n\n● 빈 곳을 찾기 위한 비용 소요 \n\n● 닫힌 방법은 삽입 비용은 항상 상수이지만 찾는 비용은 같은 위치에 저장된 키 값의 개수에 의해 결정됨 \n\n● 다음에 충돌이 발생할 확률이 높아짐 \n\n● 닫힌 방법에서는 충돌이 다음 충돌에 영향을 주지 않음 \n\n● 닫힌 방법 중 별도 연결구조를 이용하는 방법은 메모리 사용 최적화 측면에서 다음과 같은 단점이 있음 \n\n● 연결구조 때문에 포인터 저장을 위한 공간이 추가로 필요함 \n\n● 모든 데이터가 근접하여 유지되지 않음 (캐시 성능에 영향이 있음) \n\n● 이론적으로 열린 방법은 m에 의해 저장되는 키 값의 개수가 제한되지만 닫힌 방법은 제한되지 않음",
    "source": "ds-slide10_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 26,
      "page_heading": "## 엘린 방법 vs. 닫힌 방법",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0332"
  },
  {
    "type": "강의자료",
    "text": "## 쿠쿠 해싱 \n\n- H1에서 충돌이 발생하는 키에 대해\nH2는 충돌이 발생하지 않아야 효과적임 \n\n- 두 개 해시함수 사용 \n\n- 충돌이 일어나면 원래 해당 위치에 있던 값을 다른 곳으로 이동함\n- 한 개의 해시 테이블을 사용하여 구현할 수 있지만 보통 다음과 같은 두 개의 테이블 사용 \n\nH1(K) = K % 7\nH2(K) = K % 5 \n\n![](images/26_0.jpg)\n\n \n\n- Insert(5)\n- Insert(12)\n- Insert(10)\n- Insert(3)\n- Insert(19)???? \n\n- 무한 루프 발생 가능:\n  일정 횟수 이상 반복되면 중단 후\n  해시함수 변경하거나\n  해시 테이블 용량을 변경해야 함 \n\n- open addressing vs. closed addressing \n\n- closed hashing vs open hashing \n\n- find, delete 최악 비용이 O(1)",
    "source": "ds-slide10_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 27,
      "page_heading": "## 쿠쿠 해싱",
      "images": [
        "ds-slide10/images/26_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0333"
  },
  {
    "type": "강의자료",
    "text": "# 해시 테이블의 용량 (1/3) \n\n- **space vs. time**: 용량이 클수록 충돌 발생 가능성이 낮아지지만 반대로 낭비되는 공간은 증가됨 \n\n- 해시 테이블의 크기가 \\(m\\)이고, 여기에 \\(n\\)개의 값을 저장할 때, 충돌이 발생할 확률은? \n\n- 각 입력이 특정 slot에 삽입될 확률은 모두 같다고 가정 \n\n- 이 확률은 1에서 \\(n\\)개가 모두 서로 다른 슬롯에 포함될 확률을 배면 구할 수 있음 \n\n\\[P_{n,m}(\\text{collision} \\ge 1) = 1 - 1 \\times \\left(\\frac{m-1}{m}\\right) \\times \\left(\\frac{m-2}{m}\\right) \\times \\cdots \\times \\left(\\frac{m-n+1}{m}\\right)\\]\n\n- (생일 파라독스) \\(\\sqrt{m}\\)개를 삽입하면 충돌이 발생할 확률이 50%가 됨 \n\n\\[E_{n,m}(\\# \\text{ of collision}) \\approx \\frac{n^2}{2m}\\]\n\n- 따라서 \\(m = \\frac{n^2}{2}\\)이면 기대되는 충돌이 1이 됨 \n\n- 하지만 이것은 공간을 너무 많이 사용하는 것임",
    "source": "ds-slide10_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 28,
      "page_heading": "# 해시 테이블의 용량 (1/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0334"
  },
  {
    "type": "강의자료",
    "text": "# 해시 테이블의 용량 (2/3) \n\n- **load factor = n/m** \n\n- 이 값이 증가할수록 충돌이 발생할 확률은 높고, 충돌이 많이 일어날수록 성능은 떨어질 수밖에 없음 \n\n해시 테이블\n접근 수\n(하나의 키를 저장하기\n위해 필요한 접근) \n\n![](images/28_0.jpg)\n\n \n\n접선: 선형 조사\n실선: 랜덤 조사 \n\n- **0.75 이상 되면 급격하게 성능이 떨어짐** \n\n- \\(m \\ge 1.3n\\) \n\n- **Load factor를 0.75 이하로 유지하는 것이 중요**",
    "source": "ds-slide10_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 29,
      "page_heading": "# 해시 테이블의 용량 (2/3)",
      "images": [
        "ds-slide10/images/28_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0335"
  },
  {
    "type": "강의자료",
    "text": "# 해시 데이터분석 응용 (3/3) \n\n- 선형 조사 방법의 경우 해시 테이블 용량이 뭉침 현상에 영향을 줌 \n\n  - 예) 상수 c를 더하는 선형 조사에서는 c와 m이 서로소이어야 전체 위치를 조사할 수 있음 \n\n  - 보통 a% m = b에서 a와 m이 공약수 k를 가지면 b는 k의 배수가 됨 \n\n  - 예) 입력 데이터 10, 20, 30, 40, 50일 때, m = 4이면, 2, 0, 2, 0, 0일 \n\n  - 예) 같은 데이터일 때, m = 7이면 3, 6, 2, 4, 1일 \n\n  - 예) 같은 데이터일 때, m = 5이면 0, 0, 0, 0, 0일 \n\n- 해시값과 m이 공약수를 가지면 좋지 않음 \n\n  - m을 소수로 선택하는 것도 좋은 방법임 \n\n  - 하지만 입력 데이터가 균일하게 분포되어 있다면 m의 선택은 무관함 \n\n- 가장 좋은 경우 \n\n  - 사전에 얼마나 많은 데이터를 삽입할지 알고 있으면 m ≥ 1.3n인 소수를 m으로 사용함 \n\n  - 사전에 입력되는 데이터의 분포를 알면 그것에 적합한 해시함수를 선택할 수 있음 \n\n  - 좋은 해시함수를 사용하면 입력 데이터와 무관하게 나머지 연산을 해야 하는 해시값이 균일하게 분포됨",
    "source": "ds-slide10_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 30,
      "page_heading": "# 해시 데이터분석 응용 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0336"
  },
  {
    "type": "강의자료",
    "text": "## 동적 해시 테이블 \n\n● 삼입되는 데이터가 많아짐에 따라 해시 테이블의 용량을 늘리는 기법 \n\n● 열린 기법의 경우 n/m이 일정 크기(0.75) 이상이 되거나 닫힌 기법 중 chaining의 경우 n/m 또는 c가 너무 커질 경우 해시 테이블의 용량을 늘릴 수 있음 \n\n● 보통 2배, 이때에도 소수가 되도록 할 수 있음 \n\n● 이 경우 해시함수가 변경되며, 기존 저장된 모든 요소에 새 해시함수를 적용해야 함 \n\n● 최종 나머지 연산이 바뀜 \n\n● 많은 비용이 소요됨 \n\n● 따라서 동적 해시 테이블을 사용하기보다는 삽입할 데이터의 수를 예측하여 초기에 충분히 확보하는 것이 가장 바람직함",
    "source": "ds-slide10_page_31",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 31,
      "page_heading": "## 동적 해시 테이블",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0337"
  },
  {
    "type": "강의자료",
    "text": "# 빈 상태 표시 \n\n- 연결구조: nullptr 또는 empty list \n\n- 버킷방식: ? \n\n- 정수배열: -1? \n\n- 구조체 배열 \n\nBucket:\nkey: key type\nempty: boolean type \n\n- 버킷 배열과 bool 배열 두 개 사용 \n\n- 선형조사에서 deleteFlag \n\nBucketState: enum\nEMPTY, OCCUPIED, DELETED \n\nBucket:\nkey: key type\nempty: BucketState type",
    "source": "ds-slide10_page_32",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 32,
      "page_heading": "# 빈 상태 표시",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0338"
  },
  {
    "type": "강의자료",
    "text": "## HashMap 구현과 활용 \n\n● 해시 테이블에 키와 값을 함께 저장함 \n\n● 일반 해시 테이블과 다르게 중복 키 입력은 무시하는 것이 아니라 해당 키와 연관된 값을 교체함 \n\n● 맵 구조를 사용할 때 한 키에 여러 개 값을 연결하여 사용할 수 있음 \n\n● 예) unordered_map<string, vector<string>> map",
    "source": "ds-slide10_page_33",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 33,
      "page_heading": "## HashMap 구현과 활용",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0339"
  },
  {
    "type": "강의자료",
    "text": "## multiset \n\n● 중복을 허용하는 집합 (맵 개념) \n\n○ C++: multiset(균형BST), unordered_multiset(해싱) \n\n○ 파이썬: collections의 Counter(해싱) \n\n● 예) freq = Counter(word) \n\n● 중복을 허용하기 때문에 특정 요소가 몇 개 저장되어 있는지  효율적으로 알 수 있음 \n\n● C++: count(const Key& key) \n\n● 삭제의 경우도 중복 요소를 모두 삭제하는 방법과 하나만 삭제하는 방법을 제공함 \n\n● C++: erase(iterator pos), erase(const Key& key)",
    "source": "ds-slide10_page_34",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 34,
      "page_heading": "## multiset",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0340"
  },
  {
    "type": "강의자료",
    "text": "## LinkedInHashSet, LinkedInHashMap \n\n 보통 해싱을 이용한 자료구조는 저장된 요소 간의 순서를 유지하지 않음 \n\n LinkedInHashSet, LinkedInHashMap은 저장된 요소 간의 순서를 이중 연결구조로 연결하여 유지함 \n\n 두 가지 순서 제공: 삽입된 순서, 접근 순서 \n\n 자바: LinkedInHashSet, LinkedInHashMap \n\n entrySet을 이용하여 반복하면 저장된 순서로 반복합 \n\n 파이썬3: OrderedDict \n\n 파이썬 3.7 이후부터 일반 dict도 삽입 순서를 바탕으로 반복할 수 있도록 해줌",
    "source": "ds-slide10_page_35",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 35,
      "page_heading": "## LinkedInHashSet, LinkedInHashMap",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0341"
  },
  {
    "type": "강의자료",
    "text": "## C++, Java, Python \n\nSet  C++: unordered_set, set  Java: Set, HashSet, TreeSet  Python: set  Map  C++: unordered_map, map  Java: HashMap, TreeMap  Python: dict  해시함수  C++11: <functional> 헤더에 각종 타입에 대한 hash 함수 제공  Java: Object 클래스에 hashCode 함수가 있음. 새 데이터의  경우에는 이 메소드를 재정의해야 해싱을 이용한 set과 map에서  새 데이터가 올바르게 동작함  Python: __hash__를 재정의해야 함",
    "source": "ds-slide10_page_36",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 36,
      "page_heading": "## C++, Java, Python",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0342"
  },
  {
    "type": "강의자료",
    "text": "# HashMap vs. TreeMap \n\n<table><tr><td></td><td>HashMap</td><td>TreeMap</td></tr><tr><td>구현방법</td><td>당현 기법 중 chaining 기법</td><td>Red-Black-Tree (균형 이진 트리)</td></tr><tr><td>생성</td><td>용량은 저장할 개수의 1.3배</td><td>저장할 개수가 예측이 안 되면 TreeMap의 사용이 더 유리할 수 있음</td></tr><tr><td>연산</td><td>\\(O(1)\\) 해시 비용, 충돌 처리 비용 등</td><td>\\(O(\\log n)\\) 비교 비용</td></tr><tr><td>순서</td><td>저장된 데이터 순서에 대한 정보 없음</td><td>저장된 데이터에 대한 순서 정보 있음</td></tr><tr><td>특징</td><td>용량이 부족하여 확장해야 하면 많은 비용이 소요됨</td><td></td></tr><tr><td>C++</td><td>특정 클래스 타입을 key로 사용하고자 하면 == 연산자의 재정의가 매우 중요 별도 hash function을 생성할 때 제공해야 함</td><td>특정 클래스 타입을 key로 사용하고자 하면 &lt; 연산자의 재정의가 필요 아니면 별도 비교자를 제공해야 함</td></tr><tr><td>자바</td><td>특정 클래스 타입을 key로 사용하고자 하면 hashcode, equals 메소드의 재정의가 매우 중요</td><td>특정 클래스 타입을 key로 사용하고자 하면 해당 클래스는 Comparable interface를 구현해야 함 아니면 별도 비교자를 제공해야 함</td></tr></table>",
    "source": "ds-slide10_page_37",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 37,
      "page_heading": "# HashMap vs. TreeMap",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0343"
  },
  {
    "type": "강의자료",
    "text": "std::set \n\n● 헤더 파일: <set>, <unordered_set> \n\n<table><tr><td>std::pair&lt;iterator,bool&gt; insert(const value_type&amp; value );<br/>template&lt;typename InputIt&gt; void insert(InputIt first, InputIt last);<br/>void insert(std::initializer_list&lt;value_type&gt; ilist);</td></tr><tr><td>iterator erase(const_iterator pos);<br/>iterator erase(const_iterator first, const_iterator last);<br/>size_type erase(const key_type&amp; key);</td></tr><tr><td>iterator find(const Key&amp; key);<br/>const_iterator find(const Key&amp; key) const;</td></tr><tr><td>void clear() noexcept;</td></tr><tr><td>bool empty() const noexcept;</td></tr><tr><td>size_type size() const noexcept;</td></tr><tr><td></td><td>std::unordered_set&lt;int&gt; set(13);<br/>set.insert(5);<br/>set.insert(3);<br/>set.insert(5);<br/>set.insert(2);<br/>for(auto n: set)<br/>std::cout &lt;&lt; n &lt;&lt; \", \"<br/>std::cout &lt;&lt; std::endl;</td></tr></table>",
    "source": "ds-slide10_page_38",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 38,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0344"
  },
  {
    "type": "강의자료",
    "text": "std::unordered_set \n\n● 해싱 기반이므로 값을 저장할 때 사용할 해시함수가 필요함 \n\n● <functional> 헤더에 원시타입과 문자열에 대한 해시함수가 정의되어 있음 \n\n● 원시타입과 문자열이 아닌 데이터를 저장하고 싶을 경우에는\n자료구조를 생성할 때 사용할 해시함수를 제공할 수 있음 \n\n○ 함수 호출 연산자를 다중 정의하는 구조체를 정의하여 제공할 수\n있고, 람다 표현식을 이용할 수 있음 \n\n○ 해시함수의 반환 타입은 size_t이어야 함 \n\n● 해시함수뿐만 아니라 해시함수와 호환되는 == 연산자도 다중 정의해\n주어야 함 \n\n○ x == y가 true이면 hash(x) == hash(y)도 true이어야 함 \n\n○ 충돌이 발생하였을 때 실제 저장된 값이 맞는지 확인하기 위해 필요",
    "source": "ds-slide10_page_39",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 39,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0345"
  },
  {
    "type": "강의자료",
    "text": "## std::unordered_set \n\n● 구조체나 클래스의 모든 멤버 변수를 이용하여 해시값을 계산하는 해시함수를 만들고 싶을 경우 \n\n● 방법 1. 각 멤버 변수의 해시값을 계산한 후에 이를 이용하여 최종 해시값 계산 \n\n● 방법 2. 각 멤버 변수를 모두 문자열로 변환한 후에 결합한 다음 이 문자열에 대한 해시값 계산 \n\nstruct Student{  std::string name;  std::string number;  int year;  bool operator==(const Student& other) const noexcept{  return name==other.name&&  number==other.number&&year==other.year;  }  };",
    "source": "ds-slide10_page_40",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 40,
      "page_heading": "## std::unordered_set",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0346"
  },
  {
    "type": "강의자료",
    "text": "std::unordered_set \n\nstruct IHash{\n    std::size_t operator()(const Student& s) const noexcept{\n        std::vector<sizet> vals;\n        vals.push_back(std::hash<std::string>0(s.name));\n        vals.push_back(std::hash<std::string>0(s.number));\n        vals.push_back(std::hash<int>0(s.year));\n        size_t hashval{0};\n        for(auto n: vals) hashval = hashval*31 + n;\n        return hashval;\n    }\n}; \n\nstruct SHash{\n    std::size_t operator()(const Student& s) const noexcept{\n        std::stringstream buf;\n        buf << s.name << s.number << s.year;\n        return std::hash<std::string>0(buf.str());\n    }\n};",
    "source": "ds-slide10_page_41",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 41,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0347"
  },
  {
    "type": "강의자료",
    "text": "# LeetCode 202. Happy Number  \n\nWrite an algorithm to determine if a number is \"happy\".  \n\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.  \n\n## Example:  \n\nInput: 19  Output: true  Explanation:  1^2 + 9^2 = 82  8^2 + 2^2 = 68  6^2 + 8^2 = 100  1^2 + 0^2 + 0^2 = 1",
    "source": "ds-slide10_page_42",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 42,
      "page_heading": "# LeetCode 202. Happy Number",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0348"
  },
  {
    "type": "강의자료",
    "text": "std::map \n\n● 헤더 파일: <map>, <unordered_map> \n\n<table><tr><td>std::pair&lt;iterator,bool&gt; insert(const value_type&amp; value );<br/>template&lt;typename InputIt&gt; void insert( InputIt first, InputIt last );<br/>void insert(std::initializer_list&lt;value_type&gt; list);</td></tr><tr><td>T&amp; operator[](const Key&amp; key);</td></tr><tr><td>iterator erase(const iterator pos);<br/>iterator erase(const iterator first, const_iterator last );<br/>size_type erase(const key_type&amp; key);</td></tr><tr><td>iterator find(const Key&amp; key);<br/>const_iterator find(const Key&amp; key) const;</td></tr><tr><td>void clear() noexcept;</td></tr><tr><td>bool empty() const noexcept;</td></tr><tr><td>size_type size() const noexcept;</td></tr></table>\n\nstd::unordered_map&lt;std::string, int&gt; map(13);\nmap.insert(std::make_pair(\"apple\",3));\nmap[\"grape\"] = 5;\nmap.insert(std::make_pair(\"banana\",4));\nmap[\"apple\"] = 2;\nmap.insert(std::make_pair(\"banana\",1));\nauto loc = map.find(\"apple\"); // banana\nif(loc!=map.cend()) {\n    std::cout << loc->second << std::endl;\n}",
    "source": "ds-slide10_page_43",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 43,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0349"
  },
  {
    "type": "강의자료",
    "text": "# LeetCode 205. Isomorphic Strings  \n\nGiven two strings \\(s\\) and \\(t\\) , determine if they are isomorphic.  \n\nTwo strings are isomorphic if the characters in \\(s\\) can be replaced to get \\(t\\) .  \n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.  \n\n## Example 1:  \n\nInput: \\(s = \"egg\", t = \"add\"\\) Output: true  \n\n## Example 2:  \n\nInput: \\(s = \"foo\", t = \"bar\"\\) Output: false  \n\n## Example 3:  \n\nInput: \\(s = \"paper\", t = \"title\"\\) Output: true  \n\n## Note:  \n\nYou may assume both \\(s\\) and \\(t\\) have the same length.",
    "source": "ds-slide10_page_44",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 44,
      "page_heading": "# LeetCode 205. Isomorphic Strings",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0350"
  },
  {
    "type": "강의자료",
    "text": "# Java \n\n- java.util.Set<T> \n\n- 구현: HashSet, EnumSet, TreeSet \n\nimport java.util.HashSet; \n\npublic class Test {\n    public static void main(String[] args) {\n    Set<Integer> s = new HashSet<Integer>(13);\n    s.add(5);\n    s.add(3);\n    s.add(7);\n    s.add(5);\n    System.out.println(s.size());\n    System.out.println(s.contains(5));\n    s.remove(3);\n    System.out.println(s.size());\n    }\n} \n\n- 해싱 기반의 경우 삽입하는 데이터의\n  hashCode, equals의 재정의가 매우 중요\n- TreeSet의 경우 삽입하는 데이터는\n  Comparable을 구현하고 있거나\n  데이터를 삽입할 때 사용할 비교 함수를\n  제공해야 함",
    "source": "ds-slide10_page_45",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 45,
      "page_heading": "# Java",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0351"
  },
  {
    "type": "강의자료",
    "text": "Java \n\n- 자바는 Object에 정의되어 있는 hashCode를 이용하여 해싱이 필요한 자료구조의 해시값을 계산함 \n\n- 새 클래스의 hashCode의 재정의는 Objects의 hashCode 이용함 \n\n- 멤버 변수가 a, b, c, d, e 다섯 개가 있는 경우 \n\npublic int hashCode(){\n    return Objects.hash(a, b, c, d, Arrays.hashCode(e));\n} \n\n여기서 a, b, c, d는 원시타입, 객체타입\ne는 배열 타입",
    "source": "ds-slide10_page_46",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 46,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0352"
  },
  {
    "type": "강의자료",
    "text": "Java \n\n- java.util.Map<K,T> \n\n- 구현: HashMap, EnumMap, TreeMap \n\nimport java.util.Map;\nimport java.util.HashMap; \n\npublic class Test {\n    public static void main(String[] args) {\n    Map<String, Integer> animals = new HashMap<>();\n    animals.put(\"zebra\", 5);\n    animals.put(\"lion\", 3);\n    animals.put(\"tiger\", 7);\n    System.out.println(animals.get(\"zebra\"));\n    animals.put(\"zebra\", 8);\n    System.out.println(animals.get(\"zebra\"));\n    animals.remove(\"lion\");\n    animals.replace(\"lion\", 6); // key가 존재할 경우에만\n    System.out.println(animals.get(\"lion\"));\n    }\n}",
    "source": "ds-slide10_page_47",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 47,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0353"
  },
  {
    "type": "강의자료",
    "text": "## Python3 \n\n 언어자체에집합과맵자료구조를제공함   집합: set(), 맵: dict(), {}   파이썬의 set()과 dict()은모두해싱을이용하는자료구조   둘다해싱을이용하지만초기용량을지정할수없음   set()의연산   in 연산자, add, update, remove, clear   집합간연산: | (합집합), & (교집합), - (차집합),  비교연산자를이용하여부분집합여부검사가능   파이썬의 dict()은 C++처럼색인연산자를이용하여주로처리함   items, keys, values를통해저장된값의집합을얻을수있음   색인연산자대신에 get(key, default=None)을사용할수있음   여기서 default는 key가맵에없을때반환하는값   삭제는 pop(key, default=None), popitem, del 사용가능   defaultdict을이용하여없는키를접근할때기본값을얻을수있음",
    "source": "ds-slide10_page_48",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 48,
      "page_heading": "## Python3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0354"
  },
  {
    "type": "강의자료",
    "text": "# Python3 \n\n- 사용자 정의 클래스를 위한 해시함수는 __hash__ dunder 메소드를 재정의하면 됨 \n\n- C++에서 제시한 방법처럼 재정의해 주면 됨 \n\n- __eq__ dunder도 올바르게 재정의해 주어야 함 \n\ndef __hash__(self): \n\nvals = [] \n\nvals.append(hash(self.name)); \n\nvals.append(hash(self.number)); \n\nvals.append(hash(self.year)); \n\nhashval = 0 \n\nfor n in vals: \n\nhashval = hashval*31 + n \n\nreturn hashval \n\n- 내장되어 있는 hash 함수 immutable\n- 파이썬 객체에 대해서만 동작함",
    "source": "ds-slide10_page_49",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 49,
      "page_heading": "# Python3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0355"
  },
  {
    "type": "강의자료",
    "text": "# Bloom Filters (1/4) \n\n- 악성 사이트 목록이 주어져 있을 때, 이를 이용하여 악성 사이트 필터를 만들어야 함 \n\n<table><tr><td>방법</td><td>공간복잡도</td><td>시간복잡도</td></tr><tr><td>리스트</td><td>\\(O(n)\\)</td><td>\\(O(n)\\)</td></tr><tr><td>균형이진검색트리</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)</td></tr><tr><td>해시테이블</td><td>\\(\\ge O(n)\\)</td><td>\\(O(1)\\)</td></tr></table>\n\n- 볼룸 필터(bloom filter)는 이와 같은 문제를 해시 테이블과 마찬가지로 \\(O(1)\\)의 시간복잡도를 제공해주지만 상대적으로 매우 적은 공간을 사용할 수 있도록 해줌 \n\n- 단, 거짓 양성 결과를 줄 수 있음",
    "source": "ds-slide10_page_50",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 50,
      "page_heading": "# Bloom Filters (1/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0356"
  },
  {
    "type": "강의자료",
    "text": "## Bloom Filters (2/4) \n\n● 블룸 필터는 해시 테이블과 마찬가지로 빠른 검색(𝑂(1))을 제공함 \n\n● 해시 테이블과 차이점 \n\n○ 장점 \n\n● 항상 𝑂(1)에 검색할 수 있음 \n\n● 상대적으로 매우 적은 공간을 사용함 \n\n○ 단점 \n\n● 검색 결과의 거짓 양성(false positive) 오류 가능 \n\n● 거짓 음성(false negative)은 절대 일어나지 않음 \n\n● 삽입되지 않은 것도 있다고 할 수 있지만 삽입된 것을 없다고 하는 경우는 발생하지 않음 \n\n● 이 때문에 확률적 자료구조라 함 \n\n● 데이터 자체를 저장하는 구조가 아님 \n\n● 삭제 연산이 복잡함 (보통 제공하지 않음) \n\n● 필요하면 다시 필터를 만드는 방법으로 제공 가능",
    "source": "ds-slide10_page_51",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 51,
      "page_heading": "## Bloom Filters (2/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0357"
  },
  {
    "type": "강의자료",
    "text": "# Bloom Filters (3/4) \n\n- \\(n\\) 비트 크기의 비트 배열 \\(A\\) 사용 \n\n- \\(m\\) 개의 해시 함수 사용: \\(h_1, h_2, ..., h_m\\) \n\n- \\(k \\in S\\)의 삽입 \n\n\\[ \\text{for } i := 1 \\text{ to } m \\text{ do} \\\\ A[h_i(k)] := 1 \\]\n\n- \\(k \\in S\\)의 검색 \n\n\\[ \\begin{aligned} \\text{for } i := 1 \\text{ to } m \\text{ do} \\\\ \\text{if } A[h_i(k)] == 0 \\text{ then return false} \\\\ \\text{return true} \\end{aligned} \\]\n\n- 이 방식이기 때문에 거짓 양성 오류가 발생할 수 있음",
    "source": "ds-slide10_page_52",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 52,
      "page_heading": "# Bloom Filters (3/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0358"
  },
  {
    "type": "강의자료",
    "text": "# Bloom Filters (4/4) \n\n- **블룸 필터의 배열 크기가 \\(n\\)이고 \\(s\\)개 입력하였을 때, 거짓 양성 확률 \\(\\epsilon\\)을 구할 수 있음** \n\n- **이 확률이 최소화되기 위한 해시함수의 수 \\(m\\)을 구할 수 있음** \n\n\\[\n\\bullet m = -\\log \\epsilon\n\\]\n\n- **이를 바탕으로 블룸 필터를 만드는 절차** \n\n- **블룸 필터에 삽입할 요소의 개수 \\(s\\)를 추측** \n\n- **잘 모르면 충분히 큰 크기로 예측할 수 있음** \n\n- **원하는 거짓 양성 확률 \\(\\epsilon\\)을 정함** \n\n- **그다음 \\(m = -\\log \\epsilon\\)을 이용하여 \\(m\\)을 계산함** \n\n- \\(\\epsilon = 0.02\\)이면 \\(m\\)은 5 또는 6이어야 함 \n\n- **마지막으로 배열의 크기 \\(n\\)을 결정** \n\n\\[\n\\bullet n(\\approx -\\frac{s(\\ln \\epsilon)}{0.48}) \\approx 8s)\n\\]",
    "source": "ds-slide10_page_53",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 53,
      "page_heading": "# Bloom Filters (4/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0359"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide10_page_54",
    "meta_data": {
      "tables": [],
      "lecture_title": "Set, Map, Hashing",
      "page_no": 54,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0360"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n## 우선순위 큐 \n\nNOTE 11 \n\n한국기술교육대학교 컴퓨터공학부 김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide11_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 1,
      "page_heading": "## 우선순위 큐",
      "images": [
        "ds-slide11/images/0_0.jpg",
        "ds-slide11/images/0_1.jpg",
        "ds-slide11/images/0_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0361"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 우선순위 큐 ● 이진 힙 ● C++, 자바, Python 라이브러리 \n\n![](images/1_0.jpg)\n\n우선순위 큐: 응급실에서 치료 순서 \n\n![](images/1_1.jpg)",
    "source": "ds-slide11_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [
        "ds-slide11/images/1_0.jpg",
        "ds-slide11/images/1_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0362"
  },
  {
    "type": "강의자료",
    "text": "## 우선순위 큐 \n\n● 일반 큐는 FIFO 방식이지만 우선순위 큐는 각 데이터마다 우선순위가 있어 추출이 추가된 순서와 무관함 \n\n● 우선순위 큐의 연산 \n\n○ add: 큐에 데이터 추가 \n\n○ extract: 가장 우선순위가 높은 데이터 추출 \n\n○ get: 가장 우선순위가 높은 데이터 열람 \n\n○ remove: 특정 데이터 제거 \n\n○ changePriority: 특정 데이터의 우선순위 변경 \n\n● add, extract, get이 기본 연산이며, remove, changePriority는 제공하지 않을 수 있음 \n\n● 보통 우선순위를 계산하는 방법을 큐를 생성할 때 제공할 수 있음",
    "source": "ds-slide11_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 3,
      "page_heading": "## 우선순위 큐",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0363"
  },
  {
    "type": "강의자료",
    "text": "# 우선순위가 단순한 경우 \n\n- 예) 우선순위가 상, 중, 하 3개로만 분류되면 \n\n  - 여러 개의 FIFO 큐로 구현 \n\n- 예) 우선순위가 복잡한 경우: 정수로 표현되면",
    "source": "ds-slide11_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 4,
      "page_heading": "# 우선순위가 단순한 경우",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0364"
  },
  {
    "type": "강의자료",
    "text": "# 기존 자료구조를 이용한 구현 (1/2) \n\n- 비정렬 연결구조 / 비정렬 배열 리스트 \n\n  - add: O(1), extract: O(n) \n\n- 정렬 배열 리스트 \n\n  - add: O(n), 삽입 위치는 이진 검색할 수 있지만 삽입하는 비용은 선형 비용 \n\n  - extract: O(1): how? (우선순위가 높은 것을 어디에?) \n\n- 정렬 연결구조 \n\n  - add: O(n) \n\n  - extract: O(1) \n\n- n번 add, √n번 추출: 위 3가지 중 어느 방법이 가장 효과적인가? \n\n\\[n + n\\sqrt{n}, n^2 + \\sqrt{n}, n^2 + \\sqrt{n}\\]",
    "source": "ds-slide11_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 5,
      "page_heading": "# 기존 자료구조를 이용한 구현 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0365"
  },
  {
    "type": "강의자료",
    "text": "# 기존 자료구조를 이용한 구현 (2/2) \n\n- 이진 검색 트리 \n\n  - 최댓값, 최솟값의 위치 \n\n  - 예) 최댓값: 루트에서 계속 오른쪽 \n\n  - 최댓값 추출 비용은 트리 높이에 비례 \n\n  - 균형 트리가 아니면 \\(O(\\log n)\\)이 보장되지 않음 \n\n- 균형 이진 검색 트리 \n\n  - 삽입, 추출을 \\(O(\\log n)\\)에 할 수 있음 \n\n  - 가장 큰 값 또는 가장 작은 값에 대한 포인터를 별도 유지하여 성능을 향상할 수 있음 \n\n- 더 효과적인 방법은 없을까?",
    "source": "ds-slide11_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 6,
      "page_heading": "# 기존 자료구조를 이용한 구현 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0366"
  },
  {
    "type": "강의자료",
    "text": "## 이진 힘 \n\n● 이진 힘: 부모 값이 자식 값보다 같거나 항상 큰 이진 트리 \n\n get: 항상 루트 값이 가장 큼 \n\n 큰 값이 우선순위가 높은 힘을 MaxHeap라 함 \n\n● 같은 방법으로 MinHeap도 만들 수 있음 \n\n 힘은 max와 min을 동시에 제공할 수 없음 \n\n● 값의 중복도 지원함 \n\n 중복 중 추출되는 것은 임의로 결정함 \n\n 이진 검색 트리와 차이점 \n\n![](images/6_0.jpg)",
    "source": "ds-slide11_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 7,
      "page_heading": "## 이진 힘",
      "images": [
        "ds-slide11/images/6_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0367"
  },
  {
    "type": "강의자료",
    "text": "## insert \n\n![](images/7_0.jpg)\n\n 단계 1. 단말로 노드 추가  단계 2. reheap up 과정을 통해 이진 힙 구조 복원 \n\n reheap up 대신에 bubble up, sift up 등 다양한 용어로 표현됨 \n\n 최대 하나의 연결만 규칙 위배  비용은 트리 높이: O(log n) 트리가 균형이어야 함 \n\n 단말 위치에 대한 빠른 접근 필요  부모 노드를 쉽게 접근할 수 있어야 함",
    "source": "ds-slide11_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 8,
      "page_heading": "## insert",
      "images": [
        "ds-slide11/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0368"
  },
  {
    "type": "강의자료",
    "text": "## extract \n\n![](images/8_0.jpg)\n\n 단계 1. 루트 노드를 임의의 단말 노드와 교체  단계 2. 단말 제거 (부모 링크 필요)  단계 3. reheap down 과정을 통해 이진 힙 특성 복원 \n\n 처음을 제외하고 최대 하나의 연결만 규칙 위배  자식 노드 중 큰 값과 교체  비용은 트리 높이: O(log n) 균형 트리이어야 함 \n\n 단말 위치에 대한 빠른 접근 필요  부모 노드를 쉽게 접근할 수 있어야 함",
    "source": "ds-slide11_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 9,
      "page_heading": "## extract",
      "images": [
        "ds-slide11/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0369"
  },
  {
    "type": "강의자료",
    "text": "## 나머지 연산 \n\n● changePriority: 값 변경 후 reheap down 또는 up ● 변경할 데이터의 위치를 알면 O(log n)에 변경할 수 있음 ● 위치를 어떻게 효과적으로 알 수 있을까? \n\n● remove \n\n● 방법 1. 단말과 값을 교체 후, 단말은 삭제, 노드는 reheap down \n\n● 실제 heap은 마지막 단말과 교체 \n\n● 방법 2. changePriority를 통해 max 값으로 변경, extractMax \n\n● 두 방법 모두 제거할 데이터의 위치를 알아야 함 \n\n● heapify: 기존 데이터를 이용하여 힙 구성 (buildheap) \n\n● 빈 이진 힙에 insert하여 구성 가능: O(n log n) \n\n● 더 효과적인 방법도 있음",
    "source": "ds-slide11_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 10,
      "page_heading": "## 나머지 연산",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0370"
  },
  {
    "type": "강의자료",
    "text": "## 이진 힘 구현 방법 (1/2) \n\n● 힘을 구현할 때  ● 트리의 단말노드를 쉽게 접근할 수 있어야 함  ● 노드에서 부모 노드를 접근할 수 있어야 함  ● 연결구조를 이용하여 구현하면 노드에 부모 링크 유지 필요  ● 트리의 균형이 유지되어야 함  ● 힘은 부모와 자식 간의 제약만 존재함  ● 이진 검색 트리는 왼쪽과 오른쪽에 올 수 있는 값에 제약이 있음  ● 이 때문에 힘은 완전 이진 트리 형태로 데이터를 유지할 수 있음  ● 항상 트리를 완전 이진 트리 형태로 유지할 수 있으면 노드를  포인터로 연결하는 형태가 아니라 배열로 표현할 수 있음",
    "source": "ds-slide11_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 11,
      "page_heading": "## 이진 힘 구현 방법 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0371"
  },
  {
    "type": "강의자료",
    "text": "## 이진 힘 구현 방법 (2/2) \n\n● 배열로 완전 이진 트리를 표현할 때 장점 \n\n● 부모와 자식에 대한 연결을 명백하게 유지하지 않아도 됨 \n\n● 노드가 저장되어 있는 배열의 색인을 이용하여 부모와 \n\n자식 노드가 저장되어 있는 배열의 색인을 계산할 수 있음 \n\n● 완전 이진 트리이므로 마지막 색인에 있는 노드는 항상 단말임 \n\n● 배열에 첫 번째 색인에 위치한 노드가 루트 노드가 되며, 여기에 가장 작은 값 또는 가장 큰 값이 유지됨 \n\n● 트리의 높이는 최적임 \n\n● 배열로 완전 이진 트리를 표현할 때 단점 \n\n● 동적 배열 기능 구현 필요 → 초기 용량 확보 중요",
    "source": "ds-slide11_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 12,
      "page_heading": "## 이진 힘 구현 방법 (2/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0372"
  },
  {
    "type": "강의자료",
    "text": "# Complete Binary Tree \n\n- 완전 이진 트리는 배열로 표현 가능 \n\n\\[ \\bullet parent(i) = (i - 1)/2 \\]\n\n\\[ \\bullet left(i) = 2i + 1 \\]\n\n\\[ \\bullet right(i) = 2i + 2 \\Rightarrow left(i) + 1 \\]\n\n- 완전 이진 트리이므로 트리의 높이는 항상 \\(O(\\log n)\\)임 \n\n- 주어진 노드를 가지고 이보다 더 높이를 축소할 수 없음 \n\n![](images/12_0.jpg)\n\n \n\n**완전 이진 트리 (complete binary tree):**\n마지막 레벨을 제외하면 모두 채워져 있고,\n최하위 레벨의 단말 노드들은 왼쪽에서부터\n채워진 형태로 되어 있는 경우",
    "source": "ds-slide11_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 13,
      "page_heading": "# Complete Binary Tree",
      "images": [
        "ds-slide11/images/12_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0373"
  },
  {
    "type": "강의자료",
    "text": "![](images/13_0.jpg)\n\n \n\n<table><tr><td>0</td><td>16</td></tr><tr><td>1</td><td>12</td></tr><tr><td>2</td><td>14</td></tr><tr><td>3</td><td>5</td></tr><tr><td>4</td><td>6</td></tr><tr><td>5</td><td>11</td></tr><tr><td>6</td><td>7</td></tr><tr><td>7</td><td>2</td></tr><tr><td>8</td><td>3</td></tr></table>\n\n부모의 위치: (index-1)/2\n원쪽 자식의 위치: (index*2)+1\n오른쪽 자식의 위치: (index*2)+2",
    "source": "ds-slide11_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 14,
      "page_heading": "",
      "images": [
        "ds-slide11/images/13_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0374"
  },
  {
    "type": "강의자료",
    "text": "insert와 reheapUp \n\n![](images/14_0.jpg)\n\n \n\n단계 1. 배열에 맨 끝에 추가\n단계 2. reheap up 과정 진행\n단계 2-1. 부모노드와 비교\n단계 2-1-1. 부모노드보다 크면 교환\n단계 2-1-2. 작으면 과정 종료\n단계 2-2. 루트노드가 될 때까지 단계 2-1 반복",
    "source": "ds-slide11_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 15,
      "page_heading": "",
      "images": [
        "ds-slide11/images/14_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0375"
  },
  {
    "type": "강의자료",
    "text": "add(item): if numItems==capacity then increaseCapacity() heap[numItems] := item reheapUp(numItems) ++numItems \n\nreheapup(index): while index>0 do parentIdx := (index-1)/2 if heap[parentIdx] < heap[index] then swap(heap[parentIdx], heap[index]) else return index := parentIndex",
    "source": "ds-slide11_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 16,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0376"
  },
  {
    "type": "강의자료",
    "text": "extract와 reheapDown \n\n![](images/16_0.jpg)\n\n \n\n단계 1. 루트와 마지막 노드와 교환 \n\n단계 2. reheap down 과정 진행 \n\n단계 2-1. 자식이 없으면 종료 \n\n단계 2-2. 자식이 하나면 해당 노드와 비교 \n\n단계 2-3. 자식이 둘이면 둘 중 큰 노드와 비교 \n\n단계 2-1-1. 자식노드보다 작으면 교환 \n\n단계 2-1-2. 크면 과정 종료 \n\n단계 2-4. 루트노드가 될 때까지 단계 2-1 반복",
    "source": "ds-slide11_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 17,
      "page_heading": "",
      "images": [
        "ds-slide11/images/16_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0377"
  },
  {
    "type": "강의자료",
    "text": "extract(item): if isEmpty() then throw IllegalArgumentException ret := heap[0] swap(heap[0], heap[numItems-1]) --numItems reheapdown(0) return ret \n\nreheapdown(index): while index<numItems do leftIdx := 2*index + 1 rightIdx := leftIdx + 1 if leftIdx >= numItems then return maxChildIdx := leftIdx if rightIdx < numItems and heap[leftIdx] < heap[rightIdx] then maxChildIdx := rightIdx if heap[maxChildIdx]>heap[index] then swap(heap[maxChildIdx], heap[index]) else return index := maxChildIdx",
    "source": "ds-slide11_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 18,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0378"
  },
  {
    "type": "강의자료",
    "text": "remove \n\n● 힙에서 삭제는 보통 extract를 의미함 \n\n● 하지만 임의의 값을 삭제하고자 하면 그 값이 있는 위치를 찾아야 함 \n\n○ 별도 정보가 없으면 트리 탐색(배열 선형 검색)이므로 비용이 o(n)임 \n\n● 임의의 값을 효과적으로 삭제하고자 하면 값과 값의 위치를 매핑하여 주는 맵을 유지해야 함 \n\n○ 이 맵은 reheapUp, reheapDown 될 때마다 갱신되어야 함 \n\n○ 이 때문에 보통 remove 연산을 제공하지 않음",
    "source": "ds-slide11_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 19,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0379"
  },
  {
    "type": "강의자료",
    "text": "# 이진 힘 vs. 균형 이진 트리 \n\n<table><tr><td></td><td>이진 힘</td><td>균형 이진 트리</td></tr><tr><td>내부 구현</td><td>배열<br/>(캐싱에 유리: 연속 공간 사용)<br/>(동적 배열 기법 필요)</td><td>포인터를 이용한 연결구조 형태</td></tr><tr><td>트리 높이</td><td>완전 이진 트리 (최적)</td><td></td></tr><tr><td>우선순위 큐 생성 비용</td><td>\\(O(n) - 슬라이드 20\\)</td><td>\\(O(n \\log n)\\)</td></tr><tr><td>데이터 검색</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)<br/>next, prev</td></tr><tr><td>추출비용</td><td>\\(O(\\log n)\\)<br/>reheap down</td><td>\\(O(\\log n)\\), \\(O(1)\\)<br/>루트까지 올라가면서 회전 (remove<br/>연산)</td></tr><tr><td>삽입비용</td><td>\\(O(\\log n)\\)<br/>reheap up</td><td>\\(O(\\log n)\\)<br/>삽입 후 루트까지 올라가면서 회전<br/>(add 연산)</td></tr><tr><td>삭제비용</td><td>\\(O(n)\\) (보통 제공하지 않음)</td><td>\\(O(\\log n)\\)</td></tr><tr><td>추가특징</td><td></td><td>중복요소 문제</td></tr></table>",
    "source": "ds-slide11_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 20,
      "page_heading": "# 이진 힘 vs. 균형 이진 트리",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0380"
  },
  {
    "type": "강의자료",
    "text": "## HeapSort \n\n● 선택 정렬(selection sort): 정렬이 안 되어 있는 원소 중 가장 작은 원소를 찾아 그것의 위치로 이동하여 정렬하는 방법 \n\n○ 시간 복잡도: 𝑂(𝑛²) \n\n○ 문제 해결이 반복적으로 최솟값 또는 최댓값을 찾아야 하면 우선순위 큐(힙)을 적용하여 개선할 수 있는 가장 적합한 문제임 \n\n● Heap을 이용하여 선택 정렬의 개선 \n\n○ 직관적 방법 \n\n● 단계 1. 힙에 정렬할 모든 요소를 삽입 \n\n● 단계 2. ExtractMax를 하여 배열 맨 끝에 추가 \n\n○ 직관적 방법의 복잡성은? 𝑂(𝑛𝑙𝑜𝑔𝑛) \n\n● 힙에 요소를 삽입하는 비용과 ExtractMax는 각각 logn임 \n\n● 공간복잡도: 추가 공간 사용 \n\n○ 이 방법을 개선? 기존 배열을 그대로 이용. 어떻게? \n\n● 기존 배열을 heap 특성을 만족하도록 변경해야 함. 어떻게?",
    "source": "ds-slide11_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 21,
      "page_heading": "## HeapSort",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0381"
  },
  {
    "type": "강의자료",
    "text": "# heapify \n\n![](images/21_0.jpg)\n\n \n\n- 반복적으로 힙 특성을 만족하도록 값들의 위치 변경\n- 어디서부터? 자식이 있는 노드부터\n- 자식이 있는 첫 번째 노드는? 마지막 노드의 부모 노드\n- 내림차순이면 minheap, 오름차순이면 maxheap \n\n![](images/21_1.jpg)",
    "source": "ds-slide11_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 22,
      "page_heading": "# heapify",
      "images": [
        "ds-slide11/images/21_0.jpg",
        "ds-slide11/images/21_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0382"
  },
  {
    "type": "강의자료",
    "text": "# heapify의 시간복잡도 \n\n- 대략적 분석: \\(\\frac{n}{2}\\)개에 대한 `reheapDown` 수행 → \\(O(n \\log n)\\) \n\n- 실제 수행되는 연산의 수 \n\n<table><tr><td>노드의 수</td><td>reheapDown 비용</td></tr><tr><td>1</td><td>\\(log n\\)</td></tr><tr><td>2</td><td>\\(log n - 1\\)</td></tr><tr><td></td><td></td></tr><tr><td>\\(\\leq n/4\\)</td><td>2</td></tr><tr><td>\\(\\leq n/2\\)</td><td>1</td></tr></table>\n\n- 전체 비용 \\(\\leq \\frac{n}{2} \\cdot 1 + \\frac{n}{4} \\cdot 2 + \\frac{n}{8} \\cdot 3 + \\dots \\leq n \\sum_{i=1}^{h} \\frac{i}{2^i} \\leq n \\sum_{i=0}^{\\infty} ix^i = 2n\\)",
    "source": "ds-slide11_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 23,
      "page_heading": "# heapify의 시간복잡도",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0383"
  },
  {
    "type": "강의자료",
    "text": "# 이진 힙 vs. 정렬 \n\n- 주어진 데이터를 특정 기준에 따라 차례로 하나씩 차례해야 하는 경우 \n\n  - 방법 1. 배열에 데이터 삽입 후, 정렬하여 처리함 \n\n  - 방법 2. 우선순위 큐에 삽입한 후, 하나씩 추출하여 처리함 \n\n- 방법 1. vs. 방법 2 \n\n<table><tr><td></td><td>방법 1</td><td>방법 2</td></tr><tr><td rowspan=\"2\">시간복잡도</td><td rowspan=\"2\">삽입 비용: \\(O(n)\\) ||n번의 pushback<br/>정렬 비용: \\(O(n \\log n)\\)<br/>접근 비용: \\(O(n)\\) ||n번의 색인 연산</td><td>2-1.<br/>삽입 비용: \\(O(n \\log n)\\)<br/>추출 비용: \\(O(n \\log n)\\)</td></tr><tr><td>2-2.<br/>삽입 후 heapify 비용: \\(O(n)\\)<br/>추출 비용: \\(O(n \\log n)\\)</td></tr><tr><td rowspan=\"2\">공간복잡도</td><td rowspan=\"2\">\\(O(n)\\)</td><td>2.1. 배열+힙</td></tr><tr><td>2.2. 배열</td></tr></table>\n\n- 2-2. 라이브러리를 사용하지 못하고 직접 extract을 구현해야 함 (heapify는 보통 라이브러리로 제공될 수 있음) \n\n- C++는 std::make_heap, std::pop_heap 함수 지원",
    "source": "ds-slide11_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 24,
      "page_heading": "# 이진 힙 vs. 정렬",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0384"
  },
  {
    "type": "강의자료",
    "text": "## Heap 응용 (1/3) \n\n● 문제. 일련의 정수가 주어진. 정수가 하나씩 주어질 때마다 중간값을 알고 싶음 \n\n● 예) 1 → [1] → 1, 5 → [1, 5] → 1, 5, 3 → [1, 3, 5] → 3, 7 → [1, 3, 5, 7] → 3, 5, 9 → [1, 3, 5, 7, 9] → 5 \n\n● 배열 기반 비정렬 리스트 이용 \n\n○ 삽입 비용: O(1) \n\n○ 중간값 찾기 \n\n● 방법 1. 정렬한 후 찾기: O(nlog n) \n\n● 방법 2. 선택 문제 이용: O(n) \n\n● 배열 기반 정렬 리스트 이용 \n\n○ 삽입 비용: O(n) \n\n○ 중간값 찾기: O(1) \n\n● 이것을 힘을 사용하여 어떻게 개선?",
    "source": "ds-slide11_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 25,
      "page_heading": "## Heap 응용 (1/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0385"
  },
  {
    "type": "강의자료",
    "text": "## Heap 응용 (2/3) \n\n● 두 개의 힙 사용: 하나는 maxheap, 다른 하나는 minheap \n\n● n개 요소를 만나면 그 중 가장 작은 n/2개는 maxheap에 나머지 반은 minheap에 저장하면 중앙값을 항상 상수 시간을 찾을 수 있음 \n\n● Rule 1. maxheap의 가장 큰 값보다 작으면 maxheap에 삽입 \n\n● Rule 2. rule 1에 해당하지 않으면 minheap에 삽입 \n\n● Rule 3. rule 1과 2를 적용하였을 때 두 힙의 크기 차이가 2가 되면 최댓값 또는 최솟값을 다른 힙으로 이동함",
    "source": "ds-slide11_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 26,
      "page_heading": "## Heap 응용 (2/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0386"
  },
  {
    "type": "강의자료",
    "text": "## Heap 응용 (3/3) \n\n● 이) 3, 5, 4, 2, 7, 9, 6  ○ 3: maxheap [3], minheap [] → 3 (rule 1)  ○ 5: maxheap [3], minheap [5] → 3, 5 (rule 2)  ○ 4: maxheap [3], minheap [4, 5] → 4 (rule 2)  ○ 2: maxheap [3, 2], minheap [4, 5] → 3, 4 (rule 1)  ○ 7: maxheap [3, 2], minheap [4, 5, 7] → 4 (rule 2)  ○ 9: maxheap [4, 3, 2], minheap [5, 7, 9] → 4, 5 (rule 3)",
    "source": "ds-slide11_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 27,
      "page_heading": "## Heap 응용 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0387"
  },
  {
    "type": "강의자료",
    "text": "C++ \n\nstd::vector<int> data{1,8,5,6,3,4,0,9,7,2} \n\nstd::priority_queue<int> q; \n\nfor(auto n : data) q.push(n); \n\nstd::cout << q.top() << '\\n'; // 9 \n\nstd::priority_queue <queue> \n\npush, pop \n\ntop \n\nstd::vector<int> data{1,8,5,6,3,4,0,9,7,2}; \n\nstd::priority_queue<int, std::vector<int>, std::greater<int>> q; \n\nfor(auto n : data) q.push(n); \n\nstd::cout << q.top() << '\\n'; // 0 \n\nstd::greater는 x>y일 때 true \n\n큰 것이 순서가 앞에 있다는 것을 의미함 \n\npriority_queue는 순서 측면에 가장 마지막에 있는 것을 가장 먼저 추출해 줌 (혼동스러운 측면이 있음) \n\n순서에 대한 정의 \n\n1) std::less, std::greater, std::less_equal, std::greater_equal 이용 \n\n2) 람다 표현식 이용 \n\n3) 삽입하는 데이터에 < 연산자 재정의 \n\n4) 새 구조체를 정의하고 operator()를 재정의하는 방법 \n\nstd::vector<int> container; \n\ncontainer.reserve(1024); \n\nstd::priority_queue<int, std::vector<int>, std::less<int>> pq(std::less<int>(), std::move(container));",
    "source": "ds-slide11_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 28,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0388"
  },
  {
    "type": "강의자료",
    "text": "Java \n\n- java.util.PriorityQueue \n\n- add, poll \n\n- peek \n\n- clear \n\nimport java.util.Queue; \n\nimport java.util.PriorityQueue; \n\npublic class Test { \n\npublic static void main(String[] args) { \n\nQueue<Integer> queue = new PriorityQueue<>(); \n\nqueue.add(5); \n\nqueue.add(3); \n\nqueue.add(9); \n\nqueue.add(2); \n\nSystem.out.println(queue.peek()); // 2 \n\nqueue.poll(); \n\nqueue.remove(5); \n\nSystem.out.println(queue.size()); \n\n} // minheap \n\nQueue<Integer> queue = new PriorityQueue<>(a,b)->Integer.compare(b,a));",
    "source": "ds-slide11_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 29,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0389"
  },
  {
    "type": "강의자료",
    "text": "# Python3 \n\n- PriorityQueue \n\n- put, get \n\n- qsize, empty, full \n\n- 동기화 기능 포함 \n\n- heapq \n\n- heappush \n\n- heappop \n\n- heapify \n\nfrom queue import PriorityQueue \n\nQ = PriorityQueue() \n\nQ.put(5) \n\nQ.put(1) \n\nQ.put(10) \n\nprint(Q.queue[0]) # peek\nprint(Q.get()) \n\nfrom heapq import heappush \n\nheap = [] \n\nheappush(heap, 'apple') \n\nheappush(heap, 'banana') \n\nprint(heap[0]) # peek \n\nprint(heappop(heap)) \n\nprint(heappop(heap)) \n\n- 기본적으로 minheap임 \n\n- 다른 기준을 이용하고 싶으면 tuple (key, value) 형태로 저장 \n\n- 이 경우 key를 기준으로 사용함. key가 정수이면 -key 형태로 저장하여 maxheap으로 사용 가능 \n\n- 복잡한 기준이 필요하면 클래스 정의 후 __lt__ 매소드로 우선순위를 정의할 수 있음\n- 여러 데이터를 삽입할 경우에는 리스트에 삽입 후 heapify하는 것이 저렴함 \n\n![](images/29_0.jpg)",
    "source": "ds-slide11_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "우선순위 큐",
      "page_no": 30,
      "page_heading": "# Python3",
      "images": [
        "ds-slide11/images/29_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0390"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n## 그래프 \n\nNOTE 12 \n\n한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide12_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 1,
      "page_heading": "## 그래프",
      "images": [
        "ds-slide12/images/0_0.jpg",
        "ds-slide12/images/0_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0391"
  },
  {
    "type": "강의자료",
    "text": "## 교육목표 \n\n● 그래프 ● 그래프의 종류 ● 분류 기준. 간선의 방향 유무, 간선의 가중치 유무 ● 트리도 그래프의 한 종류 ● 그래프 자료구조: 인접 행렬, 인접 리스트 ● 최단경로 알고리즘",
    "source": "ds-slide12_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 2,
      "page_heading": "## 교육목표",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0392"
  },
  {
    "type": "강의자료",
    "text": "## 그래프 용어 (1/4) \n\n● 그래프(graph): 공집합이 아닌 노드(node, 정점(vertex))의 집합과 이 노드들을 연결하는 간선(edge)으로 구성되는 ADT \n\n○ 수학적 정의: 그래프 G는 G = (V, E)로 정의되며, 여기서 \n\n● V: 공집합이 아닌 노드의 집합, |V| = n \n\n● E: 간선의 집합, |E| = m \n\n![](images/2_0.jpg)\n\n \n\n● 참고. 빈 그래프라는 개념도 있음 \n\n● 무방향 그래프(undirected graph): 간선의 방향성이 없는 그래프 \n\n● 방향 그래프(directed graph, digraph): 간선의 방향성이 있는 그래프 \n\n● 방향 그래프에서는 간선을 아크(arc)라고도 함 \n\n● 가중치 그래프(weighted graph): 간선에 가중치가 있는 그래프 \n\n● 비가중치 그래프(unweighted graph): 간선에 가중치가 없는 그래프 \n\n● 다중 그래프(multigraph): 두 노드를 잇는 간선이 여러 개 존재할 수 있는 그래프 \n\n● 이와 같은 간선을 병행 간선(parallel edge)이라 함 \n\n![](images/2_1.jpg)",
    "source": "ds-slide12_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 3,
      "page_heading": "## 그래프 용어 (1/4)",
      "images": [
        "ds-slide12/images/2_0.jpg",
        "ds-slide12/images/2_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0393"
  },
  {
    "type": "강의자료",
    "text": "# 그래프 용어 (2/4) \n\n- **인접 노드(adjacent vertex):** 간선에 의해 연결되어 있는 노드 \n\n  - 다른 말로 이웃 노드 \n\n  - 무방향 그래프: 간선 \\((a, b)\\)가 있으면 \\(a\\)와 \\(b\\)는 서로 인접 노드임 \n\n  - 방향 그래프: 간선 \\(a \\to b\\)가 있으면 \\(b\\)는 \\(a\\)의 인접 노드임 \n\n- **노드의 차수(order):** 노드에 연결된 간선의 수를 말하며, 방향 그래프는 진입 차수(\\(indegree\\))와 진출 차수(\\(outdegree\\))로 나누어 고려함 \n\n- **경로(path):** 두 개의 노드를 연결하는 일련의 노드들 \n\n  - 노드 \\(a\\)에서 \\(b\\)까지의 경로 \\(a, v_1, v_2, ..., v_k, b\\)가 존재하기 위해서는 간선 \\((a, v_1), (v_1, v_2), ..., (v_{n-1}, v_k), (v_k, b)\\)가 존재해야 함 \n\n  - 단순 경로(simple path): 한 노드를 두 번 거치지 않는 경로 \n\n- **경로의 길이** \n\n  - 비가중치 그래프: 경로를 구성하는 간선의 수, \n\n  - 가중치 그래프: 경로를 구성하는 간선의 가중치 합 \n\n![](images/3_0.jpg)",
    "source": "ds-slide12_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 4,
      "page_heading": "# 그래프 용어 (2/4)",
      "images": [
        "ds-slide12/images/3_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0394"
  },
  {
    "type": "강의자료",
    "text": "## 그래프 용어 (3/4) \n\n![](images/4_0.jpg)\n\n \n\n● 주기(cycle): 첫 번째 노드와 마지막 노드가 같은 경로 \n\n● 연결 그래프(connected graph): 그래프에서 서로 다른 모든 노드 쌍 사이에 경로가 존재하는 그래프 \n\n○ 방향 그래프. 약한(weakly) vs. 강한(strongly) 연결 그래프 \n\n● rooted graph \n\n● 완전 그래프(complete graph): 모든 노드가 인접 노드가 되는 그래프 \n\n○ 완전 그래프이면 연결 그래프이지만 반대는 성립하지 않음 \n\n● 부분 그래프(subgraph): \\(V' \\subseteq V\\), \\(E' \\subseteq E\\)이면 \\(G' = (V', E')\\)는 \n\n\\(G = (V, E)\\)의 부분 그래프라 함 \n\n● 유한 그래프: 노드의 수가 유한한 그래프 (비고. 무한 그래프) \n\n![](images/4_1.jpg)\n\n \n\n![](images/4_2.jpg)",
    "source": "ds-slide12_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 5,
      "page_heading": "## 그래프 용어 (3/4)",
      "images": [
        "ds-slide12/images/4_0.jpg",
        "ds-slide12/images/4_1.jpg",
        "ds-slide12/images/4_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0395"
  },
  {
    "type": "강의자료",
    "text": "# 그래프 용어 (4/4) \n\n- \\(n\\)개의 노드로 구성된 그래프(다중 그래프는 아님)의 최대 간선 수 \n\n- 완전 그래프일 때 최대 간선을 가짐 \n\n- 무방향 그래프 \n\n![](images/5_0.jpg)\n\n \n\n- 진출과 진입이 같은 간선의 존재 고려: \\(\\frac{n(n-1)}{2} + n = n(n+1)/2\\) \n\n- 진출과 진입이 같은 간선을 고려하지 않으면: \\(n(n-1)/2\\) \n\n- 방향 그래프 \n\n- 진출과 진입이 같은 간선의 존재 고려: \\(n^2\\) \n\n- 진출과 진입이 같은 간선을 고려하지 않으면: \\(n(n-1)\\) \n\n![](images/5_1.jpg)\n\n \n\n- 무방향 연결 그래프의 최소 간선의 수: \\(n-1\\) \n\n- 트리는 항상 최소 간선의 수로 구성됨 \n\n- 그래프의 간선 수가 최대 간선 수에 가까우면 **밀집(dense)** 그래프 \n\n- 반대로 간선 수가 0에 가까우면 **희소(sparse)** 그래프라 함 \n\n![](images/5_2.jpg)",
    "source": "ds-slide12_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 6,
      "page_heading": "# 그래프 용어 (4/4)",
      "images": [
        "ds-slide12/images/5_0.jpg",
        "ds-slide12/images/5_1.jpg",
        "ds-slide12/images/5_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0396"
  },
  {
    "type": "강의자료",
    "text": "# 신장 트리 (1/2) \n\n- **신장 트리 (spanning tree):** G의 부분 그래프 중 G의 모든 정점들을 포함하는 트리 \n\n- 그래프의 노드 수가 n이면 신장 트리의 간선 수는 n - 1임 \n\n![](images/6_0.jpg)\n\n \n\n<center>부분 그래프이지만 신장 트리가 아님</center> \n\n![](images/6_1.jpg)\n\n \n\n<center>신장트리가 아님</center> \n\n![](images/6_2.jpg)\n\n \n\n<center>신장트리</center>",
    "source": "ds-slide12_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 7,
      "page_heading": "# 신장 트리 (1/2)",
      "images": [
        "ds-slide12/images/6_0.jpg",
        "ds-slide12/images/6_1.jpg",
        "ds-slide12/images/6_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0397"
  },
  {
    "type": "강의자료",
    "text": "## 최소 신장 트리 \n\n● 최소 신장 트리(minimum spanning tree): 가중치 그래프에서 간선들의 가중치의 합이 최소인 신장 트리 \n\n● Prim 알고리즘 ● 우선순위 큐: 힙 자료구조 ● Kruskal 알고리즘 ● Union-find 자료구조 \n\n![](images/7_0.jpg)",
    "source": "ds-slide12_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 8,
      "page_heading": "## 최소 신장 트리",
      "images": [
        "ds-slide12/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0398"
  },
  {
    "type": "강의자료",
    "text": "# 그래프 예 \n\n![](images/8_0.jpg)\n\n \n\n\\(V = \\{A, B, C, D\\}\\)\n\\(E = \\{(A, B), (A, D), (B, C), (C, D)\\}\\) \n\n![](images/8_1.jpg)\n\n \n\n**A의 인접 노드: B, D**\n**A의 차수: 2**\n**경로 (A, C): (A, B), (B, C)**\n**경로 길이: 2**\n**주기: (A, B), (B, C), (C, D), (D, A)**\n**연결그래프** \n\n\\(V = \\{A, B, E, L, M\\}\\)\n\\(E = \\{(A, E), (B, L), (E, A), (L, A), (L, L), (M, B), (M, E)\\}\\) \n\n**A의 인접 노드: E**\n**A의 진출 차수: 1**\n**A의 진입 차수: 2**\n**경로 (M, A): (M, B), (B, L), (L, A)**\n**경로 길이: 3**\n**주기: (A, E), (E, A)**",
    "source": "ds-slide12_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 9,
      "page_heading": "# 그래프 예",
      "images": [
        "ds-slide12/images/8_0.jpg",
        "ds-slide12/images/8_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0399"
  },
  {
    "type": "강의자료",
    "text": "![](images/9_0.jpg)",
    "source": "ds-slide12_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 10,
      "page_heading": "",
      "images": [
        "ds-slide12/images/9_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0400"
  },
  {
    "type": "강의자료",
    "text": "# 비가중치 그래프의 표현 (1/2) \n\n## ● 방법 1. 인접 행렬(adjacent matrix) \n\n![](images/10_0.jpg)\n\n \n\n<table><tr><td></td><td>A</td><td>B</td><td>C</td><td>D</td></tr><tr><td>A</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>B</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>C</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>D</td><td>1</td><td>0</td><td>1</td><td>0</td></tr></table>\n\n**합: 노드의 차수** \n\n단점. \\(n^2\\) 공간이 필요 \n\n- 무방향 행렬은 이것의 반만으로 표현가능 \n\n- 밀집 방향 그래프에 유리한 방식 \n\n- 그래프 정보의 수정이 필요할 때 유리함 \n\n**bool 배열로 표현 가능**",
    "source": "ds-slide12_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 11,
      "page_heading": "# 비가중치 그래프의 표현 (1/2)",
      "images": [
        "ds-slide12/images/10_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0401"
  },
  {
    "type": "강의자료",
    "text": "# 비가중치 그래프의 표현 (2/2) \n\n## ● 방법 2. 인접 리스트 \n\n![](images/11_0.jpg)\n\n \n\n실제 구현에서는 연결 리스트를 꼭 사용하지 않고 배열 리스트를 사용하는 경우도 많음\n배열 리스트를 사용하면 공간이 낭비됨 \n\n진입 정보가 필요 없는 최소 그래프에 유리\n밀집 그래프이면 공간 복잡도 측면에서\n인접 행렬과 차이가 거의 없을 수 있음",
    "source": "ds-slide12_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 12,
      "page_heading": "# 비가중치 그래프의 표현 (2/2)",
      "images": [
        "ds-slide12/images/11_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0402"
  },
  {
    "type": "강의자료",
    "text": "# 가중치 그래프의 표현 (1/2) \n\n## ● 방법 1. 인접 행렬 \n\n<table><tr><td></td><td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>0</td><td>서울</td><td>0</td><td>0</td><td>60</td><td>90</td><td>100</td><td>120</td><td>180</td><td>800</td><td>1600</td><td>-</td><td>-</td></tr><tr><td>1</td><td>부산</td><td>1</td><td>60</td><td>0</td><td>-1</td><td>20</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-</td><td>-</td></tr><tr><td>2</td><td>제주</td><td>2</td><td>90</td><td>-1</td><td>0</td><td>40</td><td>40</td><td>-1</td><td>-1</td><td>-1</td><td>-</td><td>-</td></tr><tr><td>3</td><td>동경</td><td>3</td><td>100</td><td>-1</td><td>-1</td><td>0</td><td>-1</td><td>-1</td><td>-1</td><td>1200</td><td>-</td><td>-</td></tr><tr><td>4</td><td>홍콩</td><td>4</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>0</td><td>60</td><td>-1</td><td>-1</td><td>-</td><td>-</td></tr><tr><td>5</td><td>북경</td><td>5</td><td>180</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>0</td><td>-1</td><td>-1</td><td>-</td><td>-</td></tr><tr><td>6</td><td>하와이</td><td>6</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-0</td><td>600</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>시애틀</td><td>7</td><td>1600</td><td>-1</td><td>-1</td><td>1200</td><td>-1</td><td>-1</td><td>600</td><td>0</td><td>-</td><td>-</td></tr><tr><td>8</td><td>-</td><td>8</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td><td>-</td><td>-</td></tr><tr><td>9</td><td>-</td><td>9</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td><td>-</td><td>-</td></tr></table>\n\n- 간선이 없음을 나타내기 위한 값의 설정 필요 \n\n- 양의 가중치만 존재하는 경우: -1, MAX(가중치의 최댓값보다 큰 값) \n\n- 음의 가중치가 가능한 경우: MAX \n\n- 두 개의 배열이나 구조체 배열을 사용할 수 있음 \n\n- 응용에 따라 임의 노드 a에서 a로의 간선이 합축적으로 존재하고, 그것의 가중치를 0으로 설정하는 경우도 많음",
    "source": "ds-slide12_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 13,
      "page_heading": "# 가중치 그래프의 표현 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0403"
  },
  {
    "type": "강의자료",
    "text": "# 가중치 그래프의 표현 (2/2) \n\n## ● 방법 2. 인접 리스트 \n\n![](images/13_0.jpg)\n\n \n\n인접 행렬 vs. 인접 리스트: 희소 vs. 밀집, 역인접 리스트 필요 여부에 의해 결정 가중치 여부와 무관함",
    "source": "ds-slide12_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 14,
      "page_heading": "# 가중치 그래프의 표현 (2/2)",
      "images": [
        "ds-slide12/images/13_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0404"
  },
  {
    "type": "강의자료",
    "text": "# 순회 (1/2) \n\n## 길이우선탐색(DFS, Depth First Search) \n\ns := starting node\nS := empty stack\nvisited[v] := false for all v\nvisited[s] := true\nS.push(s)\nwhile S is not empty do\n    v := S.pop()\n    for each edge (v, w) do\n        if not visited[w] do\n            visited[w] := true\n            S.push(w) \n\nDFS(G, v, visited) \n\nvisited[v] := true\nfor each edge (v, w) do\n    if not visited[w] then\n        DFS(G, w, visited) \n\ns := starting node\nvisited[v] := false for all v\nDFS(G, s, visited) \n\n스택에 push하는 순서가\n방문 순서에 영향을 줌 \n\n순회 순서: A,C,E,D,B\n스택에서 pop한 순서 \n\n재귀 버전\n순회 순서: A,B,E,C,D\nvisited[v]를 true로 설정한 순서 \n\n순회 순서: A,D,G,C,F,B,E \n\n재귀버전\n순회 순서: A,B,F,C,E,D,G",
    "source": "ds-slide12_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 15,
      "page_heading": "# 순회 (1/2)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0405"
  },
  {
    "type": "강의자료",
    "text": "# 순회 (2/2) \n\n## ● 너비우선탐색(BFS, Breadth First Search) \n\ns := starting node \n\nQ := empty queue of nodes \n\nvisited[v] := false for all v \n\nvisited[s] := true \n\nQ.enqueue(s) \n\nwhile Q is not empty do \n\nv := Q.dequeue() \n\nfor each edge (v, w) do \n\nif not visited[w] then \n\nvisited[w] := true \n\nQ.enqueue(w) \n\n출발노드부터 같은 거리에 있는 노드 순으로 방문함 \n\n![](images/15_0.jpg)",
    "source": "ds-slide12_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 16,
      "page_heading": "# 순회 (2/2)",
      "images": [
        "ds-slide12/images/15_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0406"
  },
  {
    "type": "강의자료",
    "text": "# BFS의 성능 \n\ns := starting node\nQ = empty queue of nodes\nvisited[v] := false for all v\nvisited[s] := true\nQ.enqueue(s)\nwhile Q is not empty do\n  v := Q.dequeue()\n  for each edge (v, w) do\n    if not visited[w] then\n    visited[w] := true\n    Q.enqueue(w) \n\n- while 문 이전 비용: \\(O(n)\\)\n- 큐 생성, visited 배열 초기화 비용 등\n- 전체 queue 연산 수: \\(2n \\rightarrow O(n)\\)\n- 노드마다 두 번\n- while 문 반복 횟수\n- 인접 행렬: \\(O(n^2)\\)\n- 인접 리스트: \\(O(m)\\)\n- 전체 비용\n- 인접 행렬: \\(O(n^2)\\)\n- 인접 리스트 : \\(O(m + n)\\)",
    "source": "ds-slide12_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 17,
      "page_heading": "# BFS의 성능",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0407"
  },
  {
    "type": "강의자료",
    "text": "# 연결 여부 \n\n- 무방향 그래프의 경우 DFS, BFS를 이용하여 연결 여부를 확인할 수 있음 \n\n- DFS(G, i): i 노드로부터 시작하여 방문한 모든 정점 \n\n- 이때 G = DFS(G, i)이면 연결 그래프 \n\n- 어떤 무방향 연결 그래프의 모든 노드의 차수가 짝수이면 여기서 하나의 간선을 제거하여도 여전히 연결 그래프임",
    "source": "ds-slide12_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 18,
      "page_heading": "# 연결 여부",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0408"
  },
  {
    "type": "강의자료",
    "text": "## 신장 트리 \n\nDFS, BFS를 이용하여 신장 트리를 계산할 수 있음 길이우선 신장트리(depth first spanning tree) 너비우선 신장트리(breadth first spanning tree) \n\n![](images/18_0.jpg)\n\n![](images/18_1.jpg)\n\n![](images/18_2.jpg)\n\n<center>원 그래프</center> \n\n<center>DFS(A)의 신장 트리 BFS(A)의 신장 트리</center>",
    "source": "ds-slide12_page_19",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 19,
      "page_heading": "## 신장 트리",
      "images": [
        "ds-slide12/images/18_0.jpg",
        "ds-slide12/images/18_1.jpg",
        "ds-slide12/images/18_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0409"
  },
  {
    "type": "강의자료",
    "text": "## 최단 경로 알고리즘 \n\n● 최단 경로 문제: 노드 간의 가장 짧은 경로를 찾는 문제 \n\n○ 비가중치 그래프: 최소 간선 수 \n\n○ 가중치 그래프: 가중치 합이 최소인 경로 \n\n● 이 문제는 그래프의 종류에 따라 다른 해결책이 필요함 \n\n○ 경우 1. 비가중치 그래프 \n\n● 간선의 가중치가 모두 같으면 여기에 해당 \n\n○ 경우 2. 가중치가 모두 양수인 경우 \n\n○ 경우 3. 음수의 가중치가 있는 경우 (가장 어려움)",
    "source": "ds-slide12_page_20",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 20,
      "page_heading": "## 최단 경로 알고리즘",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0410"
  },
  {
    "type": "강의자료",
    "text": "# Moore 알고리즘 (1/3) \n\n- 모든 간선의 가중치가 같은 그래프에서 출발 노드 s에서 다른 모든 노드까지 길이가 가장 짧은 경로를 찾아주는 알고리즘 \n\n- BFS를 이용하는 알고리즘 \n\n- Moore 알고리즘 \n\ns := starting node \n\nQ := empty queue \n\ndist[v] := -1 for all v \n\nvisited[v] := false for all v \n\nvisited[s] := true \n\ndist[s] = 0 \n\nQ.enqueue(s) \n\nwhile Q is not empty do \n\nv := Q.dequeue() \n\nfor each edge (v, w) do \n\nif not visited[w] then \n\nvisited[w] := true \n\ndist[w] := dist[v]+1 \n\nQ.enqueue(w) \n\n- dist 배열이 visited 배열의 역할까지 할 수 있음\nif dist[w] != -1 then",
    "source": "ds-slide12_page_21",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 21,
      "page_heading": "# Moore 알고리즘 (1/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0411"
  },
  {
    "type": "강의자료",
    "text": "Moore 알고리즘 (2/3) \n\n![](images/21_0.jpg)\n\n \n\n시작 노드: A \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr></table>\n\n시작 노드: C \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-1</td><td>-1</td><td>0</td><td>-1</td><td>-1</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>1</td><td>-1</td><td>-1</td><td>1</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>1</td><td>2</td><td>2</td><td>1</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>2</td><td>1</td><td>0</td><td>1</td><td>1</td></tr></table>",
    "source": "ds-slide12_page_22",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 22,
      "page_heading": "",
      "images": [
        "ds-slide12/images/21_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0412"
  },
  {
    "type": "강의자료",
    "text": "# Moore 알고리즘 (3/3) \n\n- 경로? \n\n- 방법 1. 찾아가면서 이전 노드를 기록함 \n\n- 방법 2. 거꾸로 다시 찾아감. 이웃 중 dist[v]가 최소인 노드를 다음 노드로 선택함. 이웃 노드 중 시작 노드가 있으면 종료 \n\n![](images/22_0.jpg)\n\n \n\nA에서 D까지 \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>1</td><td>-1</td><td>-1</td><td>1</td></tr><tr><td>-</td><td>A</td><td>-</td><td>-</td><td>A</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>1</td><td>2</td><td>2</td><td>1</td></tr><tr><td>-</td><td>A</td><td>B</td><td>B</td><td>A</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>1</td><td>2</td><td>2</td><td>1</td></tr><tr><td>-</td><td>A</td><td>B</td><td>B</td><td>A</td></tr></table>\n\nD→B→A",
    "source": "ds-slide12_page_23",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 23,
      "page_heading": "# Moore 알고리즘 (3/3)",
      "images": [
        "ds-slide12/images/22_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0413"
  },
  {
    "type": "강의자료",
    "text": "# 마식스트라 알고리즘 (1/4) \n\n- 모든 간선의 가중치가 양수인 방향 그래프에서 출발 노드 \\(s\\)에서 다른 모든 노드까지 길이가 가장 짧은 경로를 찾아주는 알고리즘 \n\n- **Dijkstra 알고리즘** \n\n  - **단계 1.** \\(\\forall dist[v] = \\infty, dist[s] = 0\\) \n\n  - **단계 2.** \\(T \\leftarrow V\\) \n\n  - **단계 3.** \\(T\\) 중에 \\(dist[u]\\)가 최소인 노드 \\(u\\)를 찾음 \n\n  - **단계 4.** \\(T\\)가 빈 집합이면 종료 \n\n  - **단계 5.** 노드 \\(u\\)에서 진출하는 모든 간선에 대해 \\(e: u \\to v\\) 중 \\(v \\in T\\)에 대해 \\(dist[v] > dist[u] + weight(e)\\)이면 \\(dist[v] = dist[u] + weight(e)\\)로 갱신 \n\n  - **단계 6.** \\(T = T - \\{u\\}\\) \n\n  - **단계 3부터 다시 반복** \n\n- **BFS에서 일반 큐 대신에 우선순위 큐를 사용함** \n\n  - **대표적인 탐욕적 알고리즘(greedy algorithm)임**",
    "source": "ds-slide12_page_24",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 24,
      "page_heading": "# 마식스트라 알고리즘 (1/4)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0414"
  },
  {
    "type": "강의자료",
    "text": "# 다익스트라 알고리즘 (2/4) \n\n![](images/24_0.jpg)\n\n \n\n게으른 다익스트라 알고리즘: 보통 라이브러리에 제공하는 우선 순위 큐는 갱신이나 삭제 연산을 제공하지 않음",
    "source": "ds-slide12_page_25",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 25,
      "page_heading": "# 다익스트라 알고리즘 (2/4)",
      "images": [
        "ds-slide12/images/24_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0415"
  },
  {
    "type": "강의자료",
    "text": "# 다익스트라 알고리즘 (3/4) \n\n![](images/25_0.jpg)\n\n \n\n<table><tr><td>priority queue</td><td>(∞,B)</td><td>(∞,C)</td><td>(∞,D)</td><td>(∞,E)</td><td>(∞,E)</td></tr></table>\n\n<table><tr><td>priority queue</td><td>(3,C)</td><td>(5,E)</td><td>(∞,D)</td><td>(∞,D)</td></tr></table>\n\n<table><tr><td>priority queue</td><td>(5,E)</td><td>(8,D)</td><td>(8,D)</td></tr></table>\n\n<table><tr><td>priority queue</td><td>(8,D)</td><td>(8,D)</td></tr><tr><td>priority queue</td><td>(6,D)</td><td></td></tr></table>\n\n<table><tr><td>노드</td><td>dist</td><td>prev</td></tr><tr><td>A</td><td>0</td><td>null</td></tr><tr><td>B</td><td>2</td><td>A</td></tr><tr><td>C</td><td>3</td><td>A</td></tr><tr><td>D</td><td>6</td><td>E</td></tr><tr><td>E</td><td>4</td><td>C</td></tr></table>\n\n원 다익스트라 알고리즘",
    "source": "ds-slide12_page_26",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 26,
      "page_heading": "# 다익스트라 알고리즘 (3/4)",
      "images": [
        "ds-slide12/images/25_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0416"
  },
  {
    "type": "강의자료",
    "text": "# 다익스트라 알고리즘 (4/4) \n\n## ● 경로 구축 \n\n### ○ Moore 매와 마찬가지로 두 가지 방법으로 가능 \n\n![](images/26_0.jpg)\n\n \n\n## A에서 D까지의 최단 경로 \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>99</td><td>99</td><td>99</td><td>99</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>2</td><td>3</td><td>99</td><td>5</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>2</td><td>3</td><td>8</td><td>5</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>2</td><td>3</td><td>8</td><td>4</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>4</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>A</td><td>A</td><td>-</td><td>A</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>A</td><td>A</td><td>B</td><td>A</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>A</td><td>A</td><td>B</td><td>C</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>A</td><td>A</td><td>E</td><td>C</td></tr></table>\n\n○ 이전 노드를 기록하지 않고 dist 배열을 이용하여 경로를 구축할 수 있음",
    "source": "ds-slide12_page_27",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 27,
      "page_heading": "# 다익스트라 알고리즘 (4/4)",
      "images": [
        "ds-slide12/images/26_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0417"
  },
  {
    "type": "강의자료",
    "text": "# Bellman과 Ford 알고리즘 (1/3) \n\n- **Bellman과 Ford 알고리즘**: 가중치가 음수가 될 수 있는 방향 그래프에서 노드 \\(s\\) 에서 다른 모든 노드까지의 가장 짧은 경로를 찾아주는 알고리즘 \n\n- 음의 주기가 존재하지 않아야 함 \n\n- 음의 주기가 존재하지 않으면 최단 경로의 길이는 최대 \\(n-1\\) 일 (Why?) \n\n- 기본 생각 \n\n- 길이가 1인 것부터 \\(n-1\\)인 것까지 모두 구함 \n\n음의 주기가 있는지 여부는 어떻게? \n\n**Bellman-Ford를 한번 더 수행**\n즉, 길이가 \\(n\\)인 것을 구함\n길이가 \\(n\\)인 것이 \\(n-1\\)인 것보다 짧으면 음의 주기 존재하는 것임 \n\n<table><tr><td>A</td><td>B</td><td>C</td></tr><tr><td>0</td><td>5</td><td>3</td></tr><tr><td></td><td></td><td></td></tr><tr><td>A</td><td>B</td><td>C</td></tr><tr><td>0</td><td>1</td><td>6</td></tr><tr><td></td><td></td><td></td></tr><tr><td>A</td><td>B</td><td>C</td><td></td></tr><tr><td>0</td><td>4</td><td>2</td></tr></table>\n\n![](images/27_0.jpg)\n\n \n\n음의 주기가 존재하는 경우",
    "source": "ds-slide12_page_28",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 28,
      "page_heading": "# Bellman과 Ford 알고리즘 (1/3)",
      "images": [
        "ds-slide12/images/27_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0418"
  },
  {
    "type": "강의자료",
    "text": "# Bellman과 Ford 알고리즘 (2/3) \n\n- **Bellman과 Ford가 서로 독립적으로 제안한 알고리즘** \n\n- **동적 프로그래밍 기법의 알고리즘** \n\n- **Dist\\(^{k}[u]\\): 출발 노드 \\(v\\)에서 \\(u\\)까지 최대 \\(k\\)개의 간선을 포함할 수 있는 최단 경로** \n\n\\[\n\\text{Dist}^{k}[u] := \\min \\left( \\text{Dist}^{k-1}[u], \\min(\\text{Dist}^{k-1}[i] + \\text{weight}[i, u]) \\right)\n\\]\n\n- **참고. 동적 프로그래밍에서는 위와 같은 점화식을 찾아 상향식(bottom-up) 방법으로 문제를 해결함** \n\n- \\(\\forall u, \\text{Dist}^{k}[u] = \\text{Dist}^{k-1}[u]\\) 이면 종료할 수 있음 \n\n- **Dist\\(^{n-1}[u]\\)까지 계산하는 것이 아니라 음의 주기 검사를 위해 Dist\\(^{n}[u]\\)까지 계산함** \n\n- **Floyd와 Warshall 최단 경로 알고리즘: 가중치에 제한이 없는 방향 그래프에서 모든 노드에서 다른 모든 노드까지 최단 경로를 찾아 줌** \n\n- **Bellman과 Ford 알고리즘을 \\(n\\)번 수행하는 것보다 성능이 우수함**",
    "source": "ds-slide12_page_29",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 29,
      "page_heading": "# Bellman과 Ford 알고리즘 (2/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0419"
  },
  {
    "type": "강의자료",
    "text": "# Bellman과 Ford 알고리즘 (3/3) \n\n## 경로의 간선 수 = 1 \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>99</td><td>99</td><td>99</td><td>99</td></tr></table>\n\n## 경로의 간선 수 = 3 \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>5</td><td>3</td><td>-2</td><td>-</td></tr></table>\n\n## 경로의 간선 수 = 2 \n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>5</td><td>3</td><td>-2</td><td>-</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>-</td><td>-</td><td>4</td><td>-</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>-</td><td>1</td><td>-</td><td>-</td><td>2</td></tr></table>\n\n<table><tr><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>0</td><td>1</td><td>3</td><td>-2</td><td>1</td></tr></table>\n\n## 최소 길이가 변하지 않으면 종료할 수 있음 \n\n## 경로의 간선 수가 1과 2인 것 중 최소 길이",
    "source": "ds-slide12_page_30",
    "meta_data": {
      "tables": [],
      "lecture_title": "그래프",
      "page_no": 30,
      "page_heading": "# Bellman과 Ford 알고리즘 (3/3)",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0420"
  },
  {
    "type": "강의자료",
    "text": "![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n## 학기 요약 \n\nNOTE 13 \n\n한국기술교육대학교 컴퓨터공학부  김상진 \n\nsangjin@koreatech.ac.kr www.facebook.com/sangjin.kim.koreatech",
    "source": "ds-slide13_page_1",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 1,
      "page_heading": "## 학기 요약",
      "images": [
        "ds-slide13/images/0_0.jpg",
        "ds-slide13/images/0_1.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_강의자료_0421"
  },
  {
    "type": "강의자료",
    "text": "## 전체 요약 \n\n● 이 수업에서 문제 해결할 때 사용할 수 있는 다양한 자료구조를 살펴보았음 \n\n● 리스트, 스택, 큐, 맥, 트리, 이진트리, 이진검색트리, 균형이진검색트리, 집합, 맵, 해시테이블, 블룸필터, 우선순위 큐, 그래프 \n\n● 자료구조는 구체적 구현이기 때문에 ADT와 구분하여 생각할 수 있어야 함 \n\n● 각 자료구조의 특성을 이해하고 문제가 주어졌을 때 가장 효과적인 자료구조를 선택하여 사용할 수 있어야 함 \n\n● 필요하면 여러 자료구조를 함께 사용할 수 있어야 함 \n\n● 각 자료구조를 사용하여 문제를 해결하였을 때의 시간 복잡도와 공간 복잡도를 분석할 수 있어야 함 \n\n● 이 분석에 사용하는 것이 비어임 \n\n● 각종 자료구조를 구현해봄으로써 자료구조에 대한 이해도와 프로그래밍 능력이 향상하였을 것으로 기대함",
    "source": "ds-slide13_page_2",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 2,
      "page_heading": "## 전체 요약",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0422"
  },
  {
    "type": "강의자료",
    "text": "## 비O \n\n● Big-O 표기법은 최악의 경우 알고리즘이 특정 수준과 같거나 빠르다는 것을 나타냄 \n\n● 실제 수행시간을 측정하여 성능을 분석하는 것이 아니라 주어진 입력 크기에 대해 필요한 기본 연산 수를 파악하여 시간 복잡도를 분석하는 것임 \n\n● 연산 수 대신에 필요한 공간의 크기를 분석하여 공간 복잡도를 분석할 수 있음 \n\n● 입력 크기에 대해 필요한 기본 연산 수를 나타내는 다항식을 구하고, 그 다항식에서 가장 높은 차수(계수 제외)가 알고리즘의 비O가 됨 \n\n● 접근적 최악의 경우 분석이기 때문에 입력 크기가 매우 클 경우에만 의미가 있음 \n\n● 입력 크기가 작으면 빅O가 나쁜 것이 실제 성능이 더 좋을 수 있음 \n\n● 입력 크기는 정확하게는 그 입력을 컴퓨터에 표현하기 위한 문자 수임 ● 대부분의 경우 정확하게 분석하지 않아도 결과의 차이가 없음",
    "source": "ds-slide13_page_3",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 3,
      "page_heading": "## 비O",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0423"
  },
  {
    "type": "강의자료",
    "text": "## 비어 \n\n● 다중변수비O는단일변수로바꾸지않고그대로사용하는것이 더많은정보를주는형태가됨 \n\n● 공간복잡도는(입력이사용하는공간+ 알고리즘내부에서사용하는 공간)임 \n\n● 하지만같은문제의경우입력이사용하는공간이같기때문에 비교에서는알고리즘내부에서사용하는공간이중요함 \n\n● 재귀알고리즘은재귀호출의깊이가공간복잡도에영향을줌 \n\n● 재귀호출이계속이루어지면그만큼함수스택공간이필요하며, 이공간도공간복잡도에포함됨",
    "source": "ds-slide13_page_4",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 4,
      "page_heading": "## 비어",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0424"
  },
  {
    "type": "강의자료",
    "text": "Common Order \n\n- \\(O(1)\\): 상수시간(constant time) 비용. 입력 크기에 전혀 영향을 받지 않는 경우 \n\n- 예) 배열 끝에 요소 저장하기, 해상을 이용한 각종 연산 비용 \n\n- \\(O(\\log n)\\): 로그시간(logarithmic time) 비용. 한 번에 처리해야 하는 양이 반씩 줄어드는 경우 \n\n- 예) 이진 검색, 균형 이진 검색 트레이션 각종 연산 비용 \n\n- \\(O(n)\\): 선형시간(linear time) 비용. 예) 선형 검색 \n\n- \\(O(n\\log n)\\): 의사선형시간(quasilinear time) 비용 \n\n- 예) 합병 정렬, 빠른 정렬. 힙 정렬 \n\n- \\(O(n^2)\\): 이차시간(quadratic time) 비용. 예) 버블 정렬 \n\n- 다항시간(polynomial time) 비용 \n\n- \\(O(2^n)\\): 지수시간(exponential time) 비용 \n\n- \\(O(n!)\\): 계승시간(factorial time) 비용",
    "source": "ds-slide13_page_5",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 5,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0425"
  },
  {
    "type": "강의자료",
    "text": "## 리스트 \n\n● 리스트. 배열 기반 vs. 연결구조 기반 \n\n● 데이터를 정렬하여 유지할 수 있고, 정렬하지 않고 유지할 수 있음 \n\n○ 정렬하지 않으면 삽입을 효과적으로 할 수 있지만 반면에 검색은 선형 검색을 할 수밖에 없음 \n\n○ 연결구조는 정렬하여 유지하여도 이진 검색을 할 수 없음 \n\n● 중복 허용 여부 \n\n○ 비정렬의 경우에는 중복을 허용하지 않으면 삽입을 효과적으로 할 수 있는 이점이 사라지기 때문에 보통 중복을 허용함 \n\n○ 정렬은 중복 허용이 성능에 영향을 주지 않음 \n\n● 배열은 용량이 고정되기 때문에 보통 동적 배열 기법을 사용함 \n\n○ 동적 배열 기법은 보통 용량을 확장해야 할 때 k(>1)배 확장함 \n\n○ k(>1)배 확장하면 확장 비용을 무시할 수 있지만 최초에 필요한 용량을 파악하고 충분히 확보한 후에 사용하는 것이 효과적임 \n\n● 동적 배열 기법을 사용하는 모든 자료구조에 해당함",
    "source": "ds-slide13_page_6",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 6,
      "page_heading": "## 리스트",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0426"
  },
  {
    "type": "강의자료",
    "text": "## 리스트 \n\n● 배열은 임의 접근할 수 있는 것이 최대 이점이고, 연결구조는 공간이 낭비되지 않고, 초기에 적절한 용량을 확보해야 하는 고민이 없음 \n\n● 배열은 연속 공간으로 확보되기 때문에 캐싱 측면에서 유리함 \n\n● 배열을 이용한 다른 자료구조도 마찬가지임 \n\n● 포인터/참조 배열이면 이 효과가 없음 \n\n● 리스트는 다른 자료구조를 구현할 때 내부 데이터를 저장하는 용도로도 많이 활용됨. 예) 스택, 큐, 떡 \n\n● 배열은 기본적으로 맨 뒤에 삽입/추출이 효과적이고, 연결구조는 맨 앞에 삽입/추출이 효과적임 \n\n● 배열은 삽입 순서를 유지하면서 양방향으로 효과적으로 삽입/추출하고 싶으면 순환 배열 방식을 사용해야 함 \n\n● 연결구조는 양방향으로 효과적으로 삽입/추출하고 싶으면 꼬리 포인터를 유지하는 이중 연결구조를 사용해야 함 \n\n● 단일 연결구조는 꼬리 포인터를 유지하더라도 popBack은 여전히 선형 비용임",
    "source": "ds-slide13_page_7",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 7,
      "page_heading": "## 리스트",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0427"
  },
  {
    "type": "강의자료",
    "text": "비교 \n\n<table><tr><td rowspan=\"3\"></td><td colspan=\"2\">ArrayList</td><td colspan=\"4\">SingleLinkedList</td><td colspan=\"4\">DoubleLinkedList</td></tr><tr><td rowspan=\"2\">비정렬</td><td rowspan=\"2\">정렬</td><td colspan=\"2\">비정렬</td><td colspan=\"2\">Sorted</td><td colspan=\"2\">비정렬</td><td colspan=\"2\">정렬</td></tr><tr><td>With tail</td><td></td><td>With tail</td><td></td><td>With tail</td><td></td><td>With tail</td><td></td></tr><tr><td>find</td><td>O(n)</td><td>O(logn)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>Push Front</td><td>O(1)*</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td>O(1)</td></tr><tr><td>Pop Front</td><td>O(1)*</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td></td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>add</td><td>-</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(1)</td></tr><tr><td>Push Back</td><td>O(1)</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td>O(1)</td></tr><tr><td>Pop Back</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>remove</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)<br/>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td></td><td>O(n)</td></tr></table>\n\n- 배열리스트는 동적배열을 사용하였을 때 확장에 따른 추가 비용 발생 \n\n- *비정렬 배열리스트에서는 삽입 위치를 유지하지 않아야 저렴한 비용으로 추가, 삭제 가능 또는 순환 배열 리스트이면 O(1) \n\n- 배열리스트는 색인에 의한 O(1) 접근이 가능",
    "source": "ds-slide13_page_8",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 8,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0428"
  },
  {
    "type": "강의자료",
    "text": "## 스택, 큐, 덱 \n\n● 스택: LIFO \n\n○ 동적 배열 기법을 사용하는 비정렬 배열 리스트로 구현하거나 단일 연결 구조 리스트로 구현 \n\n● 큐: FIFO \n\n○ 동적 배열 기법을 사용하는 비정렬 순환 배열 리스트로 구현하거나 꼬리 포인터를 유지하는 단일 연결 구조 리스트로 구현 \n\n● 덱: 양쪽이 모두 효과적인 큐 \n\n○ 동적 배열 기법을 사용하는 비정렬 순환 배열 리스트로 구현하거나 꼬리 포인터를 유지하는 이중 연결 구조 리스트로 구현",
    "source": "ds-slide13_page_9",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 9,
      "page_heading": "## 스택, 큐, 덱",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0429"
  },
  {
    "type": "강의자료",
    "text": "## 트리 \n\n<table><tr><td rowspan=\"2\">● 비선형 구조 ● 보통 루트가 있는 트리를 고려함 ● 트리의 특성 ● 루트에서 모든 노드까지 경로가 유일함 ● 트리에서 간선을 하나 추가하면 더 이상 트리가 아닌 ● 재귀적 구조 ● 트리/노드의 높이, 레벨, 깊이 ● 트리 탐색(그래프 탐색): BFS(큐), DFS(스택 또는 재귀) ● 이진 트리: 자식 수가 최대 2개인 트리 ● 완전 이진 트리 ● 이진 검색 트리 ● 균형 이진 검색 트리 ● AVL보다 red-black 트리가 성능이 좋지만 트리 높이 측면에서는 AVL이 더 우수함 (보통 라이브러리에서는 red-black 트리 사용)</td><td>None</td></tr><tr><td>None</td></tr></table>",
    "source": "ds-slide13_page_10",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 10,
      "page_heading": "## 트리",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0430"
  },
  {
    "type": "강의자료",
    "text": "# 이진 검색 트리 \n\n## ● 데이터의 삽입과 검색 \n\n<table><tr><td rowspan=\"2\"></td><td colspan=\"2\">배열</td><td colspan=\"2\">연결구조</td><td rowspan=\"2\">이진 검색 트리</td></tr><tr><td>비정렬</td><td>정렬</td><td>비정렬</td><td>정렬</td></tr><tr><td>삽입</td><td>\\(O(1)\\)</td><td>\\(O(n)\\)</td><td>\\(O(1)\\)</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)</td></tr><tr><td>검색</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)</td><td>\\(O(n)\\)</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)</td></tr><tr><td>순위/선택</td><td>\\(O(n)\\)</td><td>\\(O(1)^{*}\\)</td><td>\\(O(n)\\)</td><td>\\(O(n)\\)</td><td>*</td></tr><tr><td>prev/next</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)</td><td>\\(O(n)\\)</td><td>\\(O(n)\\)</td><td>\\(O(\\log n)\\)</td></tr><tr><td>range</td><td>\\(O(n)\\)</td><td>\\(O(\\log n + k)\\)</td><td>\\(O(n)\\)</td><td>\\(O(n)\\)</td><td>\\(O(\\log n + k)\\)</td></tr></table>\n\n- 일반 이진 검색 트리는 삽입하는 순서에 의해 트리 모습이 결정되기 때문에\n주어진 복잡도를 얻기 위해서는 균형 이진 검색 트리를 사용해야 함 \n\n- 순위(rank): 주어진 요소가 몇 번째 요소인지? 정렬 배열: 검색 후 색인이 rank → \\(O(\\log n)\\) \n\n- 선택(selection): n번째 요소 찾기? n번째 색인에 있는 값 → \\(O(1)\\)",
    "source": "ds-slide13_page_11",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 11,
      "page_heading": "# 이진 검색 트리",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0431"
  },
  {
    "type": "강의자료",
    "text": "## 집합 \n\n● 실제 데이터를 유지할 필요는 없음 \n\n● 구현 방법 \n\n● 방법 1. 직접 주소(direct addressing) 방법 \n\n● 직접 주소 계산을 위한 매핑 함수가 필요함 \n\n● 단점. 도메인 크기만 공간이 필요함 \n\n● 극복 방법. 비트 벡터 사용 \n\n● 방법 2. 균형 이진 검색 트리 (데이터 저장 필요) \n\n● 모든 연산이 O(log n)임 \n\n● 순서가 유지됨 \n\n● 방법 3. 해상 (데이터 저장 필요) \n\n● 모든 연산이 O(1)이지만 해상 비용, 충돌 처리 비용이 소요됨 \n\n● 생성할 때 충분한 용량을 확보하지 않으면 동적 배열 기법 비용이 고가임 \n\n● 저장된 데이터에 대한 순서를 제공하지 않음",
    "source": "ds-slide13_page_12",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 12,
      "page_heading": "## 집합",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0432"
  },
  {
    "type": "강의자료",
    "text": "● 맥은 집합과 같은 방법을 구현되지만 키만 유지하는 것이 아니라 키와 값 쌓을 유지함 \n\n● 같은 데이터를 삽입하면 집합은 삽입되지 않지만 맥은 연결된 기존 키 값을 변경함 \n\n● 맥을 응용한 multiset, counter 집합이 있으며, 이 집합은 중복을 허용하고, 같은 키를 몇 번 저장하였는지 알려줌 \n\n● 키의 순서를 유지해주는 것은 아니지만 삽입 순서를 유지해 주는 집합과 맥도 있음 (예: OrderDict, LinkedInHashSet 등) \n\n● 삭제가 필요 없고, 검색이 작은 확률로 거짓 양성을 주어도 괜찮으면 블룸 필터를 이용할 수 있음 \n\n● 블룸 필터도 데이터 자체를 저장하지 않고, 내부적으로 비트 벡터로 구현함",
    "source": "ds-slide13_page_13",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 13,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0433"
  },
  {
    "type": "강의자료",
    "text": "# 해싱 기술 \n\n- 해시 함수를 이용하여 저장할 값의 저장 위치를 계산하여 임의 접근이 가능한 배열에 데이터를 저장하는 기술 \n\n- 해시 함수는 기본적으로 충돌이 불가피함 \n\n  - 충돌: 서로 다른 데이터이지만 해시값이 같은 경우 \n\n  - 해시 함수와 비교 함수(equals, ==)가 매우 중요함 \n\n- 초기 용량(저장할 데이터의 1.3배 이상)을 충분히 확보하고 좋은 해시함수를 사용하면 충돌을 최소화할 수 있음 \n\n  - 이 경우에만 실제 비용이 0(1)이라고 할 수 있으며, 이 비용에는 해시 함수 계산 비용이나 충돌 처리 비용은 포함되지 않음 \n\n- 충돌 해소 전략은 크게 열린 기법과 닫힌 기법이 있음 \n\n  - 열린 기법은 원래 위치가 아닌 다른 위치에 저장하는 방법이고, 닫힌 기법은 원래 위치에 여러 개를 저장하는 방법임 \n\n  - 보통 연결구조를 이용한 닫힌 기법을 주로 사용함",
    "source": "ds-slide13_page_14",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 14,
      "page_heading": "# 해싱 기술",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0434"
  },
  {
    "type": "강의자료",
    "text": "<table><tr><td></td><td>HashSet/HashMap</td><td>TreeSet/TreeMap</td></tr><tr><td>구현방법</td><td>단헌 기법 중 chaining 기법</td><td>Red-Black-Tree (균형 이진 검색 트리)</td></tr><tr><td>생성</td><td>용량은 저장할 개수의 1.3배</td><td>저장할 개수가 예측이 안 되면 TreeMap의 사용이 더 유리할 수 있음</td></tr><tr><td>연산</td><td>\\(O(1)\\)<br/>해시 비용, 충돌 처리 비용,<br/>저장된 값과 비교 비용 등<br/>* 저장된 요소에 비례한 비용은 아님</td><td>\\(O(\\log n)\\)<br/>비교 비용</td></tr><tr><td>순서</td><td>저장된 데이터 순서에 대한 정보 없음</td><td>저장된 데이터에 대한 순서 정보 있음</td></tr><tr><td>특징</td><td>용량이 부족하여 확장해야 하면 많은<br/>비용이 소요됨</td><td>균형 이진 검색 트리가 제공할 수 있는<br/>다양한 연산 활용 가능</td></tr></table>",
    "source": "ds-slide13_page_15",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 15,
      "page_heading": "",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0435"
  },
  {
    "type": "강의자료",
    "text": "## 우선순위 큐 \n\n● 우선순위 큐를 선형 자료구조로 구현하면 삽입과 추출 중 하나만 효과적으로 제공할 수 있음 \n\n● 균형이진검색트리로구현할수있지만그것보다더효과적인 힘이라는자료구조가있음 \n\n● 우선순위가단순하면여러개FIFO 큐를사용할수있음 \n\n● 힘은 값의 중복도 자연스럽게 제공할 수 있음 \n\n● 가장 우선순위가 높은 값만 필요하면 힘의 사용이 효과적이지만 검색, 삭제 등의 기능이 필요하면 균형 이진 검색 트리의 사용이 더 효과적임 \n\n● 힘은 항상 완전 이진 트리를 유지하기 때문에 연결구조 방식이 아니라 배열을 사용하여 구현할 수 있음 \n\n● 이진 검색 트리는 노드의 좌우 자손 값에 제한이 있지만 힘은 위 아래만 제한이 있고 좌우는 제한이 없어 항상 완전 이진 트리로 유지할 수 있음 \n\n● 동적 배열 기법이 필요함",
    "source": "ds-slide13_page_16",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 16,
      "page_heading": "## 우선순위 큐",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0436"
  },
  {
    "type": "강의자료",
    "text": "## 그래프 \n\n<table><tr><td rowspan=\"2\">● 그래프는 트리를 포함하는 개념. 노드와 간선으로 구성 ● 방향/무방향, 가중치/비가중치 등 다양한 형태가 있음 ● 그래프를 표현하는 방법은 크게 인정 행렬, 인접 리스트가 있음 ● 희소 무방향 그래프이면 인접 리스트 ● 밀집 방향 그래프이면 인접 행렬 ● 역인접이 필요하면 인접 행렬이 더 효과적일 수 있음 ● 인접 행렬로 가중치 그래프를 표현할 경우에는 간선이 없다는 것을 표현할 가중치 값의 결정이 필요함 ● 최단 경로 문제는 그래프의 형태에 따라 다른 해결책이 필요함 ● 비가중치 그래프: 단순 BFS ● 음수 가중치가 없는 가중치 그래프: 다익스트라 알고리즘 ● 우선순위 큐 사용, 탐욕적 알고리즘 ● 음수 가중치가 있는 가중치 그래프: Bellman/Ford, Warshall/Floyd 알고리즘, 동적 프로그래밍</td><td>None</td></tr><tr><td>None</td></tr></table>",
    "source": "ds-slide13_page_17",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 17,
      "page_heading": "## 그래프",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0437"
  },
  {
    "type": "강의자료",
    "text": "# 1.1.1.1.1.1.1.1.1.1.1",
    "source": "ds-slide13_page_18",
    "meta_data": {
      "tables": [],
      "lecture_title": "학기 요약",
      "page_no": 18,
      "page_heading": "# 1.1.1.1.1.1.1.1.1.1.1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_강의자료_0438"
  }
]