[
  {
    "type": "텍스트북",
    "text": "## 1. 데이터와 데이터 추상화",
    "source": "ds01_1_데이터와 데이터 추상화",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "데이터와 데이터 추상화",
      "section_number": "1",
      "section_heading": "## 1. 데이터와 데이터 추상화",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0001"
  },
  {
    "type": "텍스트북",
    "text": "### 1.1 데이터 \n\n오늘날 소프트웨어는 다양한 종류의 데이터를 처리한다. 단순한 데이터부터 어떤 구조도 없는 매우 복잡한 데이터를 처리해야 할 수 있다. 또 매우 빠른 속도로 발생하는 데이터를 처리해야 할 수 있고, 처리해야 하는 데이터의 양도 매우 많을 수 있다. 소프트웨어가 필요한 데이터를 처리하기 위해서는 해당 데이터를 컴퓨터 내부에 표현해야 한다. 이때 데이터를 표현하고 유지하는 형태가 소프트웨어 성능에 큰 영향을 줄 수 있다. 어떤 데이터를 컴퓨터 내부에 표현하고 유지하는 형태는 보통 사람이 해당 데이터를 생각하고 바라보는 시각과 같을 수 없다. \n\n예를 들어 사람의 나이라는 데이터를 생각하여 보자. 사람의 나이는 1살부터 시작하여 1년이 지날 때마다 1씩 증가하기 때문에 양의 정수 데이터이다. 컴퓨터에서 가장 효과적으로 표현하고 처리할 수 있는 데이터가 정수이다. 하지만 컴퓨터는 정수를 이진 데이터로 저장하며, 2의 보수(two's complement)라는 방법을 사용하여 표현한다. 또 특정 데이터를 표현할 때 사용하는 공간이 정해져 있기 때문에 나타낼 수 있는 정수의 범위가 제한적이다. 이처럼 우리의 일반적 사고와 컴퓨터의 표현 간에는 차이가 있을 수 밖에 없다. \n\n개발자 입장에서는 소프트웨어를 개발하는 과정에서 이 차이를 어느 정도 수준까지는 인식하고 고려해야 한 다. 하지만 세부적이고 상세한 부분까지 항상 검토해야 하는 것은 아니다. 상황에 따라 추상화(abstraction)하여 생각하는 것이 편리하며 효과적이다. \n\n예를 들어 우리는 운전하는 방법을 배우고 면허증을 취득하면 자동차를 운전할 수 있다. 이를 위해 자동차의 내부 동작 원리와 내부 구성요소에 대해 전문 지식을 가지고 있지 않아도 된다. 물론 전문 지식을 가지고 있으면 자동차를 더 잘 관리할 수 있고, 더 효과적으로 운전할 수 있다.",
    "source": "ds01_1.1_데이터와 데이터 추상화-### 1.1 데이터",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "데이터와 데이터 추상화: ### 1.1 데이터",
      "section_number": "1.1",
      "section_heading": "### 1.1 데이터",
      "parent_section": "1. 데이터와 데이터 추상화",
      "parent_section_number": "1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0002"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 데이터의 종류 \n\n데이터의 종류를 프로그래밍에서는 자료유형 또는 타입(type)이라 한다. 타입은 해당 타입이 가질 수 있는 값의 범위(domain)와 해당 값들을 가지고 할 수 있는 연산에 의해 정의된다. 예를 들어 C++에서 int가 4바이트로 표현된다면 그것의 도메인은 -2,147,483,648에서 2,147,483,647까지이며, 정수를 이용하여 사칙연산, 나머지 연산 등을 할 수 있고, 비교 연산자를 이용하여 다른 정수와 비교할 수 있다. \n\n하지만 int는 추상 데이터 타입(ADT. Abstract Data Type)은 아니다. 추상 데이터 타입은 특정 구현과 무관한 독립적인 특성만 이용하여 정의된다. 정수 데이터는 어떤 정수 n이 있으면 항상 n - 1과 n + 1이 존재한다. 반면에 C++의 int는 2의 보수를 사용하는 특정 구현이며, 범위도 제한적이다.\n\n\n프로그래밍에서 데이터 타입은 기준에 따라 원시 타입(primitive type, basic type)과 복합 타입(composite type, compound type)으로 구분할 수 있고, 값 타입(value type)과 참조 타입(reference type)으로 구분할 수 있다. 원시 타입은 특정 값을 하나만 유지하는 타입을 말한다. 앞서 살펴본 C++의 int는 정수 값 하나만 유지하기 때문에 원시 타입이다. 복합 타입은 여러 개의 값을 유지하는 타입을 말한다. C 언어의 경우, 문자열, 배열, 구조체 등이 복합 타입에 해당한다. 값 타입은 값 자체를 유지하는 타입이고 참조 타입1은 값 대신에 값이 유지되어 있는 위치 정보를 유지하는 타입을 말한다. \n\n프로그래밍 언어 자체에 포함하여 제공하는 타입이 있고, 시스템 라이브러리를 통해 제공하는 타입도 있고, 사 용자가 정의한 타입이 있을 수 있다. 보통 언어 자체에는 원시 타입과 배열, 문자열 정도만 제공하며, 나머지 타입은 시스템 라이브러리를 통해 제공한다. 시스템 라이브러리를 통해 제공하는 타입은 대부분 복합 타입이다. \n\n컴퓨터에서 처리해야 하는 데이터가 단순하여 단일 원시 타입으로 표현할 수 있으면 이에 대한 처리 방법도 간단할 수 있다. 하지만 처리해야 하는 데이터가 하나가 아니라 여러 개이면 이들을 표현하고 유지하는 방법이 소프트웨어 성능에 의미 있는 영향을 주게 된다. 가장 효과적으로 처리하기 위해서는 데이터의 특성과 소프트웨어 요구사항을 잘 분석해야 하고, 그 분석을 바탕으로 가장 적합한 자료구조(data structure)에 데이터를 유지해야 한다.",
    "source": "ds01_2_데이터의 종류",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "데이터의 종류",
      "section_number": "2",
      "section_heading": "## 2. 데이터의 종류",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0003"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 자료구조 \n\n자료구조란 복합타입의 구체적 구현을 말하며, 개별 데이터를 저장하고 추출하는 방식에 의해 그 특성이 결정된다. 자료구조의 주요 특징은 다음과 같다. \n\n• 개별 요소로 나눌 수 있다. \n\n• 개별 요소의 배치가 각 요소의 접근을 결정한다. \n\n• 배치와 접근 방법을 모두 추상화할 수 있다. \n\n프로그래머는 같은 종류의 데이터를 여러 개 유지하여야 할 때 이를 어떤 자료구조에 유지하는 것이 바람직한 것인지 알아야 한다. 이때 자료구조와 추상 데이터 타입을 구분하여 생각할 필요가 있다. 추상 데이터 타입은 특정 구현과 독립적인 특성을 정의한 것이기 때문에 공간 복잡성이나 개별 연산의 시간 복잡성을 논할 수 없다. 반면에 자료구조는 구체적 구현이므로 공간과 각 연산의 성능에 대한 복잡성을 계산할 수 있다. 따라서 자료구조는 상호 간의 비교가 가능하다. \n\n프로그래밍을 잘 하지 못하더라도 (언제가는 잘 할 수 있다는 생각을 꼭 가지시길 바람) 특정 구현과 독립적인 특성으로 정의되는 추상 데이터 타입은 이해하여야 하며, 특정 자료구조를 프로그래밍 언어로 구현을 하지 못하더라도 어떤 방법으로 구현한 것인지에 따라 그 자료구조의 특성은 이해할 수 있어야 한다. 이 특성은 프로그래밍 언어에 따라 조금 다를 수 있다. 이것도 어렵게 느껴질 수 있겠지만 이 교재를 통해 조금은 마음이 편해지고 추상 데이터 타입과 자료구조를 상위 수준에서 이해할 수 있기를 기대한다. \n\n스택(stack) ADT를 통해 ADT와 자료구조의 차이를 이해해 보자. ADT 측면에서 스택은 LIFO(Last-In-First- Out) 방식을 지원하는 복합 타입이라는 것만 이해하면 사용할 수 있다. LIFO를 지원하는 자료구조에 5, 3, 7 순으로 데이터를 추가한 다음 추출 연산을 실행하면 7이 가장 먼저 추출된다. 스택은 내부적으로 배열을 이용하여 구현할 수 있고, 연결구조(linked-list)라는 것을 이용하여 구현할 수 있다. 구현을 어떻게 했는지에 따라 특성이 조금 다르다. 배열을 이용하면 중간에 용량이 부족하여 확장해야 할 수 있으며, 이때 비용이 많이 발생할 수 있다. 반면에 연결구조는 데이터를 삽입할 때마다 공간을 확보하기 때문에 이와 같은 문제는 없지만 저장된 데이터가 인접하여\n\n\n유지하지 않기 때문에 CPU 캐시 활용 측면에서 효과적이지 못하다. ADT 측면에서 접근하면 이와 같은 복잡한 내용은 고려하지 않는다. \n\n보통 ADT는 추가(push), 추출(pop), 보기(peek), 찾기(find), 삭제(remove) 5가지 연산을 제공한다. 보기와 추출은 둘 다 특정 위치에 있는 요소를 요구하는 것이지만 보기는 내부 구성을 유지한 상태에서 요소를 보기만 하는 것인 반면에 추출은 해당 요소를 삭제까지 한다. 또 추가 외에 바꾸기(replace) 연산을 제공하는 경우도 있다. 바꾸기는 저장되어 있는 요소의 개수는 변하지 않고 특정 요소를 다른 요소로 바꾸는 것을 말한다. \n\n자료구조가 제공하는 연산의 수가 적을수록 더 효과적으로 구현할 수 있다. 반면에 제공하는 연산이 많으면 모든 연산을 효과적으로 구현하는 것이 어렵다. 따라서 자료구조가 제공하는 각 연산의 성능을 이해해야 하고, 해당 자료구조를 사용할 때에는 효율적인 연산만 사용하는 것이 바람직하다.",
    "source": "ds01_3_자료구조",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "자료구조",
      "section_number": "3",
      "section_heading": "## 3. 자료구조",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0004"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1 범용 자료구조 \n\n보통 자료구조가 제공하는 기본 연산의 알고리즘은 그것이 유지하는 타입과 무관하다. 이 때문에 불필요한 코드 중복을 줄이기 위해 특정 타입만 유지할 수 있는 전용 자료구조를 구현하여 사용하지 않고 다양한 타입을 유지할 수 있는 자료구조를 구현하여 사용한다. 이와 같은 자료구조를 범용 자료구조라 한다. \n\nC++와자바는이와같은범용자료구조를쉽게구현할수있도록template이라는기능을제공한다. template 은실제사용할타입과무관하게타입매개변수를이용하여구현할수있도록해주며, 구현된것을사용할때에는 타입인자를제시하여야한다. C++의template은template로구현한것을n개의다른타입인자를이용하여 사용하면컴파일러는총n개의서로다른구현을내부적으로만들어사용한다. 모든언어가이와같은것은아니다. 자바는n개의다른타입인자를이용하더라도하나의구현만을사용하여처리한다. 파이썬은특정변수가특정 타입만저장할수있는것이아니므로C++나자바처럼template을이용하여범용자료구조를구현하지않는다. 파이썬은또실제성능을위해라이브러리에서제공하는자료구조는파이썬으로구현되어있지않고C와같은다른 언어로구현되어제공되는경우가대부분이다. \n\n앞서 언급한 바와 같이 자료구조의 내부 구현은 그것이 유지하는 타입과 무관하기 때문에 간단하게 정수를 저장하는 자료구조를 구현할 수 있으면 이를 쉽게 범용 자료구조로 변환할 수 있다.",
    "source": "ds01_3.1_자료구조-범용 자료구조",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "자료구조: 범용 자료구조",
      "section_number": "3.1",
      "section_heading": "## 3.1 범용 자료구조",
      "parent_section": "3. 자료구조",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0005"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2 자료구조의 종류 \n\n자료구조는다음과같은3가지기준을이용하여구분할수있다. \n\n• 기준 1. 선현 vs. 비선형: 선형 자료구조는 배열처럼 요소들이 선형으로 배치되어 한 요소의 앞 요소와 뒷 요소가 있으면 각 하나씩만 존재한다. 반면에 비선형 자료구조는 트리처럼 한 요소의 앞 요소나 뒷 요소가 여러 개 있을 수 있는 자료구조를 말한다. \n\n• 기준 2. 동질 vs. 비동질: 자료구조는 저장된 요소들이 논리적 또는 물리적으로 같은 타입이면 동질 자료구조라 하고, 그렇지 않으면 비동질 자료구조라 한다. \n\n• 기준 3. 정적 vs. 동적: 자료구조의 용량이 고정되어 있으면 정적 자료구조라 하고, 요소가 추가됨에 따라 용량이 늘어날 경우에는 동적 자료구조라 한다. \n\n라이브러리에서 제공되는 대부분의 자료구조는 동질 자료구조이며, 동적 자료구조이다. 동적 자료구조의 경우 현재 용량이 부족하여 용량을 확장할 경우 비용이 소요된다는 것을 알고 있어야 한다. 이 때문에 최종적으로 필요한 용량을 고려하여 사용할 자료구조를 선택하여야 하며, 자료구조를 사용할 때에도 효율성을 높이기 위해 필요한 용량을 미리 확보한 다음 사용하는 것이 바람직하다.",
    "source": "ds01_3.2_자료구조-자료구조의 종류",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "자료구조: 자료구조의 종류",
      "section_number": "3.2",
      "section_heading": "## 3.2 자료구조의 종류",
      "parent_section": "3. 자료구조",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0006"
  },
  {
    "type": "텍스트북",
    "text": "## 3.3 의사코드 \n\n이교재에서는특정언어를이용하여자료구조가제공하는연산의알고리즘을제시하지않고의사코드(pseudocode) 를이용하여제시한다. 주어진의사코드를각언어로실제구현할경우에는각언어의특성이다르기때문에각언 어마다구현하는방법이나고려해야하는것이달라질수있다. 이교재에서사용하는의사코드는파이썬코드와 유사하며, 파이썬과유사하게들여쓰기를통해코드블록을나타낸다. 또프로그래밍언어는보통0색인을사용하는 데, 의사코드를작성할때는1색인을사용한다. 필요에따라0색인을사용하는경우도있다. 이교재에서사용하는 의사코드는프로그래밍에익숙하면대부분쉽게이해할수있을것이다. 하지만다음의몇가지는제시된의사코드를 이해하기위해필요할것이다. \n\n● 上: 의미 없는 값 또는 널포인터를 나타낸다. \n\n● C++나 자바에서 사용한 3항 연산자로 구현될 수 있는 것은 다음과 같이 서술한다. \n\n1 a := if condition then b else c \n\n● allocate, free: 동적 생성과 반납을 나타낸다.",
    "source": "ds01_3.3_자료구조-의사코드",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "자료구조: 의사코드",
      "section_number": "3.3",
      "section_heading": "## 3.3 의사코드",
      "parent_section": "3. 자료구조",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0007"
  },
  {
    "type": "텍스트북",
    "text": "## 3.4 자료구조와 알고리즘 \n\n자료구조와 알고리즘은 매우 밀접한 관계를 가지고 있다. 어떤 문제를 해결하는 방법을 찾을 때, 그것을 해결할 때 사용해야 할 자료구조가 먼저 떠오르는 경우도 있고, 반대로 그것을 해결하기 위한 알고리즘이 먼저 떠오르는 경우도 있다. 전자의 경우에는 선택된 자료구조에 의해 알고리즘이 영향을 받을 수밖에 없으며, 후자의 경우에는 결정한 알고리즘에 적합한 또는 필요한 자료구조가 있을 수 있다. 따라서 보통 문제를 해결하기 위한 방법을 찾을 때 자료구조와 알고리즘을 함께 검토하고 설계해야 한다.",
    "source": "ds01_3.4_자료구조-자료구조와 알고리즘",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "자료구조: 자료구조와 알고리즘",
      "section_number": "3.4",
      "section_heading": "## 3.4 자료구조와 알고리즘",
      "parent_section": "3. 자료구조",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0008"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 알고리즘의 성능 분석 \n\n특정 문제를 해결하는 방법은 다양한 수 있다. 예를 들어 정수 배열이 주어졌을 때 중복된 값이 존재하는지 여부를 확인하는 문제를 해결하는 방법은 다양하다. 이 중에 3가지 방법이 그림 1.1에 제시되어 있다. 여기에 제시된 것 말고 또 다른 방법이 있을까? 개발자는 어떤 문제를 만나면 다음을 할 수 있어야 한다. \n\n● 이 문제를 해결하는 여러 방법을 생각해 낼 수 있어야 한다. \n\n● 생각해 낸 여러 방법 중 가장 효과적인 알고리즘을 선택할 수 있어야 한다. \n\n● 선택한 알고리즘을 정확하고 효율적으로 구현할 수 있어야 한다. \n\n또 개발자가 최종 결과에 만족하지 않고 끊임없이 자신의 해결책이나 코드를 개선하고 싶어야 한다. \n\n가장 효과적인 알고리즘이란 어떤 것일까? 보통 성능이 우수(수행시간이 빠른)한 것이 가장 효과적인 알고리즘 이라 한다. 하지만 보통 성능만 고려하지 않고 메모리 공간 요구사항을 함께 고려한다. 따라서 주어진 문제를 빠르게 해결할 수 있고, 메모리 공간도 적게 사용하는 알고리즘이 가장 효과적인 알고리즘이다. \n\n효과적인 알고리즘을 설계하고 구현하는 것이 쉬운 것은 아니며, 기술적인 이해도를 많이 요구한다. 하지만 개 발하는 응용에서 해결하는 문제의 범위가 제한적이면 성능이 중요하지 않을 수 있다. 이 경우에는 구현하기 쉽거나 가독성이 좋아 나중에 유지보수하는 것이 수월한 알고리즘이 더 효과적이거나 적합할 수 있다.\n\n\n1 containDuplicates(nums): \n\n2 for i:=1 to n-1 do \n\n3 for j:=1 to n do \n\n4 if nums[i]==nums[j] then return true \n\n5 return false \n\n(1) 전수 비교하기 방법 \n\n1 containDuplicates(nums): \n\n2 sort nums in ascending order \n\n3 for i:=2 to n do \n\n4 if nums[i-1]==nums[i] then return true \n\n5 return false \n\n(2) 정렬을 이용하는 방법 \n\n1 containDuplicates(nums): \n\n2 S := empty hash set \n\n3 for i:=1 to n-1 do \n\n4 if S contains nums[i] then return true \n\n5 add nums[i] to S \n\n6 return false \n\n(3) 집합 자료구조를 이용하는 방법 \n\n<그림 1.1> 중복 존재 여부를 검사하는 다양한 방법",
    "source": "ds01_4_알고리즘의 성능 분석",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석",
      "section_number": "4",
      "section_heading": "## 4. 알고리즘의 성능 분석",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0009"
  },
  {
    "type": "텍스트북",
    "text": "## 4.1 비O \n\n알고리즘의 성능은 주어진 문제를 해결하는데 걸리는 실제 시간을 측정하여 분석하지 않는다. 실행 시간은 구현한 개발자의 숙련도, 구현한 프로그래밍 언어, 실행된 컴퓨팅 환경 등에 영향을 받기 때문에 이를 이용하여 알고리즘을 비교하는 것은 정확하지 않다. 따라서 알고리즘 자체를 객관적으로 상호 비교할 수 있는 기준이 필요하다. 일반적으로 알고리즘의 성능을 분석하기 위해 가장 많이 사용하는 방법은 주어진 입력에 따라 알고리즘이 수행해야 하는 각종 기본 연산의 수를 계산하는 것이다. 여기서 기본 연산이란 더 이상 세부적으로 나누어지지 않는 대입 연산, 산술 연산, 비교 연산 등을 말한다. \n\n실제 각 연산의 수행 속도는 연산마다 같을 수 없다. 하지만 우리가 비교하고자 하는 것은 전혀 다른 문제를 해결하는 알고리즘을 비교하는 것이 아니라 같은 문제를 해결하는 알고리즘을 비교하는 것이다. 같은 문제를 해결하는 알고리즘은 보통 비슷한 기본 연산을 사용하며, 성능에 가장 많은 영향을 주는 기본 연산은 같은 연산일 확률이 높다. \n\n다음과 같이 1차원 배열에 특정 값으로 초기화하는 함수가 있다고 하자. \n\n1 fill(nums, v): \n\n2 for i:=1 to n do \n\n3 nums[i] = v; \n\n이 함수의 성능은 각 언어의 특성에 영향을 받는다. C/C++ 언어로 구현하였고, 전통 for문을 이용한다고 가정하여 보자. 그러면 배열의 크기가 n일 때, 제어변수 i를 1번 초기화하고, i를 n과 n+1번 비교하며, i를 n번 증가한다. 또 n번의 대입 연산이 실행된다. 따라서 총 1+n+1+n+n = 3n+2번의 기본 연산 수행이 필요하다. 참고로 알고리즘 구현에 반복문이 있을 경우에는 반복문이 복잡도 결정에 매우 큰 역할을 한다. \n\n이와 같은 방식을 이용하여 알고리즘 A와 B가 필요한 연산 수행 횟수를 계산하였더니 A는 5n²+1이 필요하였고, B는 3000n+100이 필요하였다. 특정 n에 대해 두 알고리즘을 비교하면 표 1.1과 같다. 따라서 600정도까\n\n\n지는 A가 우수하지만 그 이후는 B가 우수하며, n이 크면 클수록 그 차이가 커지며, n이 매우 클 경우에는 계수나 상수항은 두 알고리즘을 비교할 때 큰 의미가 없다. 참고로 알고리즘의 필요한 연산의 수행 횟수를 나타내는 식에서 계수나 상수항은 컴퓨팅 환경, 프로그래밍 언어, 구현 결과에 따라 다를 수 있다. \n\n<표 1.1> 알고리즘 비교: \\(A: 5n^2 + 1\\), \\(B: 3000n + 1\\) \n\n<table><tr><td>n</td><td>A</td><td>B</td></tr><tr><td>100</td><td>50,001</td><td>300,100</td></tr><tr><td>1,000</td><td>5,000,001</td><td>3,000,100</td></tr><tr><td>10,000</td><td>500,000,001</td><td>30,000,100</td></tr><tr><td>100,000</td><td>50,000,000,001</td><td>300,000,100</td></tr></table>\n\n빅O는 알고리즘의 시간 복잡도와 공간 복잡도를 나타낼 때 사용하는 표기법이다. 빅O는 최악의 경우에 대한 분석이며, **접근적**(asymptotic) 분석이다. 여기서 접근적 분석이란 입력 크기가 충분히 클 경우에만 의미가 있는 분석을 말한다. 접근적 분석을 하는 이유는 보통 입력 크기가 작으면 알고리즘 성능의 차이가 무의미하기 때문이다. 빅O는 주어진 알고리즘의 성능이 특정 표준 복잡도와 같거나 빠르다는 것을 나타내기 위해 사용한다. \n\n알고리즘의 시간 복잡도에 대한 빅O를 계산하기 위해 가장 먼저 해야 하는 것은 알고리즘의 서술이나 구현 결과를 토대로 최악의 경우 입력 크기에 따라 필요한 기본 연산 수를 파악하는 것이다. 이를 바탕으로 입력 크기 \\(n\\)에 대한 다항식 \\(T(n)\\)으로 알고리즘 수행에 필요한 기본 연산 수를 정의해야 한다. 다항식을 확보하면 이 다항식에서 최고차 항을 제외한 나머지 항은 제거하고, 최고차 항의 계수도 제거하여 얻은 다항식이 이 알고리즘의 빅O가 된다. 이렇게 나머지 항과 계수를 제거하여도 상관이 없는 이유는 이들은 보통 구현 방법에 따라 달라질 수 있고, 입력 크기가 커지면 최고차 항이 다른 것을 압도하기 때문이다. 즉, 알고리즘을 상호 비교할 때는 최고차 항만으로 충분 하기 때문이다. 하지만 두 알고리즘의 최고차 항이 같으면 제거한 계수와 항들을 함께 고려해야 어느 것이 더 우수한 알고리즘인지 판단할 수 있다. 앞서 살펴본 예에서 알고리즘 \\(A\\)의 \\(T(n) = 5n^2 + 1\\)이고, \\(B\\)의 \\(T(n) = 3000n + 1000\\)이면 알고리즘 \\(A\\)의 빅O는 \\(O(n^2)\\)이고, 알고리즘 \\(B\\)의 빅O는 \\(O(n)\\)이 된다. 빅O 기준에 의하면 \\(B\\)가 더 우수한 복잡도를 가진 알고리즘이다. \n\n빅O는 알고리즘 복잡도의 상한(upper-bound)이라고 한다. 그것보다는 좋다라는 의미에서 상한이다. 입력 크기에 대한 필요한 연산 수를 그래프로 나타내면 주어진 알고리즘의 그래프는 그 알고리즘을 나타내는 빅O의 그래프와 같거나 아래에 위치한다는 것을 말한다. 아래에 위치한다는 것은 입력 크기의 증가에 따라 증가 속도가 느리다는 것을 말하며, 느리다는 것은 수행 속도가 빠르다는 것을 의미한다. 이 때문에 알고리즘 \\(A\\)의 빅O가 \\(O(n^2)\\)이면 \\(O(n^3)\\), \\(O(n^4)\\)이라고 하여도 틀린 것은 아니다. 하지만 \\(A\\)를 \\(O(n^3)\\), \\(O(n^4)\\)이라고 하는 것은 의미가 없기 때문에 보통 최소 상한으로 표현한다. \n\n이 측면에서는 상한이 아니라 하한을 찾아 하한을 이용하여 분석하는 것이 더 정확하다고 생각할 수 있는데, 제시된 하한보다 실제 알고리즘 성능은 매우 느릴 수 있기 때문에 하한 역시 알고리즘의 정확한 성능을 대표하지는 못할 수 있다.. 알고리즘 시간 복잡도의 하한을 나타낼 때에는 빅O 대신에 빅O를 사용하며, 상한과 하한이 일치하는 경우에는 빅O를 이용하여 표현한다. \n\n그림 1.1에 제시된 3가지 알고리즘의 빅O를 계산하여 보자. 첫 번째 알고리즘은 이중 **for** 문으로 구성되어 있고, 최악의 경우 \\(n-1, n-2, \\dots, 1\\)번 비교가 필요하다. 따라서 총 \\(n(n-1)/2\\)번의 비교가 필요하기 때문에 빅O는 \\(O(n^2)\\)이다. 두 번째 알고리즘은 정렬한 후에 최대 \\(n-1\\)번의 비교가 필요하다. 가장 효과적인 정렬 알고리즘의 빅O가 \\(O(n \\log n)\\)이므로 빅O는 \\(O(n \\log n)\\)이다. 세 번째 알고리즘에서 집합 자료구조에 데이터를 삽입하는 비용이 상수비용이면 **for** 문이 \\(n\\)번 반복하는 동안 상수 비용만 발생한다. 따라서 빅O는 \\(O(n)\\)이다.",
    "source": "ds01_4.1_알고리즘의 성능 분석-비O",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: 비O",
      "section_number": "4.1",
      "section_heading": "## 4.1 비O",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0010"
  },
  {
    "type": "텍스트북",
    "text": "### 4.1.1 입력 크기 \n\n그림 1.1에 제시된 알고리즘의 빅O를 계산할 때 입력 크기 \\(n\\)을 배열의 크기로 설정하여 계산하였다. 다음과 같이 주어진 정수가 소수인지 판단하는 알고리즘에서 입력 크기는 어떻게 될까? \n\n1. isPrime(x): \n\n2. for i:=2 to sqrt(n) do \n\n3. if x%i==0 then return false \n\n4. return true \n\n하나의 정수를 입력으로 받고 있기 때문에 입력 크기가 1이라고 생각할 수 있다. 하지만 입력 크기가 1이라고 하면 정수 값 \\(x\\)에 따라 필요한 연산 수의 차이를 분석할 수 없다. 이 알고리즘은 최악의 경우 \\(\\sqrt{x}\\)번 반복을 하기 때문에 이를 알고리즘 분석에 적용해야 한다. 따라서 이 알고리즘을 분석하기 위해서는 정확한 빅O 계산법을 적용해야 한다. \n\n실제 빅O에서 입력의 크기는 그 입력을 컴퓨터에 표현하기 위한 문자 수이다. 컴퓨터에서 정수는 보통 2의 보수법을 이용하여 이진 데이터로 표현한다. 정수 \\(x\\)가 주어졌을 때, 이 정수를 나타내기 위한 비트 수는 약 \\(\\log_2 x\\) 이다. 따라서 이 문제의 입력 크기 \\(n \\approx \\log_2 x\\)가 필요하다. 이 알고리즘은 주어진 \\(x\\)에 대해 최악의 경우 \\(x^{1/2}\\) 연산이 필요하다. 입력 크기 \\(n \\approx \\log_2 x\\)이므로 \\(x \\approx 2^n\\)이다. 이것을 \\(x^{1/2}\\)에 적용하면 이 알고리즘의 \\(T(n) = 2^{n/2}\\)이다. 따라서 isPrime 알고리즘의 빅O는 \\(O(2^n)\\)이다. \n\n참고로 isPrime 알고리즘에 적용한 분석 방법을 배열의 크기가 입력인 알고리즘에 적용하여도 이전 분석 결과와 동일한 분석 결과를 얻게 된다. 예를 들어 다음과 같은 선형 검색 알고리즘을 생각하여 보자. 선형 검색 알고리즘은 최악의 경우 배열의 크기만큼 비교가 필요하므로 빅O는 \\(O(n)\\)이다. \n\n1. find(list, v): \n\n2. for i:=1 to n do \n\n3. if list[i]==v then return false \n\n4. return true \n\n이 알고리즘은 배열의 크기가 \\(k\\)일 때 최악의 경우 필요한 연산 수는 \\(3k+2\\)라 가정하자. 각 배열의 요소가 32비트이면 정확한 입력 크기 \\(n = 32k\\)이다. \\(k = \\frac{n}{32}\\)를 \\(3k+2\\)에 적용하면 이 알고리즘의 \\(T(n) = \\frac{3}{32}n + 2\\)이므로 이 알고리즘의 시간 복잡도는 정확한 입력 크기를 고려하더라도 여전히 \\(O(n)\\)이다.",
    "source": "ds01_1.1_알고리즘의 성능 분석-### 4.1.1 입력 크기",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: ### 4.1.1 입력 크기",
      "section_number": "1.1",
      "section_heading": "### 4.1.1 입력 크기",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0011"
  },
  {
    "type": "텍스트북",
    "text": "### 4.1.2 다중 변수 빅O \n\n지금까지 살펴본 알고리즘은 알고리즘의 성능이 하나의 입력에 대해서만 영향을 받는다. 하지만 알고리즘 중 여러 입력에 영향을 받는 경우도 있다. 특히, 비선형 구조인 그래프 관련 알고리즘은 보통 노드 수와 간선 수에 모두 영향을 받는다. 예를 들어 노드 수가 \\(n\\)이고 간선 수가 \\(m\\)인 그래프에 대한 깊이 우선 탐색 알고리즘의 빅O는 \\(O(m+n)\\)이다. 하나의 변수에만 영향을 받는 빅O는 표준 복잡도에 따라 어느 복잡도에 해당하는지 알기 쉽지만 다중 변수는 그것을 판단하는 것이 간단하지 않다. 하지만 알고리즘 분석은 같은 문제를 해결하는 알고리즘을 서로 비교하는 것이 목표이기 때문에 같은 다중 변수를 사용하여 표현된 빅O를 서로 비교하는 것이 어렵지 않다. 예를 들어 빅O가 \\(O(m+n)\\), \\(O(mn)\\), \\(O(m\\log n)\\)인 3개 알고리즘이 있으며 이 중 가장 우수한 것은 빅O가 \\(O(m+n)\\)인 알고리즘이고, 그다음 \\(O(m\\log n)\\)인 알고리즘이라는 것은 쉽게 파악할 수 있다. \n\n다중 변수 빅O에서 하나의 변수를 다른 변수로 표현하여 단일 변수 빅O로 분석하는 경우도 있다. 예를 들어 그래프에서 노드가 \\(n\\)이고, 간선 수가 \\(m\\)일 때, \\(m\\)이 최대 \\(n^2\\)개가 있을 수 있다면 최악의 경우를 분석하기 때문에 \\(O(mn)\\) 복잡도를 \\(O(n^3)\\)으로 바꾸어 표현할 수 있다. 하지만 다중 변수에 영향을 받는 알고리즘인 경우에는 모든\n\n\n1 reverse(x): \n\n2 rev := 0 \n\n3 negative := (x<0) \n\n4 if negative then x = -x; \n\n5 while x>0 do \n\n6 rev = rev*10+(x%10) \n\n7 x /= 10 \n\n8 return rev \n\n<그림 1.2> 정수 뒤집기 알고리즘 \n\n변수가 나타나도록 빅O를 표현하는 것이 더 많은 정보를 주기 때문에 단일 변수로 바꾸는 것보다 다중 변수를 사용하여 나타내는 것이 더 바람직하다.",
    "source": "ds01_1.2_알고리즘의 성능 분석-### 4.1.2 다중 변수 빅O",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: ### 4.1.2 다중 변수 빅O",
      "section_number": "1.2",
      "section_heading": "### 4.1.2 다중 변수 빅O",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0012"
  },
  {
    "type": "텍스트북",
    "text": "## 4.2 최선, 평균, 최악 \n\n알고리즘에 따라 항상 소요되는 시간이 동일한 경우도 있고, 입력 데이터에 따라 소요되는 시간이 매우 상이 한 경우도 있다. 예를 들어 그림 1.2에 주어진 정수를 뒤집는 알고리즘은 정수 크기에 따라 항상 일정한 비용이 소요된다. 참고로 제시된 알고리즘을 특정 언어로 구현할 때는 오버플로우 등 여러 예외적 상황을 고려해야 한다. \n\n이 알고리즘도 앞서 살펴본 isPrime과 마찬가지로 입력 크기를 표현하기 위한 문자 수를 고려해야 한다. 그러나 내부 알고리즘을 보면 10진수 기반 알고리즘이다. 즉, 주어진 정수가 10진수로 표현하였을 때 몇 자리로 표현되는 정수인지에 따라 해당 자리수만큼 while문이 반복된다. 따라서 시간 복잡도 \\(W(x) = \\log_{10} x = \\log_{10} 2^n = n \\log_{10} 2\\) 이다. 그러므로 reverse의 빅O는 \\(O(n)\\)이다. \n\n입력 데이터에 따라 소요되는 비용이 다를 수 있는 정렬되어 있지 않는 리스트에서 특정 요소를 찾는 선형 검색을 생각하여 보자. 이 경우 찾고자 하는 것이 첫 번째 요소인 경우에는 알고리즘이 바로 종료하며, 찾고자 하는 것이 리스트에 없으면 모든 요소와 다 비교한 후에 종료한다. 따라서 이 알고리즘은 최선의 경우에는 한 번 비교로 끝나지만 최악의 경우에는 입력 데이터 크기에 비례한 비용이 소요된다. 따라서 이 알고리즘의 최악의 경우 시간 복잡도는 \\(O(n)\\)이다. 최선과 최악의 경우 비용이 매우 상이할 경우 알고리즘의 더 정확한 성능을 분석하기 위해 평균 비용을 계산할 수 있다. \n\n평균 비용을 계산하는 것은 간단하지 않다. 모든 가능한 입력을 고려해야 하며, 입력의 분포를 알아야 하기 때문이다. n개 리스트가 주어졌을 때 리스트에 있는 요소를 검색할 확률이 p라 하자. 그리고 리스트에 있는 각 요소를 검색할 확률은 같다고 가정하면 선형 검색의 평균 비용은 다음과 같다. \n\n\\[A(n) = p \\times \\frac{\\sum_{i=1}^{n} i}{n} + (1-p)n\\]\n\n만약 \\(p = 1/2\\)이면 \\(A(n) = (n+1)/4 + n/2 = (3n+1)/4\\)이다. 따라서 평균 비용의 시간 복잡도도 \\(O(n)\\)이다. \n\n보통 알고리즘을 분석할 때 최선의 경우는 알고리즘 성능을 논할 때 아무런 의미가 없을 수 있고, 평균 비용은 계산하기가 매우 어려울 수 있다. 또 위의 선형 검색처럼 평균 비용과 최악의 경우 비용이 같은 경우도 많다. 이 때문에 보통 최악의 경우만을 고려한다.",
    "source": "ds01_4.2_알고리즘의 성능 분석-최선, 평균, 최악",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: 최선, 평균, 최악",
      "section_number": "4.2",
      "section_heading": "## 4.2 최선, 평균, 최악",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0013"
  },
  {
    "type": "텍스트북",
    "text": "## 4.3 공간 복잡도 \n\n알고리즘의 공간 복잡도는 입력 크기와 알고리즘이 추가로 사용하는 공간의 크기를 합하여 분석한다. 하지만 같은 문제를 해결하는 알고리즘은 같은 크기의 입력을 받기 때문에 공간 복잡도가 우수한 알고리즘은 추가로 사용하는\n\n\n공간이 적은 알고리즘이 된다. 앞서 살펴본 중복 찾기 문제에서 전수조사하는 방법이나 정렬을 이용하는 방법은 추가 공간을 전혀 사용하지 않지만 집합 자료구조를 사용하는 방법은 집합 자료구조의 크기만큼 추가 공간을 사용한다. 보통 추가 공간을 사용하지 않는 알고리즘을 제자리(in-place) 알고리즘이라 한다. \n\n재귀 호출을 이용하여 문제를 해결하는 알고리즘은 재귀 호출의 깊이에 의해 만들어지는 스택 공간도 공간 복잡도에 포함하여 분석해야 한다. 예를 들어 다음과 같이 1부터 n까지 곱을 구하는 재귀함수의 공간 복잡도를 생각하여 보자. \n\n1 factorial(n): \n\n2 if n==1 then return n \n\n3 else return n*factorial(n-1) \n\n이 함수의 스택 공간의 크기는 매개 변수 n 하나이므로 입력 크기와 무관하게 일정하다. 따라서 이 함수가 실행될 때 공간을 가장 많이 사용한 시점은 n번 재귀호출이 일어난 시점이 이며, 사용한 공간은 재귀 호출 깊이에 비례한다. 따라서 이 알고리즘의 공간 복잡도는 O(n)이다.",
    "source": "ds01_4.3_알고리즘의 성능 분석-공간 복잡도",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: 공간 복잡도",
      "section_number": "4.3",
      "section_heading": "## 4.3 공간 복잡도",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0014"
  },
  {
    "type": "텍스트북",
    "text": "## 4.4 알고리즘 복잡도 분류 \n\n<표 1.2> 알고리즘 복잡도 비교 \n\n<table><tr><td>log n</td><td>n</td><td>n log n</td><td>n<sup>2</sup></td><td>2<sup>n</sup></td></tr><tr><td>1</td><td>2</td><td>2</td><td>4</td><td>4</td></tr><tr><td>2</td><td>4</td><td>8</td><td>16</td><td>16</td></tr><tr><td>3</td><td>8</td><td>24</td><td>256</td><td>65,536</td></tr><tr><td>5</td><td>32</td><td>160</td><td>1,024</td><td>4,294,967,296</td></tr><tr><td>8</td><td>256</td><td>2,048</td><td>65,536</td><td>don't ask</td></tr></table>\n\n표 1.2에서 알 수 있듯이 입력 크기가 작으면 복잡도의 차이가 크지 않다. 하지만 입력 크기 커지면 그 차이가 무시할 수 없을 정도로 커진다. 빅O는 접근적 분석으로 입력 크기가 클 경우에만 의미가 있는 분석이다. \n\n알고리즘에 대한 빅O 분석하였을 때 자주 접하게 되는 표준 복잡도는 다음과 같다. \n\n- O(1): 상수 시간(constant time) 비용이 소요되는 알고리즘의 복잡도이다. 예를 들어 배열 끝에 요소를 추가 하고 삭제하는 것은 배열에 있는 요소의 개수와 무관하며 마지막 위치는 바로 접근할 수 있기 때문에 여기에 해당한다. \n\n- O(log n): 로그 시간(logarithmic time) 비용이 소요되는 알고리즘의 복잡도이다. 이진 검색처럼 보통 한 번에 처리해야 하는 양이 반복 줄어들면 여기에 해당한다. \n\n- O(n): 선형 시간(linear time) 비용이 소요되는 알고리즘의 복잡도이다. 정렬되어 있지 않는 배열에서 특정 요소를 찾는 비용은 선형 시간 비용이 소요된다. \n\n- O(n log n): 의사선형 시간(quasilinear time) 비용이 소요되는 알고리즘의 복잡도이다. 가장 빠른 정렬 알고리즘들이 의사선형 시간 비용이 소요된다. \n\n- O(n<sup>2</sup>): 이차 시간(quadratic time) 비용이 소요되는 알고리즘의 복잡도이다. 선택 정렬과 같은 일반적인 정렬 알고리즘들이 이차 시간 비용이 소요된다. \n\n- O(2<sup>n</sup>): 지수 시간(exponential time) 비용이 소요되는 알고리즘의 복잡도이다.\n\n\n\\(O(n)\\)을 포함하여 \\(O(2^n)\\)보다 작은 시간이 소요되는 알고리즘을 다차 시간(polynomial time) 비용이 소요되는 알고리즘이라 하며, \\(O(2^n)\\)보다 더 느린 복잡도가 \\(O(n!)\\)인 계승 시간(factorial time) 비용이 요구되는 알고리즘도 있다.",
    "source": "ds01_4.4_알고리즘의 성능 분석-알고리즘 복잡도 분류",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: 알고리즘 복잡도 분류",
      "section_number": "4.4",
      "section_heading": "## 4.4 알고리즘 복잡도 분류",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0015"
  },
  {
    "type": "텍스트북",
    "text": "## 4.5 알고리즘의 선택 \n\n개발자는 주어진 문제를 해결할 수 있는 알고리즘을 고안해 낼 수 있어야 한다. 하지만 문제의 종류와 특성에 따라 그것을 해결하는 알고리즘을 찾는 것이 어려울 수 있다. 한 가지 방법을 찾았으면 그것에 만족하지 말고 찾은 방법보다 더 효과적인 방법은 없는지 검토할 필요가 있다. 주어진 문제를 해결하는 여러 개의 알고리즘을 찾았다고 하자. 그러면 개발자는 이 알고리즘 중에 어떤 알고리즘을 사용하는 것이 가장 효과적인 판단할 수 있어야 한다. 보통 시간 복잡도와 공간 복잡도가 모두 우수한 알고리즘을 선택하는 것이 일반적이다. \n\n빅O 분석은 최악의 경우에 대한 분석이며, 입력 데이터의 크기가 매우 클 경우에만 의미가 있다. 따라서 처리해야 하는 입력 데이터의 크기가 제한적인 경우에는 빅O가 더 느린 알고리즘이 더 효과적일 수 있다. 따라서 알고리즘을 적용할 응용의 특성을 고려하여 알고리즘을 선택할 필요가 있다. 또 성능이 좋지 않지만 문제를 확실히 해결할 수 있는 알고리즘은 테스트 용으로 활용할 수 있다. 새롭게 고안한 알고리즘이 이 알고리즘과 작은 입력 크기의 데이터에 대해 같은 결과를 주는지 비교함으로써 새 알고리즘의 정확성을 검사할 수 있다. \n\n주어진 문제를 효과적으로 해결하는 알고리즘 자체를 찾지 못한 경우에는 어떻게 해야 하나? 최적의 답을 꼭 찾을 필요가 없는 응용의 경우에는 최적의 답을 주지 않지만 효과적인 알고리즘을 대신 사용할 수 있다. 이 경우에도 사용하는 알고리즘이 최적의 답과 비교하여 얼마나 차이가 나는 답을 주는지 알 수 있어야 사용할 수 있다. 효과적인 알고리즘을 찾는 능력을 향상하기 위해서는 많은 훈련이 필요하다. \n\n## 연습문제 \n\n1. 다음에 주어진 알고리즘은 선택 정렬 알고리즘이다. \n\n1. selectionSort(numss):\n2. for i:=1 to n-1 do\n3. minLoc := i;\n4. for j:=i+1 to n do\n5. if numss[minLoc]>numss[j] then minLoc := j;\n6. swap numss[i] with numss[minLoc] \n\n이와 관련하여 다음 각각에 대해 답변하시오. \n\n① 이 알고리즘은 같은 크기의 입력이더라도 numss의 내용에 따라 필요한 연산 비용이 달라진다. 실제 같은 크기의 입력에 대해 연산 비용이 달라지는 부분은 한 곳이다. 그 부분을 제시하시오. \n\n② \n\n③ 이것을 바탕으로 최선의 경우와 최악의 경우를 설명하시오.",
    "source": "ds01_4.5_알고리즘의 성능 분석-알고리즘의 선택",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제1장 자료구조 개요",
      "section": "알고리즘의 성능 분석: 알고리즘의 선택",
      "section_number": "4.5",
      "section_heading": "## 4.5 알고리즘의 선택",
      "parent_section": "4. 알고리즘의 성능 분석",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0016"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 프로그래밍 언어와 자료구조 \n\n특정 언어를 이용하여 자료구조를 구현할 때 각 언어의 특성 때문에 주의할 점이 다르며, 구현하는 방법에 차이가 있을 수 있다. 이 장에서는 C++, 자바, 파이썬 3가지 언어를 이용하여 자료구조를 구현할 때 어떤 점이 다른지 구체적으로 살펴본다. 또 각 언어별로 유의할 점과 알아두면 유용한 점을 설명한다. 이 교재에서는 알고리즘을 서술할 때 의사코드를 이용하지만 이 장은 각 언어의 차이를 살펴보는 것이므로 실제 코드를 통해 비교를 한다. 이를 위해 스택이라는 LIFO(Last-In-First-Out) 방식의 자료구조를 구현해 본다.",
    "source": "ds02_1_프로그래밍 언어와 자료구조",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "프로그래밍 언어와 자료구조",
      "section_number": "1",
      "section_heading": "## 1. 프로그래밍 언어와 자료구조",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0017"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 스택 자료구조의 구현 \n\n구현하는 스택 자료구조는 내부적으로 배열을 이용하여 구현한다. 파이썬은 배열 대신에 리스트를 이용하여 구현한다. 파이썬은 실제 리스트 자체가 자료구조이므로 스택 자료구조를 별도 만들어 사용하지 않고 리스트를 스택으로 활용하면 된다. 하지만 자료구조의 내부 구현 원리를 이해하기 위해 파이썬도 다른 언어와 유사하게 자료구조를 구현해 본다. \n\n구현하는 스택 자료구조는 동적 자료구조이다. 동적 자료구조란 공간이 부족하면 공간을 추가로 확보하여 계속 데이터를 저장할 수 있도록 해주는 자료구조이다. 또 구현하는 스택 자료구조는 범용 자료구조로 구현한다. 특정 데이터 타입만 저장할 수 있는 것이 아니라 어떤 타입의 데이터도 저장할 수 있도록 구현한다.",
    "source": "ds02_2_스택 자료구조의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현",
      "section_number": "2",
      "section_heading": "## 2. 스택 자료구조의 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0018"
  },
  {
    "type": "텍스트북",
    "text": "### 2.1 멤버 변수와 생성자 \n\n1. template <typename T>\n2. class Stack{\n3. private:\n4.    size_t capacity;\n5.    size_t top{0};\n6.    T* buf{nullptr};\n7. public:\n8.    Stack(size_t capacity=0): capacity{capacity}{\n9.    if(capacity>0) buf = new T{capacity};\n10.    }\n11. };\n\n\n1 public class Stack<T>{ 2 private int capacity = 0; 3 private int top = 0; 4 private T[] buf = null; 5 public Stack() {} 6 @SuppressWarnings(\"unchecked\") 7 public Stack(int capacity){ 8 if(capacity<0) throw new RuntimeException(\"init: capacity<=0\"); 9 this.capacity = capacity; 10 buf = (T[])new Object[capacity]; 11 } 12 } \n\n<그림 2.2> 자바 배열 기반 스택 자료구조 \n\n1 class Stack: 2 def init (self, capacity: int=0): 3 if capacity<0: raise RuntimeException('init: capacity<0') 4 self.capacity = capacity 5 self.top = 0 6 self.buf = [None]*self.capacity if self.capacity>0 else None \n\n<그림 2.3> 파이썬 배열 기반 스택 자료구조 \n\n각 언어를 이용한 스택 자료구조 맵버 변수의 선언과 생성자의 정의를 비교하여 보자. C++와 자바는 각 언어의 template 기능을 이용하여 범용 자료구조를 그림 2.1과 그림 2.2처럼 정의한다. 하지만 파이썬은 오리 타이핑(duck typing)¹이므로 template 기능을 제공하지 않는다. 오리 타이핑을 다른 말로 동적 타이핑이라 한다. 파이썬을 이용 한 구현은 보통 그림 2.3처럼 구현한다. 이와 같이 구현하면 동질 자료구조가 보장되지 않을 수 있다. 따라서 C++ 와 자바처럼 동질 자료구조가 항상 충족되도록 제한하고 싶으면 그림 2.4와 같이 구현하여 객체를 생성할 때 타입 정보를 받고, 이 타입 정보를 이용해 데이터를 추가할 때 데이터가 같은 타입인지 검사해야 한다. 이와 같은 방법을 사용하지 않고 타입 힌트 모듈을 이용할 수 있지만 별도 도구를 이용하여 문법 검사를 해야 한다. 하지만 문법 검사 결과를 무시하고 사용할 수 있으므로 실제 동질 구조가 보장되는 것은 아니다. \n\nC++에서 정수형은 부호가 없는 정수형을 선언할 수 있으며, 각 컴퓨팅 환경마다 각 타입의 크기가 달라질 수 있으므로 배열의 용량을 나타내는 변수나 배열 색인 변수의 타입으로 size_t를 주로 사용한다. size_t는 sizeof 연산자의 평가 결과 타입이며, 해당 컴퓨팅 환경에서 배열을 포함하여 모든 타입의 가장 큰 크기를 유지할 수 있는 타입이다. size_t는 부호가 없는 정수기 때문에 생성자에서 capacity 매개 변수에 음수가 전달될 수 없다. 실제 음수가 전달되면 매우 큰 양의 정수로 바뀌게 된다. 이와 같은 문제 때문에 생성자의 매개 변수 타입은 size_t를 사용하지 않고 부호가 있는 타입을 이용하고 예외를 검사하는 방법으로 생성자를 구현할 수 있다. \n\n자바와 파이썬은 부호가 없는 정수 타입이 별도 없으므로 int 타입을 사용한다. 실제 자바에서 허용하는 배열의 최대 용량은 2³¹ – 1이므로 배열의 용량을 지정하기 위해 long 타입을 사용할 수 없다. \n\n자바는 타입 매개변수를 사용하는 맵버 변수를 new를 이용하여 생성할 수 없다. 이것은 어떤 타입 인자가 주 어졌을 때 해당 타입 인자가 어떤 종류의 생성자를 가지고 있을지 알 수 없기 때문이다. 타입 매개변수를 사용하는 배열도 마찬가지이다. 따라서 그림 2.2처럼 Object 배열을 생성하고, 그것을 타입 변환하는 방법으로 구현하게 된다. 이때 경고가 발생하므로 이 경고를 무시하기 위해 @SuppressWarning을 사용할 수 있다. 실제 타입 erasure 과정 때문에 실제 타입 변환이 일어나지 않을 수 있지만 이와 같은 형태로 구현해야 가장 편리하다. \n\nC++와 파이썬은 기본 인자 기능이 있으므로 여러 개의 생성자를 정의하지 않고 필요한 기능의 생성자를 제공\n\n\n1 class Stack: \n\n2 def __init__(self, T: type, capacity: int=0): \n\n3 self.T = T \n\n4 # \n\n5 def push(self, item): \n\n6 if not isinstance(item, self.T): \n\n7 raise TypeError('This stack can only store type {self.T}') \n\n8 # \n\n<그림 2.4> 파이썬: 저장하는 타입 제한 \n\n할 수 있지만 자바는 기본 인자 기능이 없으므로 다른 언어와 상대적으로 더 많은 수의 생성자를 정의해야 한다. 파이썬은 동적 타이핑이므로 함수의 다중 정의를 제공하기 근본적으로 어렵다. 하지만 기본 인자 외에 가변 인자, 키워드 인자를 이용해 다중 정의하는 것과 비슷한 효과를 나타낼 수 있다. \n\n반면에 C++는 클래스가 동적할당하는 포인터 타입의 멤버 변수가 있으면 빅5(소멸자, 복사 생성자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자)를 정의해 주어야 한다. 자바는 복제 기능을 제공할 경우에는 clone를 재정의해 주어야 한다. 파이썬은 복제 기능이 필요하면 copy 모듈의 copy나 deepcopy를 이용하면 된다. \n\nC++에서 빅5을 정의할 때 코드 중복을 줄이기 위해 많이 사용하는 방법은 그림 2.5처럼 swap 메소드를 정의 하고 이를 이용하여 copy-and-swap 이더업(idion)을 활용하는 것이다. 복사 대입 연산자도 그림 2.5처럼 정의하지 않고 값 전달로 매개변수를 정의하는 방법도 있다. 이와 같이 하면 코드를 더 간결하게 정의할 수 있지만 this와 other이 같은 경우에 대한 최적화를 할 수 없다. \n\ncopy-and-swap 이더업을 사용하면 대입 연산자의 다중 정의에 코드 중복을 제거할 수 있으며, 예외 발생 위치를 제한할 수 있는 이점도 있다. 특히, 복사 대입 연산자에서 임시 객체를 생성하는 과정에서 예외가 발생하더라도 this 객체에는 영향을 주지 않도록 코드를 구성할 수 있다. 여기서 swap, 이동 생성자, 이동 대입 연산자는 모두 예외가 발생할 수 없는 noexcept 메소드이다.",
    "source": "ds02_2.1_스택 자료구조의 구현-### 2.1 멤버 변수와 생성자",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: ### 2.1 멤버 변수와 생성자",
      "section_number": "2.1",
      "section_heading": "### 2.1 멤버 변수와 생성자",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0019"
  },
  {
    "type": "텍스트북",
    "text": "2.2 초깃값 목록 \n\nC++는 std::initializer_list를 이용하여 그림 2.6과 같이 초깃값 목록을 받는 생성자를 쉽게 정의할 수 있다. 이와 같은 생성자를 정의하면 다음과 같이 스택 객체를 초깃값 목록을 주어 생성할 수 있다. \n\nStack<int> stack{1,2,3,4,5,6,7,8}; \n\n이와 같이 초깃값 목록을 받는 생성자를 정의할 경우 중괄호를 이용한 초기화는 이 생성자를 우선하기 때문에 용량을 주어 객체를 생성하고자 하면 괄호를 이용한 초기화를 해야 올바른 생성자가 호출된다. 예를 들어 다음에서 vec1은 초깃값 목록을 이용하는 생성자를 사용하며, 용량과 크기가 모두 2이고, 첫 번째와 두 번째 요소가 5와 1로 초기화된다. 반면에 vec2는 용량과 크기가 모두 5이고, 모든 요소가 1로 초기화된다. \n\n1 std::vector<int> vec1{5, 1}; \n\n2 std::vector<int> vec2{5,1}; \n\n이와 같은 문제는 타입 인자로 정수를 사용할 때만 발생한다. \n\n자바는 그림 2.7와 같은 가변 인자를 받는 생성자를 정의하여 초깃값 목록을 생성자를 호출할 때 나열할 수 있도록 할 수 있다. 자바에서 가변 인자는 내부적으로 배열로 처리하기 때문에 초깃값 목록을 나열하는 대신에 배열을 인자로 전달할 수 있는 이점도 있다. 하지만 자바는 원시 타입을 타입 인자로 사용할 수 없으므로 원시 타입 배열을\n\n\n1 virtual ~Stack(){ 2 delete [] buf; 3 } 4 5 Stack(const Stack& other): 6 capacity{other.capacity}, top{other.top}, buf{new T[capacity]}{ 7 std::copy(other.buf, other.buf+capacity, buf); 8 } 9 10 Stack(Stack&& tmp) noexcept: 11 capacity{tmp.capacity}, top{tmp.top}, buf{tmp.buf}{ 12 tmp.top = 0; 13 tmp.buf = nullptr; 14 } 15 16 void swap(Stack& other) noexcept{ 17 std::swap(capacity, other.capacity); 18 std::swap(top, other.top); 19 std::swap(buf, other.buf); 20 } 21 22 const Stack& operator=(const Stack& other){ 23 if(this!=other){ 24 Stack tmp(other); 25 swap(tmp); 26 } 27 return *this; 28 } 29 30 const Stack& operator=(Stack&& tmp) noexcept{ 31 swap(tmp); 32 return *this; 33 } \n\n<그림 2.5> C++: 빅5 \n\n1 Stack(const std::initializer_list<T>& inittList): 2 capacity{inittList.size()}, top{capacity}, buf{new T[capacity]}{ 3 std::copy(inittList.begin(), inittList.end(), buf); 4 } \n\n<그림 2.6> CPP: 초깃값 목록을 받는 생성자 \n\n이용하여 초깃값 목록에 제시할 수 없다. 물론 원시 타입 상수를 나열하여 제시하는 것은 autoboxing 기능 때문에 문제 없이 사용할 수 있다. \n\n타입 매개변수를 가변 인자로 사용하거나 범용 타입을 가변 인자로 사용하면 자바의 특성 때문에 타입 안전성을 제공할 수 없어, 여러 문제가 발생할 수 있다. 이 때문에 @SafeVarargs를 사용하지 않으면 컴파일러가 경고를 주게 된다. 그림 2.7의 예제처럼 가변 인자의 데이터에 의해 만들어진 배열을 단순 접근만 하면 문제가 없어, 해당 어노테이션을 사용할 수 있다. 이 예처럼 나열된 초깃값만큼 push를 호출하지 않고 다음과 같이 간단하게 구현할 수 있다. \n\n1 @SafeVarargs public Stack(T... inittList){ \n\n2 capacity = top = inittList.length; \n\n3 buf = inittList.clone();\n\n\n1 @SafeVarargs public Stack(T... initList){ 2 this(initList.length); 3 for(var item: initList) push(item) 4 } \n\n<그림 2.7> Java: 가변 인자를 받는 생성자 \n\n4 \n\n자바는 다중 정의 규칙에 의해 가변 인자를 사용하는 것과 사용하지 않는 것이 있으면 바인딩할 때 사용하지 않는 것을 우선한다. 따라서 다음과 같이 3개의 생성자가 정의되어 있어도 이들을 사용하는데 아무 문제가 없다. \n\n1 public Stack(){ \n\n2 public Stack(int capacity){} \n\n3 @SafeVarargs public Stack(T... initList){} \n\n자바 라이브러리의 경우에는 이와 같은 가변 인자를 이용하여 초깃값을 나열하는 생성자를 제공하지는 않는다. 보 통은 Collection을 받는 생성자를 제공해주며, 이를 통해 다른 자료구조가 유지하고 있는 모든 요소로 초기화된 자료구조를 생성할 수 있도록 해준다. \n\n1 def __init__(self, *initList, capacity=0):  2    if capacity<0: raise RuntimeError('init: capacity<0')  3    if len(initList) == 1 and isinstance(initList[0], list):  4        values = initList[0]  5        else: values = list(initList)  6        self.capacity = max(len(values), capacity)  7        self.buf = [None]*self.capacity  8        self.buf[:len(values)] = values  9        self.top = len(values) \n\n## <그림 2.8> Python: 가변 인자를 받는 생성자 \n\n파이썬도 자바와 마찬가지로 그림 2.8와 같은 가변 인자를 받는 생성자를 정의하여 초깃값 목록을 생성자를 호출할 때 나열할 수 있도록 할 수 있다. 원래 가변 인자는 같은 타입의 여러 개 값을 나열하도록 하는 것이 목적이지만 파이썬은 동적 타입 언어이므로 이것을 쉽게 제한할 수 없다. 따라서 그림 2.8과 같이 구현하여 초깃값 나열이 아니라 리스트도 받을 수 있도록 하고 있다. 인자가 하나만 주어졌고 그것이 리스트이면 그것을 초깃값 목록으로 활용하고 있다. 파이썬에서 가변 인자를 처리할 때 가변 인자는 tuple 타입으로 처리된다. 이 부분도 이와 같은 생성자를 구현할 때 반드시 고려해야 한다.",
    "source": "ds02_2.2_스택 자료구조의 구현-2.2 초깃값 목록",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 2.2 초깃값 목록",
      "section_number": "2.2",
      "section_heading": "2.2 초깃값 목록",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0020"
  },
  {
    "type": "텍스트북",
    "text": "## 2.3 소멸자 또는 clear 연산 \n\nC++는 동적할당한 것을 직접 반납해 주어야 한다. 따라서 이와 같은 동적 자료구조를 구현할 경우 소멸자를 정 의하여 객체가 소멸할 때 동적할당하여 사용하고 있는 공간을 직접 반납해야 한다. clear 연산도 동적할당하여 사용한 공간을 반납하도록 구현할 수 있지만 스택과 같은 경우 top을 0으로 설정하고, 기존 확보한 공간을 그대로 계속 활용할 수 있다. 스택과 달리 연결구조와 같은 자료구조는 clear 연산에서도 기존 사용한 모든 공간을 보통 반납한다. 즉, 자료구조의 특성에 따라 clear 연산에서도 공간 반납이 필요할 수 있으며, clear에서 공간 반납을 할 경우에는 코드 중복에 제거하기 위해 소멸자에서 clear 연산을 호출하는 형태로 많이 구현한다. \n\n자바와 파이썬은 동적할당한 것을 직접 반납하지 않아도 된다. 자바는 소멸자 개념 자체가 없다. 파이썬은 __del__ dunder 메소드를 정의하여 소멸자를 정의할 수 있지만 이 메소드에서 동적할당한 것을 반납할 필요는\n\n\n없다. 자바와 파이썬에서 쓰레기 수집을 촉진하기 위해 사용한 참조 변수를 null이나 None으로 바꾸는 것이 필요하다고 생각할 수 있지만 이는 잘못된 생각이다. 연결구조와 같은 경우에는 머리 포인터만 null로 바꾸어 주면 나머지 노드도 자동 쓰레기 수집 대상이 된다.",
    "source": "ds02_2.3_스택 자료구조의 구현-소멸자 또는 clear 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 소멸자 또는 clear 연산",
      "section_number": "2.3",
      "section_heading": "## 2.3 소멸자 또는 clear 연산",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0021"
  },
  {
    "type": "텍스트북",
    "text": "## 2.4 복합 타입의 저장 \n\n1  void push(const T& item){  2    if(top==capacity) increaseCapacity();  3    buf[top++] = item;  4  }  5  6  void push(T&& item){  7    if(top==capacity) increaseCapacity();  8    buf[top++] = std::move(item);  9  }  10  11  template <typename... Ts>  12  void emplace(Ts&&... args){  13    if(top==capacity) increaseCapacity();  14    new (&buf[top++]) T(std::forward<Ts>(args)...);  15  } \n\n## <그림 2.9> C++: push \n\nC++는 타입 인자로 모든 타입을 사용할 수 있지만 자바는 타입 인자로 원시타입을 사용할 수 없다. 파이썬은 저장하는 타입에 제한이 없기 때문에 이 측면에서는 C++와 유사하다. 하지만 파이썬은 모든 타입을 참조 타입으로 접근하기 때문에 실제 동작 방식은 자바와 더 가깝다. 자바는 범용 자료구조에 원시 타입을 저장하기 위해 wrapper 클래스를 이용한다. 즉, 원시타입을 객체 타입으로 바꾼 후 저장하게 된다. 자바는 각 원시타입마다 그것에 대응되는 객체 타입(예, 원시 타입 int에 대응되는 객체 타입은 Integer입)이 있으며, 둘 간의 변환을 자동으로 해준다. 이 기능을 자동 포장(autoboxing) 기능이라 한다. \n\nC++는 복합 타입의 타입 인자를 효율적으로 처리하기 위해 데이터를 저장하는 메소드의 매개변수 타입을 수정불가 참조로 보통 정의한다. 실제 라이브러리에서는 그림 2.9과 같이 3종류의 메소드를 정의한다. Lvalue가 전달되면 수정불가 참조로 받는 메소드가 호출되며, 전달 비용은 없지만 내부적으로 복사 대입 연산자를 이용하여 데이터를 저장하게 된다. Rvalue를 전달하면 매개변수가 Rvalue 참조인 메소드가 호출되며, 이 버전도 전달 비용은 없고 복사 대입 대신에 이동 대입을 통해 데이터를 저장한다. 하지만 Rvalue를 전달할 경우에는 저장할 복합 타입을 생성할 때 필요한 인자를 받는 emplace를 이용하는 것이 더 효과적이다. emplace는 가변 인자 template 기능, 완벽 포워딩, 특정 위치에 동적할당하는 기법을 사용하여 정의한다. \n\n자바와 파이썬은 참조 전달 방식으로 모든 인자를 처리하기 때문에 효율적인 데이터 저장 메소드를 만들기 위해 매개변수 타입을 정의할 때 특별히 다르게 처리해야 하는 부분은 없다. 하지만 참조를 저장하기 때문에 자료구조 에서 제공하는 방법이 아닌 다른 방법을 통해 저장된 요소를 수정할 수 있다. 이 문제는 다음과 같이 자료구조에 데이터를 저장할 때 복사본을 만들어 저장하는 형태로 자료구조 삽입 연산을 구현하여 해결할 수 있다. \n\n1  public void push(T item){  2    //  3    buf[top++] = item.clone();  4  } \n\n실제 item이 범용 타입이기 때문에 위에 제시된 것처럼 clone 메소드를 호출할 수 없다. 또 문자열과 같이 불변\n\n\n객체(immutable object)는 복제를 하여 저장해야 하는 것은 아니며, clone을 제공하지 않는 타입 인자를 사용할 수도 있다. \n\n따라서 위와 같이 구현하기 보다는 다음과 같이 자료구조를 사용할 때 필요한 경우에는 인자로 복사본을 전달하여 해결하도록 하는 것이 바람직하다. \n\n1 stack.push(item.clone()); \n\n파이썬도 마찬가지이며, 사용할 때 필요하면 복사본을 전달해야 한다. \n\n자바나 파이썬처럼 배열에 실제 데이터가 아니라 데이터의 주소를 유지하면 다음과 같은 이점이 있다. \n\n- 데이터의 실제 크기와 무관하게 주소만 저장하기 때문에 데이터를 매우 효과적으로 배열에 저장 및 추출할 수 있다. \n\n- 효과적으로 저장된 두 요소의 위치를 서로 바꿀 수 있다. \n\n데이터 대신 데이터의 주소를 저장하는 것은 이점만 있는 것은 아니고 다음과 같은 단점도 있다. \n\n- 앞서 살펴본 것처럼 배열에 접근하지 않고 데이터의 수정이 가능하다. \n\n- 데이터가 배열 자체에 유지하고 있지 않기 때문에 이들을 별도 관리할 필요가 있다. \n\n- 실제 데이터가 연속된 공간에 유지하는 것이 아니기 때문에 캐싱 효과가 반감된다. \n\nC++도 자바와 파이썬처럼 자료구조에 실제 데이터가 아니라 데이터의 주소를 유지할 수 있다. 하지만 데이터를 별도 관리할 필요가 있으므로 C++에서는 보통 두 개 이상의 자료구조를 결합하여 사용할 때 이와 같은 기법을 사용한다. 예를 들어 연결구조 리스트에 데이터를 실제 유지하고, 맵에 데이터를 접근하기 위한 키와 데이터가 저장된 노드의 주소를 유지하여 순차적으로만 접근할 수 있는 연결구조의 단점을 극복할 수 있다. 이에 대해서는 10장에서 다시 자세히 설명한다.",
    "source": "ds02_2.4_스택 자료구조의 구현-복합 타입의 저장",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 복합 타입의 저장",
      "section_number": "2.4",
      "section_heading": "## 2.4 복합 타입의 저장",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0022"
  },
  {
    "type": "텍스트북",
    "text": "2.5 동적 배열 기법 \n\n1 void increaseCapacity(){ 2 if(capacity==0){ 3 capacity = 1; 4 buf = new T[capacity]; 5 } 6 else{ 7 capacity *= 2; 8 T* tmp{new T[capacity]}; 9 std::copy(buf, buf+top, tmp); 10 delete [] buf; 11 buf = tmp; 12 } 13 } \n\n<그림 2.10> C++: increaseCapacity \n\n배열 기반 자료구조를 구현할 때 현재 사용하고 있는 배열의 용량이 부족하면 더 큰 용량의 배열을 동적 생성한 후에 기존 데이터를 옮기는 형태로 용량을 확장한다. 이때 평균 비용을 최소화하기 위해 용량을 두 배씩 확장하는 방식을 주로 사용한다. 각 언어에서 이것을 해주는 메소드는 그림 2.10부터 그림 2.12와 같다.\n\n\n1 private void increaseCapacity() { 2 if(capacity==0) { 3 capacity = 1; 4 buf = (T[])new Object[capacity]; 5 } 6 else { 7 capacity *= 2; 8 buf = Arrays.copyOf(buf, capacity); 9 } 10 } \n\n<그림 2.11> 자바: increaseCapacity \n\n1 def increaseCapacity(self): 2 if self.capacity==0: 3 self.capacity = 1 4 self.buf = [None] 5 else: 6 self.buf += [None]*self.capacity 7 self.capacity *= 2 \n\n<그림 2.12> 파이썬: increaseCapacity \n\n각 메소드는 용량이 0인 상태부터 시작할 수 있어 조건문의 사용이 불가피하다. C++는 기존에 사용한 공간을 반납하는 부분이 필요하지만 자바와 파이썬은 그것이 필요없다. 자바에서 기존 데이터를 옮기면서 공간을 확장할 때에 가장 편리하게 사용할 수 있는 것이 Arrays 클래스의 copyOf 메소드이고, 파이썬의 경우에는 + 리스트 결합 연산자나 extend 메소드를 사용하는 것이 가장 간결한 방법이다. \n\n자료구조는 용량이 부족할 때 자동으로 확장해 주지만 확장할 때 많은 비용이 소요된다. 따라서 내부적으로 동적 배열을 사용하는 자료구조는 처음에 생성할 때 저장해야 할 요소의 개수를 알면 적절한 크기의 용량을 확보해 주는 것이 자료구조를 효과적으로 사용하는 방법이다. 또 사용 중인 경우에도 특정 시점 이후 일정한 수의 데이터를 추가해야 한다는 것을 알면 미리 용량을 확장한 후에 삽입하는 것도 비용을 절약할 수 있는 방법이 된다.",
    "source": "ds02_2.5_스택 자료구조의 구현-2.5 동적 배열 기법",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 2.5 동적 배열 기법",
      "section_number": "2.5",
      "section_heading": "2.5 동적 배열 기법",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0023"
  },
  {
    "type": "텍스트북",
    "text": "2.5.1 분할상환 분석 \n\n동적 배열 기법에서 사용 중인 배열의 용량이 부족하면 더 큰 용량의 새 배열을 동적할당하고 그곳으로 데이터를 옮겨야 한다. 그러면 이때 얼마만큼 확장해야 가장 효과적일까? 직관적으로 생각하여 보자. 용량을 너무 많이 확장하면 공간 낭비가 심할 수 있다. 특히, 확장 후에 데이터를 별로 추가하지 않으면 많은 공간이 낭비될 수 있다. 반대로 적게 용량을 늘리면 계속해서 용량을 확장하는 비용이 소요될 수 있다. 가장 효과적인 방법을 알아내기 위해서는 평균 비용을 계산해 보아야 한다. \n\nC++를 기준으로 용량을 확장할 때 소요되는 비용은 다음과 같다. \n\n- 기존보다 큰 용량의 새 동적 배열 확보 \n\n- 기존 데이터의 복사 \n\n- 기존 공간의 반납 \n\n- 용량 멤버 변수와 버퍼 멤버 변수의 수정\n\n\n그러면 매번 특정 크기 k만큼 확대할 경우 평균 비용과 매번 두 배로 확장하였을 때 평균 비용을 비교하여 보자. 이때 초기 용량은 0이라고 생각하고 분석하여 보자. k개씩 확장할 때 i번째 요소를 삽입하는 비용은 다음과 같다. \n\n\\[c_i = 1 + \\begin{cases} i - 1 & i - 1이 k의 배수인 경우 \\\\ 0 & 나머지 경우 \\end{cases}\\]\n\n용량 확장 없이 삽입하는 비용은 O(1)이고, 용량 확장이 필요하면 용량 확장 후 기존 i - 1개 데이터를 복사하고 새 데이터를 삽입해야 하므로 O(i) 비용이 소요된다. 동적 배열을 할당하는 비용, 반납 비용 등까지 고려하더라도 아래 분석에는 차이가 없다. 그러면 평균 비용은 다음과 같이 먼저 cᵢ의 합계를 구한 후, \n\n\\[\\sum_{i=1}^{n} c_i = n + \\sum_{j=1}^{\\lfloor n/k\\rfloor} kj = n + \\frac{n^2 + nk}{2k}\\]\n\n이것을 n으로 나누어야 하므로, O(n)이다. 반면에 2배로 확장할 때 i번째 요소를 삽입하는 비용은 다음과 같다. \n\n\\[c_i = 1 + \\begin{cases} i - 1 & i - 1이 2의 거듭제곱인 경우 \\\\ 0 & 나머지 경우 \\end{cases}\\]\n\n그러면 평균 비용은 이전과 동일하게 먼저 cᵢ의 합계를 구한 후, \n\n\\[\\sum_{i=1}^{n} c_i = n + \\sum_{j=1}^{\\lfloor \\log_2(n-1) \\rfloor} 2^j = n + 2^{\\lfloor \\log_2(n-1) \\rfloor} + 1 - 1 \\approx 3n - 3\\]\n\n이것을 n으로 나누어야 하므로, O(1)이다. 실제 용량이 부족할 때 s(> 1)배로 확장하면 평균 비용은 O(1)이다. \n\n현재 용량이 매우 클 때 정해진 s배로 확장한 다음 데이터를 거의 추가하지 않으면 많은 공간이 낭비될 수 있다. 이에 더 이상 데이터의 추가가 필요 없으면 사용하지 않는 공간을 모두 반납하여 공간 낭비 문제를 해결할 수 있다. C++의 std::vector와 같은 자료구조는 이를 위해 shrink_to_fit 메소드를 제공하며, 자바의 ArrayList는 trimToSize 메소드를 제공한다. 파이썬의 리스트는 del과 slicing을 결합하여 사용하거나 slicing만 이용하여 리스트의 현재 용량을 줄일 수 있다. 이와 같은 반납은 용량 확장과 마찬가지로 새 공간을 확보하여 데이터를 옮긴 후 기존 배열 공간 전체를 반납하는 형태로 이루어진다.",
    "source": "ds02_5.1_스택 자료구조의 구현-2.5.1 분할상환 분석",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 2.5.1 분할상환 분석",
      "section_number": "5.1",
      "section_heading": "2.5.1 분할상환 분석",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0024"
  },
  {
    "type": "텍스트북",
    "text": "## 2.6 복합 타입의 반환 \n\n1. **const T& peek() const{**\n2. **if(isEmpty()) throw std::logic_error(\"\");**\n3. **return buf[top-1];**\n4. **}**\n5. **T pop(){**\n6. **if(isEmpty()) throw std::logic_error(\"\");**\n7. **T ret{std::move(buf[top-1])};**\n8. **--top;**\n9. **return ret; // std::move(buf[top]);**\n10. **}** \n\n<그림 2.13> C++: peek, pop \n\nC++는 인자 전달과 마찬가지로 무거운 데이터를 복사 방식으로 값을 반환하는 것은 많은 비용이 소요된다. 조회 연산은 그림 2.13처럼 배열에 있는 요소를 반환하면 되므로 참조 타입으로 반환할 수 있지만 추출 연산은 더\n\n\n이상 해당 요소를 배열에 유지하는 것이 아니므로 참조 타입으로 반환할 수 없다. 추출 연산은 값 복사 방식으로 반환하지만 C++17부터는 RVO(Return-Value Optimization)² 최적화가 의무화되어 있으므로 생각한 것만큼 비용이 소요되지는 않는다. 또 추출 연산은 배열에 더 이상 해당 값을 유지할 필요가 없으므로 std::move를 활용하는 것이 효과적이다. 조회 연산에서 참조 타입으로 반환할 경우 참조로 받아야 비용 절감의 효과를 얻을 수 있다. 그런데 받은 참조를 이용하여 저장된 요소의 상태를 변경할 수 있으므로 수정불가 참조로 반환해야 한다. \n\n자바와 파이썬은 주소를 유지하고 있으므로 반환의 효율성을 걱정할 필요는 없다. 하지만 조회 연산의 경우 받은 주소를 이용하여 저장된 요소의 상태를 변경할 수 있으므로 복제하여 반환할 필요가 있다. 하지만 이 부분도 모든 경우에 필요한 것이 아니므로 자료구조 자체에서 복제하여 반환하는 형태로 보통 구현하지 않는다.",
    "source": "ds02_2.6_스택 자료구조의 구현-복합 타입의 반환",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 복합 타입의 반환",
      "section_number": "2.6",
      "section_heading": "## 2.6 복합 타입의 반환",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0025"
  },
  {
    "type": "텍스트북",
    "text": "## 2.7 추출과 삭제 연산 \n\n보통 배열 기반 자료구조의 경우에는 크기 정보만 변경하고 실제 배열에 대해서는 어떤 조치를 하지 않아도 된다. 자바에서 객체 배열의 경우에는 크기 정보뿐만 아니라 해당 배열의 요소 값을 null로 바꾸어 쓰레기 수집을 촉진할 수 있다. 반드시 이렇게 해야 하는 것은 아니지만 간단한 문장 하나를 추가하는 것이므로 충분히 추가할 수 있는 요소이다. 파이썬도 비슷한 이유로 None으로 바꾸어 줄 수 있다.",
    "source": "ds02_2.7_스택 자료구조의 구현-추출과 삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 추출과 삭제 연산",
      "section_number": "2.7",
      "section_heading": "## 2.7 추출과 삭제 연산",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0026"
  },
  {
    "type": "텍스트북",
    "text": "## 2.8 반복자 \n\n자료구조는 유지하는 개별 요소를 차례로 접근할 수 있도록 보통 반복자를 제공한다. 반복자는 자료구조와 무관하 게 항상 균일한 방법으로 저장된 요소를 접근할 수 있게 해주는 이점이 있다. 이 절에서는 각 언어마다 반복자를 제공하는 방법을 살펴본다. \n\nC++와 자바는 보통 내부 클래스로 반복자 클래스를 정의한다. 반복자는 하나의 기능이므로 클래스의 응집성을 고려하면 반복자를 별도 클래스에 구현하는 것이 객체지향 설계 원리에 부합한 방법이다. 더욱이 자바는 내부 클래스로 정의하면 외부 클래스에 유지되어 있는 반복해야 하는 데이터에 쉽게 접근할 수 있어 구현 자체도 효과적으로 할 수 있다. 파이썬도 내부 클래스로 정의할 수 있지만 보통 클래스 자체에 메소드를 추가하는 형태로 많이 정의한다.",
    "source": "ds02_2.8_스택 자료구조의 구현-반복자",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 반복자",
      "section_number": "2.8",
      "section_heading": "## 2.8 반복자",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0027"
  },
  {
    "type": "텍스트북",
    "text": "## 2.8.1 C++ \n\nC++는 두 개의 객체를 이용하여 반복자를 처리하며, 이 객체를 포인터처럼 사용한다. 또 일반 반복자, 상수 반복자, 거꾸로 반복자 등 제공하는 반복자의 종류도 복잡하고 다양하다. 보통 begin()를 통해 얻은 반복자를 이동하여 차례로 요소에 접근하며, 이 반복자가 end()와 동일한 것을 가리키면 반복을 종료하게 된다. 따라서 두 개의 객체를 이용하지만 하나는 고정된 상태이고, 하나만 계속 위치를 바꾸게 된다. 이 개념을 통해 특정 구간을 효과적으로 나타낼 수 있고, 해당 구간에 대해서만 반복을 진행할 수 있다. \n\nC++의 반복자를 정의하는 가장 간단한 방법은 그림 2.14와 같다. 보통 스텍은 반복자가 필요한 자료구조는 아니지만 스텍에 저장된 요소를 차례로 접근할 수 있는 반복자를 제공한다면 그림 2.14와 같다. 보통 begin() 반복자를 움직일 때 필요한 ++ 연산자, begin()과 end()를 비교할 때 필요한 ==와 != 연산자, begin()이 가리키는 요소를 접근할 때 사용하는 역참조 연산자를 다중 정의해 주어야 한다. 그림 2.14처럼 범용 클래스로 정의하면 하나의 클래스로 일반 반복자와 상수 반복자를 모두 제공할 수 있다. \n\n이렇게 내부 클래스로 반복자를 정의하면 그림 2.15과 같은 begin(), end() 메소드를 정의해 주어야 한다. 현재 자료구조를 접근하는 변수의 타입에 따라 begin()를 호출하였을 때 일반 반복자를 얻을 수 있고, 상수 반복자를\n\n\n1 template <typename U>  2 class StackIterator: public std::iterator<std::input_iterator_tag,U>{  3 U* p;  4 public:  5 explicit StackIterator(U* p): p{p} {  6 const StackIterator& operator++() noexcept {--p; return *this;}  7 StackIterator operator++(int) noexcept {  8 auto retval{*this}; ++(*this); return retval;}  9 bool operator==(const StackIterator& other) const noexcept {  10 return p == other.p;}  11 bool operator!=(const StackIterator& other) const noexcept {  12 return p != other.p;}  13 U& operator*() noexcept {return *p;}  14 }; \n\n<그림 2.14> CPP: 반복자 내부 클래스 버전 1 \n\n1 auto begin() {return StackIterator<T>(buf+top-1);}  2 auto end() {return StackIterator<T>(buf-1);}  3 const auto begin() const {return StackIterator<const T>(buf+top-1);}  4 const auto end() const {return StackIterator<const T>(buf-1);}  5 auto cbegin() const {return StackIterator<const T>(buf+top-1);}  6 auto cend() const {return StackIterator<const T>(buf-1);} \n\n<그림 2.15> CPP: 반복자 반환 매소드 \n\n얻을 수 있다. 상수 반복자는 반복자가 가리키는 현재 요소를 수정할 수 없다. \n\nC++의 반복자를 꼭 포인터를 이용하여 구현해야 하는 것은 아니다. 그림 2.16처럼 방문한 요소의 개수와 현재 위치를 나타내는 색인을 이용하여 구현할 수 있다. 물론 이렇게 구현하면 다음과 같이 begin, end에서 반복자 객체를 생성할 때 전달해야 하는 것이 많다. \n\n1 auto begin() {return StackIterator<T>(0, top-1, buf);} \n\n2 auto end() {return StackIterator<T>(top, 0, buf);} \n\n이 경우 begin 메소드에서는 전달하는 모든 인자가 중요하지만 end의 경우에는 첫 인자만 중요하다.",
    "source": "ds02_8.1_스택 자료구조의 구현-.1 C++",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: .1 C++",
      "section_number": "8.1",
      "section_heading": "## 2.8.1 C++",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0028"
  },
  {
    "type": "텍스트북",
    "text": "2.8.2 자바 \n\n자바에서 정의한 클래스에 반복자를 제공하고 싶으면 해당 클래스에 Iterable interface를 구현해야 한다. Iterable interface는 iterator 메소드를 정의해 주어야 하며, 이 메소드에서 반복자를 생성하여 다음과 같이 반환해 주어야 한다. \n\n1 @override public Iterator<T> iterator() { \n\n2 return new StackIterator(); \n\n3 } \n\n자바는 C++와 달리 하나의 객체를 통해 반복자를 제공한다. 자바에서 반복자도 C++처럼 내부 클래스로 정의하며, 이 클래스는 Iterator interface를 구현해야 한다. 이 클래스는 객체지향 설계 패턴에서 말하는 반복자 형태와 동일하게 hasNext 메소드와 next 메소드를 정의하여 구현한다. 자바의 내부 클래스는 그것의 외부 클래스와 연결되기 때문에 이처럼 내부 클래스로 정의하면 데이터가 유지된 외부 클래스의 배열 멤버 변수에 쉽게 접근할 수 있다.\n\n\n1 template <typename U>  2 class StackIterator: public std::iterator<std::input_iterator_tag,U>{  3 size_t visited;  4 size_t index;  5 U* arr;  6 public:  7 explicit StackIterator(size_t visited, size_t index, U* arr):  8 visited{visited}, index{index}, arr{arr}{}  9 const StackIterator& operator++() noexcept {  10 ++visited, --index; return *this;  11 StackIterator operator++(int) noexcept {  12 auto retval{*this}; ++(*this); return retval;}  13 bool operator==(const StackIterator& other) const noexcept {  14 return visited == other.visited;}  15 bool operator!=(const StackIterator& other) const noexcept {  16 return visited != other.visited;}  17 U& operator*() noexcept {return arr[index];}  18 }; \n\n<그림 2.16> CPP: 반복자 내부 클래스 버전2 \n\n1 private class StackIterator implements Iterator<T>{ 2 int curr = top-1; 3 @Override public boolean hashCode() { 4 return curr>=0; 5 } 6 7 @Override public T next() { 8 T ret = buf[curr]; 9 --curr; 10 return ret; 11 } 12 } \n\n<그림 2.17> 자바: 반복자 내부 클래스",
    "source": "ds02_8.2_스택 자료구조의 구현-2.8.2 자바",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 2.8.2 자바",
      "section_number": "8.2",
      "section_heading": "2.8.2 자바",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0029"
  },
  {
    "type": "텍스트북",
    "text": "2.8.3 파이썬 \n\n파이썬에서 반복자는 자바와 매우 유사하다. 반복자를 제공하는 클래스는 __iter__ 메소드를 제공해야 하며, 반복자 클래스는 __next__ 메소드를 제공해야 한다. 파이썬도 내부 클래스로 반복자를 제공하고 이것의 객체를 자료구조의 __next__ 메소드에서 반환하는 형태로 구현할 수 있다. 하지만 파이썬은 자바와 달리 내부 클래스에서 외부 클래스 데이터를 쉽게 접근할 수 없다. 이 때문에 많은 경우 반복자를 내부 클래스로 정의하지 않고 자료구조 클래스에 __iter__와 __next__ 메소드를 모두 추가하는 형태로 구현할 많이 한다. 하지만 이것은 클래스 응집 성에 바람직한 것은 아니다. 파이썬에서 스택 자료구조에 반복자를 위해 추가한 두 개의 메소드는 그림 2.18과 같다. 이 그림에서 알 수 있듯이 자료구조 객체 자체가 반복자가 되는 형태이다. \n\n3. 단위 테스팅 \n\n자료구조를 포함하여 프로그램을 개발할 때 구현의 정확성이 매우 중요하다. 또 한번 구현한 것을 계속 유지보수 해야 하는 경우가 많다. 구현 결과의 정확성을 검사하기 위해 보통 단위 테스팅 도구를 사용한다. 단위 테스트란 구현한 프로그램의 각 함수를 개별적으로 검사하는 것을 말하며, 한 함수를 검사하기 위해 하나의 테스트 함수가\n\n\n1 def __iter__(self): 2 self.it = self.top-1 3 return self 4 5 def __next__(self): 6 if self.it>=0: 7 self.it -= 1 8 return self.buf[self.it+1] 9 else: raise StopIteration \n\n<그림 2.18> 파이썬: 반복자 메소드 \n\n아니라 여러 개의 테스트 함수를 만들어 사용할 수 있다. 특히, 테스트 기반 개발(TDD, Test-Driven Development) 에서는 프로그램을 먼저 구현하는 것이 아니라 구현할 프로그램을 테스트할 코드를 먼저 개발한다. 테스트를 통과 하였다고 프로그램이 정확한 것은 아닐 수 있다. 테스트가 모든 경우를 다 검사하지 못할 수 있기 때문이며, 테스트 자체가 잘못 구현되어 있을 수 있다.",
    "source": "ds02_8.3_스택 자료구조의 구현-2.8.3 파이썬",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 2.8.3 파이썬",
      "section_number": "8.3",
      "section_heading": "2.8.3 파이썬",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0030"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1 C++ \n\nC++는 googletest라는 단위 테스팅 도구를 활용할 수 있다. 이 도구는 TEST라는 이름의 단위 테스트를 작성하게 되며, 테스트 세트 이름과 테스트명을 인자로 받는다. 단위 테스트는 다음 assertion 등을 이용하여 작성한다. \n\n• ASSERT_EQ(val1, val12): 두 개가 같은지 확인할 때 사용한다. \n\n• ASSERT_TRUE(condtion): 조건이 참인지 확인할 때 사용한다. \n\n• ASSERT_FALSE(condition): 조건이 거짓인지 확인할 때 사용한다. \n\n• ASSERT_THROW(statement, exception_type): 예외 발생을 확인할 때 사용한다. \n\n특정 단위 테스트를 skip하고 싶으면 테스트명 앞에 DISABLED_을 추가하면 된다.",
    "source": "ds02_3.1_스택 자료구조의 구현-C++",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: C++",
      "section_number": "3.1",
      "section_heading": "## 3.1 C++",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0031"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2 자바 \n\n자바는 JUnit5라는 단위 테스팅 도구를 활용할 수 있다. 이 도구는 단위 테스트 클래스 내에 @Test로 수식된 단위 테스트를 작성하게 되며, 단위 테스트는 다음 assertion을 이용하여 작성한다. \n\n• assertEquals(expected, actual): 두 개가 같은지 확인할 때 사용한다. \n\n• assertTrue(condition): 조건이 참인지 확인할 때 사용한다. \n\n• assertFalse(condition): 조건이 거짓인지 확인할 때 사용한다. \n\n• assertThrows(exception_class, executable): 예외 발생을 확인할 때 사용한다. 보통 람다 표현 식을 이용하여 실행할 것을 인자로 전달한다. \n\n특정 단위 테스트를 skip하고 싶으면 함수를 @Disabled을 추가하거나 @Test를 주석처리하면 된다.",
    "source": "ds02_3.2_스택 자료구조의 구현-자바",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 자바",
      "section_number": "3.2",
      "section_heading": "## 3.2 자바",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0032"
  },
  {
    "type": "텍스트북",
    "text": "## 3.3 파이썬 \n\n파이썬은 unittest를 import하고 unittest.TestCase를 상속받는 단위 클래스를 정의하여 단위 테스트를 작성한다. 단위 테스트는 이 클래스의 메소드로 추가하며, 메소드의 이름은 test_로 시작한다. 테스트 함수가 호출되는 순서는 작성된 순서가 아니라 테스트 함수의 이름을 알파벳 순으로 정렬하여 수행한다. 실제 단위 테스트는 각각 서로 독립적이어야 하기 때문에 실행 순서에 의존하도록 테스트를 작성하는 것은 적절하지 않다. 단위 테스트는 다음 assertion을 이용하여 작성한다. \n\n• assertEquals(expected, actual): 두 개가 같은지 확인할 때 사용한다. \n\n• assertTrue(condition): 조건이 참인지 확인할 때 사용한다. \n\n• assertFalse(condition): 조건이 거짓인지 확인할 때 사용한다. \n\n• assertRaises(exception_class, action, argument): 예외 발생을 확인할 때 사용한다. \n\n특정 단위 테스트를 skip하고 싶으면 함수를 @unittest.skip로 수식하면 된다.",
    "source": "ds02_3.3_스택 자료구조의 구현-파이썬",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "스택 자료구조의 구현: 파이썬",
      "section_number": "3.3",
      "section_heading": "## 3.3 파이썬",
      "parent_section": "2. 스택 자료구조의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0033"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 기타 \n\n1  const T& operator[](size_t index) const{  2    if(index>=size) throw std::out_of_range(\"\");  3    return buf[index];  4  }  5  6  T& operator[](size_t index){  7    return const_cast<T&>(std::as_const(*this)[index]);  8 } // C++17 \n\n## <그림 2.19> CPP: 색인 연산자 다중 정의 \n\nC++에서 자료구조를 구현할 때 임의 접근을 제공하는 자료구조의 경우에는 배열 색인 연산자를 다중 정의하여 제공하는 경우가 많다. 배열 색인 연산자의 다중 정의를 위해 보통 두 개의 메소드를 정의해야 하는데, 코드 중복을 제거하기 위해 그림 2.19과 같이 많이 정의한다. 이 방법을 사용하기 위해서는 const 버전의 메소드를 먼저 정의 하고, 이것의 반환 타입을 값이 아니라 참조 타입으로 정의해야 한다. 그다음 non-const 버전의 메소드를 const 버전을 이용하여 정의한다. 이 방법을 사용하면 non-const 버전은 항상 클래스와 무관하게 그림 2.19에 제시된 것처럼 정의할 수 있다. \n\n파이썬은 C++처럼 연산자를 다중 정의하지는 않지만 두 개의 밑줄 문자로 시작하는 매직 메소드 또는 dunder 메소드를 많이 정의하여 사용한다. 이와 같은 메소드를 정의하면 함수 호출 대신에 연산자를 이용하여 자료구조를 조작할 수 있다. 자료구조를 정의할 때 많이 정의하여 사용하는 dunder 메소드는 다음과 같다. \n\n• _len_: 자료구조의 크기를 반환하는 메소드 \n\n• __getitem__: 배열 색인 연자 또는 slicing를 사용하기 위한 메소드 \n\n• __setitem__: 배열 색인 연자 또는 slicing를 사용하기 위한 메소드 \n\n• __contains__: 특정 요소가 자료구조에 저장되어 있는지 확인하기 위한 메소드\n\n\n1 std::optional<int> search(const T& item){ 2 for(size_t i{0}; i<numItems; ++i) 3 if(items[i]==item) return std::optional<int>(i); 4 return std::nullopt; 5 } \n\n<그림 2.20> CPP: std::optional을 이용한 선형 검색 \n\n1 Optional<Integer> search(T item){ 2 for(int i=0; i<numItems; ++i) 3 if(items[i].equals(item)) return Optional.of(i); 4 return Optional.empty(); 5 } \n\n<그림 2.21> 자바: Optional을 이용한 선형 검색 \n\n이 외에도 __eq__, __lt__, __add__ 등 정의하여 활용할 수 있는 dunder 메소드가 많다. \n\n내부적으로 배열을 이용한 자료구조 구현에서 찾기 연산은 주어진 요소가 현재 자료구조 내에 저장되어 있는지 여부를 알고자 할 때 사용하는 연산이다. 보통 이 연산은 그 결과로 있을 경우 true를 반환하여 준다. 하지만 있다 없다 유무가 아니라 저장된 위치 정보를 반환하는 형태로 만들어 사용하는 경우도 많다. 이 경우 찾고자 하는 요소가 없다는 것을 나타내기 위해 반환값으로 보통 -1을 사용한다. 하지만 C++처럼 색인 타입을 size_t를 사용하면 -1 을 반환할 수 없다. 이 때문에 0색인 방식에서 유효 색인의 범위가 0부터 n-1이므로 n을 반환하는 형태로 구현하는 경우도 많다. 따라서 해당 연산을 사용하는 입장에서는 없는 경우 어떤 값을 반환하는지 파악하고 사용해야 하는 불편함이 있다. C++와 자바는 이 문제를 해결하기 위해 각각 std::optional과 Optional을 사용할 수 있다. 이것을 사용하는 선형 검색 찾기 함수는 각 언어에서 그림 2.20과 그림 2.21와 같다. 자바에서 Optional을 사용할 경우 함수형 프로그래밍을 이용하여 간결하게 프로그래밍할 수 있는 이점도 있다. \n\n그림 2.20과 그림 2.21에 제시된 메소드에서 C++는 == 연산자를 이용하여 인자와 저장된 요소가 같은지 비 교하고 있으며, 자바는 equals 메소드를 이용하고 있다. 자바는 타입 인자로 원시 타입을 사용할 수 없기 때문에 Object 클래스에 정의되어 있는 equals 메소드를 이용하며, 사용하는 타입 인자 클래스가 equals 메소드를 올바르게 재정의하고 있어야 한다. 파이썬도 C++처럼 == 연산자를 이용한다. 이 연산자가 올바르게 동작하기 위해서는 해당 타입의 클래스가 __eq__ dunder 메소드를 재정의하고 있어야 한다. 파이썬은 == 연산자 외에 is 를 이용할 수 있는데, is는 값 비교가 아니라 두 변수가 같은 주소를 가리키는지 비교하는 것이다. \n\n두 요소가 같은지 비교하는 것이 아니라 큰지 작은지 알고 싶을 경우에도 C++와 파이썬은 연산자를 사용한 다. C++는 해당 타입 인자 클래스가 해당 연산자를 다중 정의하고 있어야 하며, 파이썬은 관련 연산자와 연결된 __lt__ 와 같은 dunder 메소드를 재정의하여야 한다. 자바는 이 경우 Comparable interface에 선언되어 있는 compareTo 메소드를 사용한다. 따라서 저장하는 데이터 타입이 Comparable interface를 구현하고 있어야 한다. \n\n1 private static class Node<T>{ 2 T item; 3 Node<T> next; 4 } \n\n<그림 2.22> Java: 연결 구조 기반 자료구조를 구현할 때 노드를 정의하는 내부 클래스 \n\n자바에서 연결 구조 방식을 구현할 때 내부 클래스로 노드에 해당하는 내부 클래스를 그림 2.22과 같이 정의하여 사용하게 된다. 이때 중첩 클래스로 정의하여 노드 객체가 불필요한 외부 객체에 대한 포인터를 유지하지 않도록 해야 한다. 반대로 내부 반복자 클래스를 자바에서 정의할 때 일반 내부 클래스로 정의하여 외부 클래스에 있는\n\n\n멤버 변수를 쉽게 접근할 수 있도록 정의한다. \n\n자바에서 범용 클래스를 정의할 때 정렬 리스트처럼 저장된 요소들을 비교할 수 있어야 하는 경우에는 자료구조 클래스를 정의할 때 다음과 같이 Comparable interface를 구현한 클래스만 타입 인자로 사용할 수 있도록 해야 한다. \n\n1 public class SortedArrayList<T extends Object & Comparable<T>> extends Iterable< T> { \n\n2 // \n\n3 } \n\n이와 같이 정의해야 내부에서 비교가 필요할 때 compareTo 메소드를 사용할 수 있다. 여기서 Object로 추가 제한한 이유는 erasure 과정에서 Comparable로 바꾸지 않고 Object로 바꾸기 위한 것이다. Comparable로 바뀔 경우에는 타입 변환 등 일부 코드가 올바르게 동작하지 않을 수 있어, 특정 interface로 제한할 때 Object 을 제한 타입으로 추가하는 경우가 많다.",
    "source": "ds02_4_기타",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제2장 자료구조의 구현",
      "section": "기타",
      "section_number": "4",
      "section_heading": "## 4. 기타",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0034"
  },
  {
    "type": "텍스트북",
    "text": "## 1.  배열 \n\n배열은 대부분의 고급 프로그램명 언어가 언어 자체에서 제공하는 복합타입이다. 하지만 배열을 조작할 때 사용할 수 있는 연산은 별도 제공하지 않기 때문에 자료구조라 하기 힘들다. 배열은 보통 언어와 무관하게 다음과 같은 특성을 가지고 있다. \n\n 특성 1. 물리적 동질 구조이다. \n\n 특성 2. 요소 간의 순서가 존재한다. \n\n 특성 3. 배열의 용량은 배열을 생성할 때 결정되며, 생성된 이후에는 현재 위치에서는 바꿀 수 없다. \n\n 특성 4. 임의 접근을 제공한다. 접근 비용은 접근하는 요소의 위치와 무관하다. \n\n물리적으로는 동질 구조이지만 사용하는 방법에 따라 논리적으로는 동질 구조가 아닐 수 있다. C에서 사용한 널문 자료 끝나는 문자열의 경우 마지막 널문자와 실제 문자열 데이터는 논리적으로 같은 요소가 아니다. 임의 접근이 가능한 이유는 용량이 고정되어 있고, 연속 공간에 확보되며, 각 요소가 물리적으로 같은 타입이기 때문이다. \n\n배열은 그것의 기본적인 특성 때문에 보통 데이터를 첫 공간부터 차례로 중간에 건너뛰지 않고 저장하며, 기존 에 데이터가 있을 경우에는 맨 뒤에 추가하여야 가장 저렴하고 효과적이다. 배열의 장점은 임의 접근을 제공하는 것이다. 하지만 다음과 같은 단점도 있다. \n\n 단점 1. 용량이 고정되어 있어, 공간이 부족할 수 있거나 낭비될 수 있다. \n\n 단점 2. 중간에 데이터를 추가 또는 삭제하는 것이 효율적이지 못하다. \n\n단점 1은 동적 배열(dynamic array) 기법을 이용하여 극복할 수 있다. 동적 배열 기법은 자동 배열 대신에 동적 배열 을 사용하고 공간이 부족하면 용량이 더 큰 동적 배열을 생성하여 대체한다. 하지만 용량이 더 큰 배열을 생성하고 기존 데이터를 옮기는 비용이 저렴하지 않다. 더 큰 동적 배열이 필요할 때 용량을 두 배씩 확장하는 기법의 평균 삽입 비용을 분석하면 이 문제점에 불구하고 2장에서 살펴본 바와 같이 평균적으로 O(1) 비용밖에 소요되지 않는 다. 그럼에도 불구하고 두 배씩 확장하는 것은 공간 낭비가 매우 클 수 있다는 점을 인식해야 한다. 또한 이 때문에 배열은 필요한 공간을 미리 알거나 필요한 공간의 크기가 가변적이지 않을 때(편차가 작을 때) 가장 효과적이다. \n\n배열의 또다른 이점은 연속 공간에 데이터를 유지하기 때문에 캐싱에 유리하다. CPU에서 메모리에 있는 데이터 를 접근할 때 필요한 특정 데이터만 CPU 레지스터로 옮기는 것이 아니라 정해진 블록 단위로 CPU 캐시에 옮기고 CPU 캐시에서 필요한 데이터를 레지스터로 옮긴다. 이 때문에 연속 공간에 데이터를 유지하는 배열은 블록 단위로 데이터를 옮길 때 같은 배열 데이터가 함께 옮겨질 확률이 매우 높다. 따라서 많은 메모리 접근 없이 CPU 캐시에서 배열에 대한 처리를 모두 수행할 수 있다.",
    "source": "ds03_1_배열",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열",
      "section_number": "1",
      "section_heading": "## 1.  배열",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0035"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 리스트 \n\n리스트(list) 추상 데이터 타입은 보통 프로그래밍 언어에서 기본적으로 제공하는 배열 대신에 사용할 수 있는 동질 구조의 선형 ADT이며, 사용 가능한 여러 연산을 제공하는 것이 특징이다. 보통 리스트를 구현하는 방법은 다음과 같은 기준에 의해 분류할 수 있다. \n\n 기존 1. 비정렬 vs. 정렬 \n\n 기존 2. 배열 vs. 연결구조 \n\n 기존 3. 중복 허용 여부 \n\n연결구조에 대해서는 4장에서 자세히 살펴보기 때문에 이 장에서는 기존 1과 기존 3에 대해 배열을 이용하여 리스트를 구현할 경우의 특징을 생각하여 보자.",
    "source": "ds03_2_리스트",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "리스트",
      "section_number": "2",
      "section_heading": "## 2. 리스트",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0036"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1 비정렬과 정렬 \n\n정렬하여 유지할 필요가 없으면 요소를 추가할 때 추가하는 위치에 제약이 없다고 생각할 수 있다. 하지만 데이터 의 삽입과 추출은 쌍으로 연관하여 생각하여야 한다. 보통 리스트 ADT는 pushFront, popFront, pushBack, popBack 4가지 삽입 추출 연산을 제공한다. 이때 pushFront와 popFront, pushBack과 popBack은 서로 맞물려 동작해야 한다. pushFront을 여러 차례 수행한 후에 popFront을 수행하면 pushFront한 순서와 반대 순서로 데이터를 얻어야 하며, pushFront와 pushBack이 서로에 영향을 주지 않아야 한다. 이것을 보장하기 위해서는 삽입한 순서가 내부적으로 유지되어야 한다. \n\n이 측면과 관계없이 데이터를 삽입할 때 가장 저렴하게 삽입할 수 있는 위치는 배열의 경우에는 맨 뒤이다. 삽입된 순서를 유지하도록 앞서 제시한 4가지 연산을 고려하면 배열은 순환 배열을 사용할 경우에만 4가지 연산을 모두 상수 비용에 제공할 수 있다. 순환 배열은 이 장 5절에서 자세히 설명한다. \n\n정렬하여 유지하면 삽입하는 위치는 주어진 데이터와 현재 상태에 의해 결정되며, 삽입하기 전에 삽입 위치를 찾아야 한다. 배열의 경우에는 이진 검색을 이용하여 삽입 위치를 찾을 수 있지만 찾은 후에 기존 데이터를 하나씩 뒤로 이동해야 하므로 배열 기반 정렬 리스트에서 삽입의 시간 복잡도는 O(n)이다. \n\n정렬 리스트에서 요소가 복합 타입이면 정렬의 기준이 되는 키가 존재한다. 보통 리스트를 생성할 때 기준을 함께 제시하게 되며, 이 기준을 사용하는 중간에 보통 바꾸지 않으므로 키 기준이 아니라 다른 기준으로 리스트를 접근할 때는 효과적으로 접근하지 못할 수 있다. \n\n정렬 리스트와 비정렬 리스트를 비교하여 보자. 비정렬 리스트는 삽입이 정렬 리스트에 비해 효과적이다. 하지만 정렬 리스트는 저장된 값의 범위, 최댓값/최솟값, k번째 요소, 요소의 순위 등과 같은 정보를 비정렬 리스트에 비해 효과적으로 얻을 수 있다. \n\n배열 기반 리스트를 사용한다고 가정하고, 앞서 언급한 정보를 얻는 연산을 자주 많이 수행해야 한다면 정렬 리스트를 사용하는 것이 더 효과적이라고 생각할 수 있다. 하지만 데이터가 빈번하게 삽입, 삭제가 이루어지 않는 정적 데이터이면 데이터를 비정렬 리스트에 삽입한 후 정렬하여 사용하는 것이 더 효과적이다. 동적 데이터이면 정렬 리스트가 효과적일 수 있지만 실제 이 경우에는 정렬 리스트를 이용하는 것보다 더 효과적으로 사용할 수 있는 자료구조(9장에서 살펴보는 균형이진검색트리)가 있다. 따라서 리스트는 보통 비정렬 리스트를 사용한다.",
    "source": "ds03_2.1_리스트-비정렬과 정렬",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "리스트: 비정렬과 정렬",
      "section_number": "2.1",
      "section_heading": "## 2.1 비정렬과 정렬",
      "parent_section": "2. 리스트",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0037"
  },
  {
    "type": "텍스트북",
    "text": "## 2.2 중복 허용 여부 \n\n중복을 허용하지 않을 경우 요소를 추가하기 전에 해당 요소가 리스트에 있는지 검색하여야 한다. 내부 구현에 따라 이 비용은 O(n) 또는 O(log n)이 소요될 수 있다. 비정렬 리스트의 경우에는 중복을 허용하지 않을 경우 항상 O(n) 의 검색 비용이 소요되므로 상수 비용으로 요소를 추가할 수 있다는 비정렬 리스트의 장점이 퇴색된다. 따라서 중 복을 허용하지 않을 경우에는 정렬 리스트를 사용하는 것이 바람직하다. 정렬 리스트는 매번 요소를 추가할 때마다 반드시 삽입 위치를 찾아야 하기 때문에 중복을 허용하지 않기 위해 추가로 소요되는 비용이 없다. 정렬 리스트에서 중복을 허용할 경우 중복된 요소는 인접하여 유지된다.",
    "source": "ds03_2.2_리스트-중복 허용 여부",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "리스트: 중복 허용 여부",
      "section_number": "2.2",
      "section_heading": "## 2.2 중복 허용 여부",
      "parent_section": "2. 리스트",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0038"
  },
  {
    "type": "텍스트북",
    "text": "## 2.3 복사본 유지 \n\n자료구조가 유지해야 하는 데이터가 복합 타입일 때 데이터를 직접 유지하지 않고 그것의 참조나 주소를 유지하면 저장하는 비용을 줄일 수 있다. 하지만 데이터를 직접 유지하지 않으면 자료구조에서 제공하는 연산을 사용하지 않고 데이터에 접근하여 데이터의 내용을 변경할 수 있는 문제점이 있다. 이것은 리스트 ADT에만 해당되는 내용이 아니다. 자바나 파이썬처럼 참조 타입만을 이용하여 객체를 처리할 경우 객체를 자료구조에 저장할 때 특히 주의해야 한다. 물론 이 문제를 해결하기 위해 복사본을 저장할 경우에는 복사본을 추가로 생성하는 비용이 소요된다. 또 모든 타입에 데이터를 저장할 때 복사본을 저장할 필요는 없기 때문에 자료구조가 직접 복사본을 만들어 저장하기보다는 자료구조를 사용할 때 필요하면 복사본을 만들어 저장해야 한다. \n\n데이터 자체가 아니라 주소를 유지하면 삽입할 때 소요되는 비용을 줄일 수 있고, 요소들의 위치를 쉽게 서로 바꿀 수 있다. 하지만 데이터를 접근할 때 주소를 얻은 후 다시 주소를 통해 데이터에 접근해야 하며, 이 때문에 캐싱에 유리하다는 이점이 사라진다. 또 실제 데이터를 별도 관리해야 한다.",
    "source": "ds03_2.3_리스트-복사본 유지",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "리스트: 복사본 유지",
      "section_number": "2.3",
      "section_heading": "## 2.3 복사본 유지",
      "parent_section": "2. 리스트",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0039"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 배열을 이용한 리스트 구현 \n\n자료구조 구현을 실습할 때에는 다음과 같은 순서로 자료구조를 구현해 보는 것이 효과적이다. \n\n• 방법 1. 용량이 고정된 배열을 이용하여 정수를 유지하는 자료구조를 구현해 본다. 이때 각 메소드를 독립적 으로 코드 중복을 고려하지 않고 구현한다. \n\n• 방법 2. 방법 1의 구현 결과를 리펙토링하여 코드 중복을 제거한 최적화된 코드로 바꾸어 본다. \n\n• 방법 3. 동적 배열 기법을 적용하여 방법 2의 결과를 수정해 본다. \n\n• 방법 4. 범용 자료구조로 방법 3을 수정해 본다. \n\n리스트의 경우에는 위 과정을 비정렬과 정렬 리스트에 대해 각각 반복해 본다. 비정렬 리스트의 경우에는 이 과정을 내부적으로 순서를 유지하는 형태로 진행하고, 내부적으로 순서를 유지하지 않을 경우에 대해서는 방법 2 수준으로 한번 구현해본다. 실제 이와 같은 훈련을 반복하면 처음부터 최적화된 코드로 동적 배열 기법을 적용한 자료구조를 효과적으로 구현할 수 있게 된다.",
    "source": "ds03_3_배열을 이용한 리스트 구현",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현",
      "section_number": "3",
      "section_heading": "## 3. 배열을 이용한 리스트 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0040"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1 배열기반비정렬리스트구현",
    "source": "ds03_3.1_배열을 이용한 리스트 구현-배열기반비정렬리스트구현",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: 배열기반비정렬리스트구현",
      "section_number": "3.1",
      "section_heading": "## 3.1 배열기반비정렬리스트구현",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0041"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1.1 멤버변수와생성자 \n\n리스트 자료구조는 내부적으로 현재 용량 정보를 유지하는 capacity, 현재의 크기(저장된 요소의 개수)를 유지하 는 numItems, 실제 요소를 유지하는 items 배열을 멤버 변수로 유지해야 한다. 생성자는 기본 생성자와 초깃값 목록을 받는 생성자를 제공해야 하며, 동적 배열 기법을 적용할 경우에는 생성자에서 items에 필요한 용량의 배열을 동적할당해 주어야 한다.",
    "source": "ds03_1.1_배열을 이용한 리스트 구현-.1 멤버변수와생성자",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: .1 멤버변수와생성자",
      "section_number": "1.1",
      "section_heading": "## 3.1.1 멤버변수와생성자",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0042"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1.2 상태조회메소드 \n\n1 isEmpty():  2    return numItems==0  3  4 isFull():  5    return numItems==capacity  6  7 size():  8    return numItems \n\n## <그림 3.1> 비정렬 리스트: 상태 조회 메소드 \n\n리스트 자료구조는 보통 빈 상태 여부를 조회할 때 사용하는 isEmpty 메소드, 용량이 고정된 경우에는 용량 만큼 요소를 자료구조가 유지하고 있는지 여부를 알 수 있도록 해주는 isFull 메소드, 현재의 크기를 알려주는 size 메소드를 제공해 주어야 한다. 이 메소드의 의사코드는 그림 3.1과 같다.",
    "source": "ds03_1.2_배열을 이용한 리스트 구현-.2 상태조회메소드",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: .2 상태조회메소드",
      "section_number": "1.2",
      "section_heading": "## 3.1.2 상태조회메소드",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0043"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1.3 색인기반접근메소드 \n\n1 get(index):  2    if index<1 or index>numItems: throw IndexOutOfBoundsException  3    return items[index]  4  5 set(index, item):  6    if index<1 or index>numItems: throw IndexOutOfBoundsException  7    items[index] := item \n\n## <그림 3.2> 비정렬 리스트: get, set 메소드 \n\n리스트 자료구조는 색인을 이용하여 색인 위치에 있는 요소를 조회하거나 수정하는 메소드를 보통 제공한다. 특히, 배열 기반 리스트 구현에서는 배열이 임의 접근을 제공하기 때문에 색인 기반 접근 메소드를 효과적으로 제공할 수 있다. 이 메소드는 주어진 색인이 유효한 범위에 있는지 검사를 먼저 하고, 유효한 경우에만 처리해 주어야 한다. 색인 접근 메소드는 그림 3.2와 같다. 보통 색인 기반 접근 메소드에서 유효 범위 여부를 검사하는 부분은 checkRange와 같은 별도 메소드로 모듈화하여 코드 중복을 제거할 수 있다. 주어진 색인 위치에 있는 값을 수정하는 메소드의 이름을 set 대신에 replace를 사용하는 경우도 많다. \n\n색인 기반 연산 중 특정 위치에 요소를 삽입하는 연산도 제공할 수 있다. 이 경우 해당 위치부터 뒤에 있는 모든 요소를 하나씩 뒤로 이동해야 한다. 특정 위치에 있는 요소부터 맨 뒤에 있는 요소들을 하나씩 앞으로 또는 뒤로 이동하는 것은 다른 연산에서도 필요하다. 따라서 이들은 별도 모듈화(예: moveLeft, moveRight)하여 사용하는 것이 필요하다. 순서가 유지가 필요 없으면 기존 요소들을 이동하지 않고 색인 위치에 있는 요소만 맨 뒤에 삽입한\n\n\n1  insert(index, item):  2  if index<1 or index>numItems then throw IndexOutOfBoundsException  3  if isFull() then throw InvalidStateException  4  // if numItems==capacity then increaseCapacity()  5  for i:=numItems to index do  6  items[i+1] := items[i]  7  items[index] := item \n\n## <그림 3.3> 비정렬 리스트: insert 메소드 \n\n후에 새 요소를 색인 위치에 삽입할 수 있다. 삽입 연산 뿐만 아니라 색인 기반 삭제 연산도 비슷한 방법으로 제공할 수 있다. \n\ninsert처럼 데이터를 삽입하는 연산은 용량이 고정되어 있으면 isFull인지 검사해야 하며, 동적 배열 기법 에서는 현재 크기와 용량이 같은지 확인하고, 같으면 용량을 두 배로 확장한 다음에 데이터를 삽입해야 한다. 이 부분은 앞으로 다른 삽입 연산의 의사코드를 제시할 때 생략한다.",
    "source": "ds03_1.3_배열을 이용한 리스트 구현-.3 색인기반접근메소드",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: .3 색인기반접근메소드",
      "section_number": "1.3",
      "section_heading": "## 3.1.3 색인기반접근메소드",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0044"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1.4  찾기 연산 \n\n1  find(item):  2  for i:=1 to numItems do  3  if items[i]==item then return true  4  return false \n\n## <그림 3.4> 비정렬 리스트: 선형 검색 메소드 \n\n비정렬 리스트는 선형 검색을 해야 하지만 정렬 리스트는 이진 검색을 할 수 있다. 선형 검색의 의사코드는 그림 3.4와 같다. 검색 메소드에서 다음을 통해 리스트가 빈 상태의 경우에는 검색을 바로 중단하도록 할 수 있지만 해당 코드가 없어도 반복문이 반복하지 않고 종료하기 때문에 해당 코드의 추가를 통해 얻어지는 이득이 별로 없다. \n\n## 1 if isEmpty() then return false \n\n찾기 연산은 주어진 요소가 자료구조에 있는지 여부를 알려주기만 하면 되는데, 삭제 연산에서도 찾기 연산의 사용이 필요하고, 정렬 리스트에서는 삽입할 때도 삽입할 위치를 찾아야 한다. 또 중복을 허용하지 않으면 비정렬 리스트에서도 삽입하기 전에 이미 저장한 요소인지 확인을 해야 한다. 따라서 내부적으로 찾은 위치를 반환하여 주는 메소드를 이용하여 다음과 같이 코드 중복을 제거하는 것이 효과적이다. \n\n1 find(item): \n\n2 return search(item)!= -1 \n\n여기서 search 메소드는 그림 3.4에서 true나 false를 반환하는 대신에 요소가 있는 경우 해당 위치를 반환하는 메소드이다. search 메소드에서 요소가 없을 때 -1을 반환할 수 있고, 색인 변수의 타입에 따라 -1이 아니라 다른 값을 반환할 수도 있다. \n\n언어 라이브러리의 경우 이 절에서 설명한 앞에서부터 찾는 연산 뿐만 아니라 뒤에서부터 찾는 연산도 종종 제공한다. 보통 이들을 구분하기 위해 이들 연산의 이름을 각각 firstndex0f, lastIndex0f라 한다.",
    "source": "ds03_1.4_배열을 이용한 리스트 구현-.4  찾기 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: .4  찾기 연산",
      "section_number": "1.4",
      "section_heading": "## 3.1.4  찾기 연산",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0045"
  },
  {
    "type": "텍스트북",
    "text": "### 3.1.5 맨 앞과 맨 뒤 삽입 추출 연산 \n\n배열 기반 자료구조는 맨 뒤에 삽입과 추출은 효과적이지만 중간이나 맨 앞에 삽입과 추출은 효과적이지 못하다. 맨 앞에 삽입하기 위해서는 기존 모든 요소를 하나씩 뒤로 이동해야 하고, 맨 앞에서 추출하기 위해서는 두 번째 색인부터 모든 요소를 하나씩 앞으로 이동해야 한다. 특정 위치에 있는 요소부터 맨 뒤에 있는 요소들을 하나씩 앞으로 또는 뒤로 이동하는 것은 일반 삭제 연산에서도 필요하다. 따라서 이들을 별도 모듈화하는 것이 필요하다. \n\n1. pushback(item):\n2. items[numItems+1] := item\n3. ++numItems \n\n<그림 3.5> 비정렬 리스트: pushback 메소드 \n\n1. popback():\n2. if isEmpty() then throw InvalidStateException\n3. ret := items[numItems]\n4. -numItems\n5. return ret \n\n<그림 3.6> 비정렬 리스트: popback 메소드 \n\n맨 뒤에 삽입과 추출하는 pushback, popback 연산의 의사코드는 각각 그림 3.5와 그림 3.6과 같다. popback 은 빈 상태인지 검사를 해야 한다. pushback은 데이터를 삽입하기 전에 insert와 비슷한 검사를 해야 한다. \n\n1. pushfront(item):\n2. for i:=numItems downto 1 do\n3. items[i+1] := items[i]\n4. items[1] := item\n5. ++numItems \n\n<그림 3.7> 비정렬 리스트: pushfront 메소드 \n\n맨 앞에 삽입과 추출하는 pushfront, popfront 연산의 의사코드는 각각 그림 3.7과 그림 3.8과 같다. pushfront는 pushback 메소드와 마찬가지로 리스트의 현재 상태를 먼저 확인하고 예외 처리를 하거나 용량을 확장해 주는 것이 필요하다. pushfront와 popfront 연산은 이처럼 O(n) 비용이 소요되므로 배열 기반 리스트 자료구조를 사용할 경우에는 불가피한 경우가 아니면 사용하지 않아야 한다. 보통 이와 같은 4개 연산을 만들면 맨 앞에 있는 요소와 맨 뒤에 있는 요소를 조회만하는 peekfront, peekback도 함께 제공한다.",
    "source": "ds03_1.5_배열을 이용한 리스트 구현-### 3.1.5 맨 앞과 맨 뒤 삽입 추출 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: ### 3.1.5 맨 앞과 맨 뒤 삽입 추출 연산",
      "section_number": "1.5",
      "section_heading": "### 3.1.5 맨 앞과 맨 뒤 삽입 추출 연산",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0046"
  },
  {
    "type": "텍스트북",
    "text": "### 3.1.6 삭제 연산 \n\n삭제는 색인을 주어 색인 위치에 있는 요소를 삭제하는 연산을 제공할 수 있지만 보통은 요소를 주어 해당 요소를 찾아 삭제해 주는 연산을 제공한다. 중복된 요소를 유지하는 자료구조의 경우에는 하나만 삭제하는 연산과 중복된 요소를 모두 삭제하는 연산 두 가지 종류를 제공할 수 있다. 하나만 삭제해주는 연산의 경우 비정렬 리스트에서는 선형 검색만 가능하므로 첫 번째 색인부터 순차적으로 검색하여 처음 만나는 요소를 삭제해 주는 연산을 보통 제공한다. 삭제 연산은 찾기부터 해야하므로 요소의 위치를 반환하여 주는 연산을 만들고 이를 이용하여 삭제 연산을 만드는 것이 효과적이다. 찾기 연산에서 사용한 search을 이용한 removeFirst 연산의 의사코드는 그림 3.9와 같다. \n\n중복된 모든 요소를 삭제하는 연산은 요소를 하나만 삭제하는 연산을 반복하는 형태로 구현한다. 하지만 항상 첫 요소부터 다시 찾는 것은 효과적이지 않으므로 요소를 하나 삭제한 후에는 그림 3.10처럼 해당 위치부터 다시\n\n\n1 popfront():  2 if isEmpty() then throw InvalidStateException  3 ret := items[1]  4 for i:=2 to numItems do  5 items[i-1] := items[i]  6 - - numItems  7 return ret \n\n<그림 3.8> 비정렬 리스트: popfront 메소드 \n\n1 removeFirst(item):  2 index := search(item)  3 if index != -1 then  4 for i := index+1 to numItems do  5 items[i-1] := items[i]  6 - - numItems \n\n<그림 3.9> 비정렬 리스트: removeFirst 메소드 \n\n찾는 형태로 구현해야 한다. 이를 위해서는 removeFirst에서 사용한 인자를 하나 받는 search 메소드가 아니 라 특정 위치부터 찾아주는 search 메소드가 필요하다. search가 루프 밖과 안에 중복되어 있는 것이 싫으면 그림 3.11처럼 구현하는 것도 가능하다.",
    "source": "ds03_1.6_배열을 이용한 리스트 구현-### 3.1.6 삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열을 이용한 리스트 구현: ### 3.1.6 삭제 연산",
      "section_number": "1.6",
      "section_heading": "### 3.1.6 삭제 연산",
      "parent_section": "3. 배열을 이용한 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0047"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 배열 기반 정렬 리스트 구현",
    "source": "ds03_4_배열 기반 정렬 리스트 구현",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열 기반 정렬 리스트 구현",
      "section_number": "4",
      "section_heading": "## 4. 배열 기반 정렬 리스트 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0048"
  },
  {
    "type": "텍스트북",
    "text": "## 4.1 차이점 \n\n필요한 멤버 변수나 상태 조회 메소드는 비정렬이나 정렬 리스트나 차이가 없다. 차이가 있는 부분은 다음과 같다. \n\n• 비정렬 리스트는 기본적으로 중복을 허용하지만 정렬 리스트는 중복 허용할 수 있고, 허용하지 않을 수도 있다. \n\n• 색인 기반 접근 메소드 중 set, insert를 그대로 사용하면 정렬된 상태가 깨질 수 있다. \n\n• find는 선형 검색 대신에 이진 검색을 할 수 있다. \n\n• pushback, pushfront도 그대로 사용하면 정렬된 상태가 깨질 수 있다. \n\n• 중복을 허용하는 정렬 리스트의 경우 같은 요소는 인접해 있기 때문에 중복된 요소를 모두 제거하는 연산은 이 점을 고려하여 구현해야 한다. \n\n이와 같은 이유로 set, insert, pushback, pushfront을 제공하지 않을 수 있고, 이 중 일부만 유효할 경우에만 처리하도록 제공할 수 있다. 예를 들어 set은 현재 정렬 상태가 유지될 경우에만 바꾸어주도록 연산을 만들어 제공할 수 있다.",
    "source": "ds03_4.1_배열 기반 정렬 리스트 구현-차이점",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열 기반 정렬 리스트 구현: 차이점",
      "section_number": "4.1",
      "section_heading": "## 4.1 차이점",
      "parent_section": "4. 배열 기반 정렬 리스트 구현",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0049"
  },
  {
    "type": "텍스트북",
    "text": "## 4.2 이진 검색\n\n\n1 removeAll(item):  2 index := search(item, 1)  3 while index!=1 do  4 for i:=index+1 to numItems do  5 items[i-1] := items[i]  6 --numItems  7 index = search(item, index) \n\n<그림 3.10> 비정렬 리스트: removeAll 메소드 버전 1 \n\n1 removeAll(item):  2 index := 1  3 while true do  4 index := search(item, index)  5 if index==-1 then break  6 for i:=index+1 to numItems do  7 items[i-1] := items[i]  8 --numItems \n\n<그림 3.11> 비정렬 리스트: removeAll 메소드 버전 2 \n\n이진 검색의 의사코드는 그림 3.12와 같다. 이진 검색은 한번에 고려 대상을 절반으로 줄이기 때문에 시간 복잡 도가 O(log n)이다. 이진 검색에서 중앙 위치를 찾을 때 범위에 따라 (l o+hi) /2를 사용하면 오버플로우가 발생할 수 있으니 구현할 때 주의해야 한다. \n\n또 있다 없다 유무만 알려주는 것이 아니라 위치를 반환하는 형태로 만들 경우에는 다음을 고려해야 한다. \n\n• 정렬 리스트에서 삽입 연산은 삽입 위치가 필요하기 때문에 이진 검색이 실패한 경우 해당 요소를 삽입할 위치를 주어야 한다. \n\n• 삽입할 위치를 반환할 경우 lo 또는 hi 변수값을 반환하게 되는데, 어떤 것을 이용하더라도 현재 배열의 유효 범위를 벗어날 수 있다. \n\n그러면 lo와 hi 중 어떤 것을 반환하는 것이 적합할까? 이를 위해 배열이 다음과 같은 상태에서 최솟값보다 작은 값을 검색하는 경우, 최댓값보다 큰 값을 검색하는 경우, 범위 내에 있지만 현재 리스트에 없는 값을 검색하는 경우에 lo와 hi가 어떻게 되는지 살펴보자. \n\n[2,3,5,7,9,11,13] \n\n먼저 6을 검색한 경우에 lo와 hi 값이 어떻게 바뀌는지 살펴보면 다음과 같다. \n\n1 find(item):  2 lo := 1  3 hi := numItems  4 while lo<=hi do  5 mid := lo + (hi-lo)/2  6 if items[mid]==item then return true  7 else if items[mid]<item then lo := mid+1  8 else hi := mid-1  9 return false \n\n<그림 3.12> 정렬 리스트: 이진 검색 메소드\n\n\n<table><tr><td>search(6)</td><td>lo</td><td>1</td><td>1</td><td>3</td><td>4</td></tr><tr><td></td><td>hi</td><td>7</td><td>3</td><td>3</td><td>3</td></tr><tr><td></td><td>mid</td><td>4</td><td>2</td><td>3</td><td></td></tr></table>\n\n그다음 최솟값보다 작은 1을 검색한 경우에는 다음과 같다. \n\n<table><tr><td>search(1)</td><td>lo</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td></td><td>hi</td><td>7</td><td>3</td><td>1</td><td>0</td></tr><tr><td></td><td>mid</td><td>4</td><td>2</td><td>1</td><td></td></tr></table>\n\n마지막으로 최댓값보다 큰 14를 검색한 경우에는 다음과 같다. \n\n<table><tr><td>search(14)</td><td>lo</td><td>1</td><td>5</td><td>7</td><td>8</td></tr><tr><td></td><td>hi</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td></td><td>mid</td><td>4</td><td>6</td><td>7</td><td></td></tr></table>\n\n결과를 살펴보면 lo는 기존 최솟값보다 작은 경우에만 올바른 삽입 위치를 주지 못하고, hi는 기존 최솟값보다 작은 경우를 제외하고 hi+1 위치가 올바른 삽입 위치가 된다. 따라서 기존 최솟값보다 작은 경우를 제외하면 lo를 사용하는 것이 효과적이다. 물론 모든 경우에 올바른 위치를 제시하기 위해 마지막에 lo를 반환하기 전에 검사하고 수정을 할 수 있지만 실제 삽입 연산에서 삽입할 데이터가 기존 최솟값보다 작은 경우와 기존 최댓값보다 큰 경우에는 다르게 최적화할 수 있기 때문에 별도 보정 없이 lo를 반환하는 것만으로 충분하다.",
    "source": "ds03_4.2_배열 기반 정렬 리스트 구현-이진 검색",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열 기반 정렬 리스트 구현: 이진 검색",
      "section_number": "4.2",
      "section_heading": "## 4.2 이진 검색",
      "parent_section": "4. 배열 기반 정렬 리스트 구현",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0050"
  },
  {
    "type": "텍스트북",
    "text": "## 4.3 삽입 연산 \n\n1. add(item):\n2. insertLoc := -1\n3. if isEmpty() or items[numsItem]<=item then insertLoc := numsItem+1\n4. else if items[1]>=item then insertLoc := 1\n5. else insertLoc := search(item)\n6. for i:=numsItems downto insertLoc do\n7. items[i+1] := items[i]\n8. items[insertLoc] := item\n9. ++numsItems \n\n<그림 3.13> 정렬 리스트: 삽입 메소드 \n\n정렬 리스트에서 삽입은 먼저 삽입할 위치를 찾아야 한다. 이때 이진 검색을 사용할 수 있는데, 삽입된 데이터가 정렬된 상태로 유지하고 있으므로 간단한 검사를 통해 맨 앞에 삽입해야 하는 경우와 맨 뒤에 삽입해야 하는 경우를 판별할 수 있다. 현재 저장된 요소의 최솟값보다 같거나 작은 경우, 현재 저장된 요소의 최댓값과 같거나 큰 경우, 리스트가 빈 경우에는 이진 검색 없이 처리할 수 있다. 이를 고려한 삽입 연산의 의사코드는 그림 3.13과 같다.",
    "source": "ds03_4.3_배열 기반 정렬 리스트 구현-삽입 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열 기반 정렬 리스트 구현: 삽입 연산",
      "section_number": "4.3",
      "section_heading": "## 4.3 삽입 연산",
      "parent_section": "4. 배열 기반 정렬 리스트 구현",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0051"
  },
  {
    "type": "텍스트북",
    "text": "## 4.4 삭제 연산 \n\n비정렬 리스트와 비교하여 차이점은 삭제할 요소를 찾기 위해 이진 검색을 사용할 수 있다는 것과 중복된 요소들이 인접해 있다는 것이다. 중복된 요소를 모두 삭제하는 연산의 의사코드는 그림 3.14와 같다. search에서 값을 찾을 경우 그 위치부터 아래로 선형 탐색하여 중복 요소 중 첫 번째 요소를 반환하도록 수정하면 첫번째 while문 없이 구현할 수 있다. 하지만 이 기능은 그것을 하는 위치만 바뀔 뿐이며, removeAll에서만 필요한 기능이므로 이 수정은 별로 이득이 없다.\n\n\n1 removeAll(item): \n\n2 insertLoc := search(item) \n\n3 if insertLoc is valid and items[insertLoc]==item then \n\n4 lo = hi = insertLoc \n\n5 while lo-1>=1 and items[lo-1]==item do --lo \n\n6 while hi+1<=numItems and items[hi+1]==item do ++hi \n\n7 count := hi-lo+1 \n\n8 for i:=hi+1 to numItems do \n\n9 items[lo] = items[i] \n\n10 ++lo \n\n11 numItems -= count \n\n<그림 3.14> 정렬 리스트: removeAll 메소드 \n\n<table><tr><td></td><td>3</td><td>1</td><td>5</td></tr><tr><td>head=3, tail=0</td><td></td><td></td><td></td></tr></table>\n\n<table><tr><td>2</td><td></td><td>3</td><td>1</td><td>5</td></tr><tr><td>head=3, tail=1</td><td></td><td></td><td></td><td></td></tr></table>\n\n<그림 3.15> 순환 배열: pushback(2)",
    "source": "ds03_4.4_배열 기반 정렬 리스트 구현-삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "배열 기반 정렬 리스트 구현: 삭제 연산",
      "section_number": "4.4",
      "section_heading": "## 4.4 삭제 연산",
      "parent_section": "4. 배열 기반 정렬 리스트 구현",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0052"
  },
  {
    "type": "텍스트북",
    "text": "## 5. 순환 배열 \n\n배열을 이용한 리스트 구현은 맨 뒤에 추가하는 것은 효과적이지만 삽입된 순서를 유지하고자 하면 맨 앞에 삽입하는 것은 효과적이지 못하다. 또 특정 색인 위치를 바로 접근할 수 있지만 그 위치에 새 데이터를 삽입하거나 해당 데이터를 제거하는 것은 그 뒤 데이터를 하나씩 뒤로 이동해야 하므로 비용이 비싸다. \n\n순환 배열(circular array list)은 기존 배열 구현에서 맨 앞 요소의 색인과 맨 뒤 요소의 색인을 추가로 유지한다. 맨 앞 요소의 색인은 1로 고정되지 않으며 배열 맨 끝에 데이터가 있을 때 시작 위치가 1이 아니면 그림 3.15처럼 그다음 요소를 맨 뒤에 삽입하면 이 요소는 색인 1 위치에 저장한다. 이를 통해 맨 뒤 뿐만 아니라 맨 앞에 삽입과 추출을 효과적으로 할 수 있다. 순환 배열을 동적 배열 방식으로 구현할 경우 용량을 늘려야 할 때 새 배열에 기존 요소를 옮겨야 한다. 이때 기존 위치 그대로 이동할 수 없고 첫 번째 색인이 1이 되도록 옮겨야 한다.",
    "source": "ds03_5_순환 배열",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "순환 배열",
      "section_number": "5",
      "section_heading": "## 5. 순환 배열",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0053"
  },
  {
    "type": "텍스트북",
    "text": "### 5.1 맨버 변수 \n\n기존에 유지한 현재 용량을 나타내는 capacity, 현재 저장된 요소의 개수를 나타내는 numItems, 요소를 유지하는 배열 items에 추가적으로 head와 tail 멤버 변수를 유지해야 한다. head는 첫 번째 요소가 저장된 위치이고, tail은 마지막 요소가 저장된 위치 또는 새 요소를 pushback할 때 저장할 위치를 나타낸다. 이 교재에서는 tail은 후자를 나타내도록 구현한다. 이 경우 이 두 변수의 초깃값은 어떻게 설정하는 것이 좋은가? tail은 새 요소를 pushback할 때 저장할 위치이므로 1로 초기화하면 된다. 반면에 초기에는 요소가 하나도 없는 상태이므로 head를 1로 설정하는 것이 적절하지 않다고 생각할 수 있다. 이 경우 0으로 설정할 수도 있다. 그런데 C++처럼 부호가 없는 경우는 head와 tail를 사용하면 0색인을 가정하였을 -1로 초기화해야 하는데, 이것이 가능하지 않은 문제도 있다. 더욱이 pushback는 head-1 위치에 삽입하는 형태로 구현하므로 head를 1로 초기화하는 것이 여러 측면에서 효과적이다. \n\nhead와 tail를 모두 1로 초기화한 상태에서 이 두 정보만 이용하여 빈 상태와 짝찬 상태를 계산할 수 있는지 생각하여 보자. 용량이 3이고 처음부터 차례로 3개 요소를 삽입할 경우 head와 tail이 어떻게 바뀌는지 살펴보자.\n\n\n<table><tr><td></td><td>빈 상태</td><td>pushback(3)</td><td>pushback(5)</td><td>pushback(1)</td></tr><tr><td>head</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>tail</td><td>1</td><td>2</td><td>3</td><td>1</td></tr></table>\n\n살펴본 바처럼 빈 상태와 짝찬 상태가 모두 head와 tail 값이 같다. 따라서 head와 tail만 이용하여 빈 상태와 짝찬 상태를 구분하기 어렵다. 하지만 공간 하나를 항상 사용하지 않는 형태로 구현하면 빈 상태와 짝찬 상태를 head와 tail만 이용하여 구분할 수 있다. 실제 빈 상태와 짝찬 상태의 파악은 head와 tail를 이용하지 않고 numItems을 이용하는 것이 더 편리하다. \n\n저장된 요소의 개수는 다음을 통해 계산할 수 있지만 이 역시 numItems을 유지하는 것이 더 편리하다. \n\n1. (tail + (capacity-head)) mod capacity",
    "source": "ds03_5.1_순환 배열-### 5.1 맨버 변수",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "순환 배열: ### 5.1 맨버 변수",
      "section_number": "5.1",
      "section_heading": "### 5.1 맨버 변수",
      "parent_section": "5. 순환 배열",
      "parent_section_number": "5",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0054"
  },
  {
    "type": "텍스트북",
    "text": "## 5.2 동적 배열 \n\n배열 기반 리스트에서 용량을 확장할 때 기존보다 두 배 큰 용량을 확보한 후에 보통 메모리 복사를 이용하여 효율적으로 기존 데이터를 새 공간에 옮길 수 있다. 하지만 순환 배열에서는 그대로 메모리 복사를 할 수 없다. 다음 두 가지 방법을 이용하여 동적 배열 기법을 적용할 수 있다. \n\n- 방법 1. 새 공간으로 데이터를 옮길 때 head가 1이 되도록 옮긴다. \n\n- 방법 2. 새 공간으로 데이터를 옮길 때 head의 위치가 바뀌지 않도록 옮긴다. \n\n두 방법 모두 두 번의 메모리 복사가 필요하다. 먼저 기존 공간에서 head부터 numItems까지 요소를 메모리 복사한 후에 그 다음 1부터 tail까지 요소를 메모리 복사를 해야 한다.",
    "source": "ds03_5.2_순환 배열-동적 배열",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "순환 배열: 동적 배열",
      "section_number": "5.2",
      "section_heading": "## 5.2 동적 배열",
      "parent_section": "5. 순환 배열",
      "parent_section_number": "5",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0055"
  },
  {
    "type": "텍스트북",
    "text": "## 5.3 반복자 \n\n순환 배열의 경우 연속적으로 요소가 저장되어 있는 것이 아니기 때문에 반복의 종료 시점을 판단하는 것이 간단하지 않다. 보통은 첫 번째 색인부터 리스트의 크기를 이용하여 종료 조건을 판단하면 되지만 순환 배열은 head부터 시작하여 중간에 첫 색인으로 이동해야 할 수 있고, 빈 상태와 짝찬 상태일 때 head와 tail의 상태가 같아 두 변수만을 이용하여 처리하기 힘들다. 특히, C++처럼 두 객체를 이용해 반복자를 처리하는 경우는 더욱 힘들다. 보통 리스트의 개수를 이용하여 반복자를 구현한다. 물론 공간을 하나 사용하지 않으면 배열 기반 일반 리스트 반복자와 유사하게 구현할 수 있다. \n\n1. hasNext(): 2. return visited<numItems 3. 4. next(): 5. ret := items[curr] 6. curr = (curr + 1) % capacity 7. ++visited 8. return ret \n\n<그림 3.16> 정렬 리스트: removeAll 메소드",
    "source": "ds03_5.3_순환 배열-반복자",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "순환 배열: 반복자",
      "section_number": "5.3",
      "section_heading": "## 5.3 반복자",
      "parent_section": "5. 순환 배열",
      "parent_section_number": "5",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0056"
  },
  {
    "type": "텍스트북",
    "text": "일반적인 반복자 패턴을 고려하여 순환 배열에 대한 hasNext와 next 메소드의 의사코드를 제시하면 그림 3.16 와 같다. 여기서 visited는 0으로 초기화하고, curr는 head로 초기화해야 한다.",
    "source": "ds03_3.16_순환 배열-일반적인 반복자 패턴을 고려하여 순환 배열에 대한 hasNext와 next 메소드의 의사코드를 제시하면 그림 3.16 와 같다. 여기서 visited는 0으로 초기화하고, curr는 head로 초기화해야 한다.",
    "meta_data": {
      "tables": [],
      "book_title": "제3장 배열 기반 리스트",
      "chapter": "",
      "section": "순환 배열: 일반적인 반복자 패턴을 고려하여 순환 배열에 대한 hasNext와 next 메소드의 의사코드를 제시하면 그림 3.16 와 같다. 여기서 visited는 0으로 초기화하고, curr는 head로 초기화해야 한다.",
      "section_number": "3.16",
      "section_heading": "일반적인 반복자 패턴을 고려하여 순환 배열에 대한 hasNext와 next 메소드의 의사코드를 제시하면 그림 3.16 와 같다. 여기서 visited는 0으로 초기화하고, curr는 head로 초기화해야 한다.",
      "parent_section": "5. 순환 배열",
      "parent_section_number": "5",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0057"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 연결구조 \n\n![](images/0_0.jpg)\n\n<center><그림 4.1> 단일 연결구조</center> \n\n연결구조(linked list)는 동적 자료구조를 구현할 때 내부적으로 사용할 수 있는 기법 중 하나이다. 연결구조는 배열과 달리 연속된 공간을 확보하여 데이터를 저장하지 않고, 새 데이터를 삽입할 때마다 공간을 확보하여 저장 한다. 하지만 각 데이터의 저장된 위치 정보를 별도 유지하는 것이 아니라 그림 4.1과 같이 각 데이터를 저장할 때 데이터와 다음 데이터의 위치 정보를 유지하는 노드를 만들어 저장한다. 이를 통해 모든 데이터를 선형적으로 연결하여 사용하고, 이 연결의 맨 앞에 있는 노드의 위치 정보만 기본적으로 유지한다. 이 정보를 유지하는 변수를 보통 머리(head) 포인터라 한다. 이 때문에 배열과 달리 임의 접근을 제공하지 못한다. 연결 중간에 있는 데이터에 접근하기 위해서는 첫 노드부터 하나씩 방문하면서 순차적으로 접근할 수밖에 없다. \n\n같은 이유로 배열에서는 맨 뒤에 저장하는 것이 가장 저렴한 반면에 보통 연결구조에서는 맨 앞에 추가하는 것이 가장 저렴하다. 물론 그림 4.1처럼 연결구조에서도 마지막 노드의 위치 정보를 유지하면 맨 뒤에 추가하는 것도 저렴하게 할 수 있다. 마지막 노드를 가리키는 변수를 보통 꼬리(tail) 포인터라 한다. 그러나 이 정보를 가지고 있더라도 맨 뒤에서 저렴하게 추출할 수 없다. \n\n기본적인 연결구조는 단일 연결구조(singly/single linked)로 현재 노드에서 후속 노드의 위치 정보만 노드에 유지한다. 따라서 현재 노드에서 다음 노드로 이동할 수 있지만 뒤로는 이동이 가능하지 않다. 맨 뒤에서 추출하기 위해서는 마지막 노드의 이전 노드 연결을 끊어주어야 하고, 이전 노드를 꼬리 포인터가 가리키도록 바꾸어 주어야 하는데, 맨 뒤 노드에서는 뒤로 이동이 가능하지 않기 때문에 추출을 저렴하게 할 수 없다. 이 문제는 한 노드가 선 행과 후속 노드에 대한 위치 정보를 모두 유지하면 해결할 수 있다. 이와 같이 노드가 두 개의 연결 정보를 유지하는 연결구조를 이중 연결구조(doubly/double linked)라 하며, 이에 대해서는 5장에서 살펴본다.",
    "source": "ds04_1_연결구조",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "연결구조",
      "section_number": "1",
      "section_heading": "## 1. 연결구조",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds04/images/0_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0058"
  },
  {
    "type": "텍스트북",
    "text": "## 1.1 배열 vs. 연결구조 \n\n배열의 가장 큰 장점은 임의 접근이 가능하다는 것이다. 요소의 위치와 무관하게 각 요소를 접근하는데 소요되는 비용이 같다는 것을 의미한다. 하지만 임의 접근을 제공하기 위해 연속적인 공간을 최초 생성할 때 확보하여야 하며, 확보된 공간을 현재 위치에서 늘리는 것은 가능하지 않다. 물론 동적 배열 기법을 사용할 수 있지만 응용에 따라 중간에 낭비되는 공간이나 새 공간을 확보한 후 복사하는 비용이 부담될 수 있다. 연결구조는 이와 달리 공간을\n\n\n낭비하는 경우가 전혀 없으며, 기본적으로 동적이다. 즉, 용량을 확보하여 사용하는 것이 아니기 때문에 메모리가 허용되는 이상 계속 데이터를 추가할 수 있다. 물론 데이터를 하나 저장할 때마다 새 공간을 확보해야 하고, 데이터 외에 연결정보를 유지해야 하기 때문에 성능과 공간 측면에서 모두 추가 비용이 발생하는 것은 불가피하다. 또한 임의 접근을 제공하지 못하고 순차 접근만 가능하다. \n\n그러면 배열과 연결구조 중 어떤 방식으로 리스트를 구현하는 것이 더 효과적인가? 이것에 대해 항상 맞는 답은 없다. 응용의 필요에 따라 더 효과적인 방식이 달라질 수 있다. 따라서 응용에서 리스트 자료구조가 필요할 때 다음과 같은 사항을 고려하여 선택하여야 한다. 하지만 실제 어느 방식이 더 효과적이라고 판단하는 것이 쉽지 않다. \n\n- 고려사항 1. 유지해야 할 요소의 개수를 사전에 알 수 있는가? \n\n- 고려사항 2. 어떤 방식의 데이터 삽입과 추출이 필요한가? \n\n- 고려사항 3. 저장된 데이터를 이용하여 어떤 작업을 주로 수행해야 하는가? \n\n보통 사전에 저장할 요소의 개수를 알 수 있다면 배열을 사용하는 것이 효과적일 수 있다. 낭비되는 공간 없이 임의 접근을 제공할 수 있기 때문이다. 하지만 이때에도 최종적으로 n개가 필요하다는 것을 알지만 n개의 데이터를 모두 삽입할 때까지 많은 시간이 소요되면 처음부터 n개 공간을 확보하는 것이 효과적이지 않을 수 있다. \n\n<표 4.1> 맨 앞과 맨 뒤 삽입 추출 연산의 비교 \n\n<table><tr><td>연산</td><td>배열 기반 리스트</td><td>연결구조 기반 리스트</td></tr><tr><td>pushback</td><td>O(1)</td><td>꼬리 포인터 유지하면 O(1)</td></tr><tr><td>popback</td><td>O(1)</td><td>꼬리 포인터를 유지하는 이중연결구조이면 O(1) 아니면 O(n)</td></tr><tr><td>pushfront</td><td>순환 배열 방식이면 O(1) 아니면 O(n)</td><td>O(1)</td></tr><tr><td>popfront</td><td>순환 배열 방식이면 O(1) 아니면 O(n)</td><td></td></tr></table>\n\n각 종 연산 구현 측면에서 비교하여 보자. 먼저 맨 앞과 맨 뒤 삽입 추출 연산을 비교하면 표 4.1와 같다. 반복적으로 언급하고 있지만 배열 기반은 기본적으로 맨 뒤 삽입과 추출이 효과적이고, 연결구조 기반은 맨 앞 삽입과 추출이 효과적이다. 순환 배열 방식을 사용하면 4가지를 모두 O(1)에 제공할 수 있고, 꼬리 포인터를 유지하는 이중 연결구조이어도 4가지를 모두 O(1)에 제공할 수 있다. 물론 배열 방식은 동적 배열 기법의 사용에 따라 중간에 확장하는 비용이 소요될 수 있다. \n\n이것을 바탕으로 고려사항 2를 생각해 보자. 리스트 앞과 뒤로 주로 접근하면 연결구조도 좋은 대안이 될 수 있다. 특히, 양쪽으로 모두 접근이 필요하면 구현 측면에서는 순환 배열보다 연결 구조가 더 간결하게 구현할 수 있다. 한쪽으로만 이루어지면 고려사항 1을 추가로 검토하여 어떤 방식을 사용할지 결정해야 한다. 색인 기반 연산을 주로 사용하면 임의 접근이 가능한 배열이 훨씬 효과적인 방식이다. \n\n보통 배열과 연결구조를 비교할 때 중간 삽입하는 비용을 고려하면 연결구조가 더 좋다고 말하는 경우도 있다. 실제 중간에 삽입하는 비용만 생각하면 연결구조가 우수하다. 하지만 그 위치를 찾아가는 비용을 고려한다면 이 비교가 이렇게 단순하지 않다. 보통 중간 삽입 비용을 극대화하고자 하면 값과 연결구조에서 값이 저장된 노드 위치를 유지하는 맨 자료구조를 추가적으로 사용해야 한다. 맨 자료구조는 10장에서 살펴본다. \n\n정렬 리스트의 경우 배열은 이진 검색하여 위치를 찾아갈 수 있지만 연결 구조는 순차 검색만 가능하다. 하지만 찾기 연산을 제외하고는 다른 연산들은 시간 복잡도가 같다. 예를 들어 삭제 연산을 생각하여 보자. 배열 기반은 이진 검색을 통해 삭제할 요소를 찾을 수 있지만 순서를 유지하기 위해 그다음 요소들을 모두 앞으로 하나씩 이동해야 하면 결과적으로 O(n) 비용이 필요하다. 연결구조는 이진 검색을 할 수 없어 선형 검색으로 요소를 찾아야 하지만 찾은 후에는 상수 비용으로 삭제할 수 있으므로 배열 기반과 마찬가지로 O(n) 비용이 필요하다. 또 한 가지 생각\n\n\n못하는 차이점은 배열은 연속 공간에 확보하기 때문에 캐시 사용에 있어 더 유리한 측면이 있으며, 이것이 성능에 큰 영향을 줄 수 있다.",
    "source": "ds04_1.1_연결구조-배열 vs. 연결구조",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "연결구조: 배열 vs. 연결구조",
      "section_number": "1.1",
      "section_heading": "## 1.1 배열 vs. 연결구조",
      "parent_section": "1. 연결구조",
      "parent_section_number": "1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0059"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 단일 연결구조 기반 비정렬 리스트 구현 \n\n연결구조에서 각종 연산은 머리 포인터와 꼬리 포인터의 갱신, 노드의 생성, 노드의 연결 정보 갱신을 통해 이루어 진다. 이때 순서가 매우 중요하다. 예를 들어 맨 앞에 새 노드를 추가할 경우 새 노드의 연결 정보를 먼저 갱신한 다음 머리 포인터를 갱신해야 하는데, 거꾸로 하면 새 노드가 기존 머리 노드를 가리키도록 만들 수 없다. 따라서 각 연산을 구현하기 전에 먼저 그림이나 의사코드로 순서를 잘 생각한 다음 구현할 필요가 있다. \n\n연결구조는 이처럼 포인터를 이용한 구현이 주가 되므로 각 포인터를 사용하기 전에 이 포인터가 널포인터인 지 확인해야 한다. 연결구조 프로그래밍을 할 때 실행 시간에 프로그램이 중단되는 경우는 이와 같이 널포인터인 포인터를 조작한 경우가 대부분이다. \n\n단일 연결구조의 경우 순차 검색을 통해 조작해야 하는 노드를 찾아간다. 그런데 이때 현재 노드를 가리키는 포인터 뿐만 아니라 바로 이전 노드를 가리키는 포인터가 필요할 경우가 많다. 이 경우 두 개의 포인터를 이용하여 순차 검색을 하면 효과적으로 구현할 수 있다. 물론 현재 노드가 아니라 이전 노드에서 다음 노드를 처리하는 형태로 구현하면 한 개의 포인터만을 이용하여 구현할 수 있다. 참고로 5장에서 살펴보는 이중 연결구조는 노드에서 선행 및 후속 노드로 이동할 수 있으므로 두 개의 포인터를 이용할 필요가 없다. \n\n두 개의 포인터를 사용할 때 이전 노드를 가리키는 prev 변수는 보통 널포인터 값으로 초기화한다. 하지만 이 경우 나중에 prev가 널포인터인지 여부를 확인해야 하는 번거로움이 있다. 이 때문에 더미(dummy) 노드를 첫 노드 앞에 추가하여 사용할 수 있다. 연결구조 자체를 항상 더미 노드를 사용하는 형태로 구현할 수 있고, 특정 연산을 구현할 때만 더미 노드를 만들어 사용할 수 있다. \n\n보통 연결구조에서 연산을 구현할 때 맨 앞, 중간, 맨 뒤 3가지 경우에 어떤 차이가 있는지 살펴보고, 차이가 있을 경우 이 차이를 올바르게 구현해야 한다. 또 리스트가 빈 상태인 경우와 노드가 하나 남아 있을 때 이 노드를 삭제하는 경우처럼 예외적 상황이 있는지 검토해야 한다.",
    "source": "ds04_2_단일 연결구조 기반 비정렬 리스트 구현",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현",
      "section_number": "2",
      "section_heading": "## 2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0060"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1 노드구조체와멤버변수 \n\n1 Node:  2 item: data type  3 next: address type \n\n## <그림 4.2> 단일 연결구조 노드 구조체 \n\n연결구조는 데이터를 추가할 때마다 데이터와 다음 노드의 위치 정보를 유지하는 노드를 동적 생성한다. 따라서 보통 내부 클래스로 그림 4.2와 같은 노드 구조체를 정의하여 사용한다. 이 교재에서 노드에 유지하는 데이터 멤버 변수를 item, 다음 노드의 위치 정보를 유지하는 멤버 변수를 next로 가정하고 앞으로 의사코드를 서술한다. 멤버 변수는 머리 포인터만 유지할 경우에는 머리 포인터 head와 저장된 요소의 개수를 나타내는 numItems가 필요하고, 꼬리 포인터도 유지할 경우에는 꼬리 포인터 tail까지 필요하다.",
    "source": "ds04_2.1_단일 연결구조 기반 비정렬 리스트 구현-노드구조체와멤버변수",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: 노드구조체와멤버변수",
      "section_number": "2.1",
      "section_heading": "## 2.1 노드구조체와멤버변수",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0061"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.1 소멸자 \n\nC++와같이동적생성한것을자동으로반납해주지않는언어의경우연결구조기반리스트가소멸할때머리\n\n\n1 clear():  2    curr := head  3    while curr != 1 do  4        delNode := curr  5        curr := curr.next  6        free delNode  7        numItems := 0  8        head := 1 \n\n<그림 4.3> 단일 연결구조: 소멸자 \n\n노드부터 꼬리 노드까지 모든 노드가 차지하는 공간을 그림 4.3처럼 반납해 주어야 한다. 배열 기반에서는 동적 생성한 배열만 반납하였던 것과 비교하면 상대적으로 비용이 많이 소요된다는 것을 알 수 있다. 보통 자료구조는 초기화를 해주는 clear 연산을 제공하는데, 연결 구조 기반에서는 clear 연산에서도 모든 노드를 반납해주어야 한다. 따라서 연결 구조 기반에서 소멸자가 필요할 경우에는 소멸자에서 clear 연산을 호출하도록 구현하여 코드 중복을 제거할 수 있다.",
    "source": "ds04_1.1_단일 연결구조 기반 비정렬 리스트 구현-.1 소멸자",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: .1 소멸자",
      "section_number": "1.1",
      "section_heading": "## 2.1.1 소멸자",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0062"
  },
  {
    "type": "텍스트북",
    "text": "2.1.2 상태 조회 메소드 \n\n1 isEmpty():  2    return head==1  3  4 size():  5    return numItems \n\n<그림 4.4> 비정렬 리스트: 상태 조회 메소드 \n\n연결 구조에서 상태 조회 메소드 중 isEmpty 메소드는 배열 기반과 마찬가지로 numItems를 이용할 수 있다. 하지만 연결 구조에서는 numItems 대신에 head 포인터의 널포인터 유무를 이용할 수도 있다. 연결 구조 기반은 메모리가 부족하지 않으면 계속 데이터를 추가할 수 있으므로 isFull 메소드는 필요 없다.",
    "source": "ds04_1.2_단일 연결구조 기반 비정렬 리스트 구현-2.1.2 상태 조회 메소드",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: 2.1.2 상태 조회 메소드",
      "section_number": "1.2",
      "section_heading": "2.1.2 상태 조회 메소드",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0063"
  },
  {
    "type": "텍스트북",
    "text": "2.1.3 색인 기반 접근 메소드 \n\n1 get(index):  2    if index<1 or index>numItems: throw IndexOutOfBoundsException  3    curr := head  4    for i:=1 to index do  5        curr := curr.next  6        return curr.item  7  8 set(index, item):  9    if index<1 or index>numItems: throw IndexOutOfBoundsException  10    curr := head  11    for i:=1 to index do  12        curr := curr.next  13    curr.item := item \n\n<그림 4.5> 비정렬 리스트: get, set 메소드 \n\n연결 구조 기반 리스트는 순차 접근만 가능하므로 색인 기반 접근이 효율적이지 못하다. 그림 4.5처럼 get, set\n\n\n은 모두 순차적으로 index만큼 하나씩 이동하여 색인에 해당하는 노드에 접근한다. 이 부분의 중복 코드는 색인에 해당하는 노드를 반환하는 getNode(index)와 같은 함수를 만들어 모듈화하면 제거할 수 있다. \n\n1  insert(index, item):  2    if index<1 or index>numItems then throw IndexOutOfBoundsException  3    newNode := allocate Node(item, 1)  4    if index==1 then pushFront(item)  5    else:  6    curr := head  7    for i:=1 to index-1 do  8    curr := curr.next  9    newNode.next := curr.next  10    curr.next := newNode  11    ++numItems \n\n## <그림 4.6> 비정렬 리스트: insert 메소드 \n\n색인 기반 삽입은 색인에 해당하는 노드에 접근하는 것이 아니라 색인에 해당하는 노드의 선행 노드에 접근하여 그다음에 새 노드를 추가해야 한다. 이때 맨 처음에 삽입하는 경우에는 head가 변경되어야 하므로 이 부분은 별도 처리하거나 더미 노드를 사용할 수 있다. 하지만 getNode(index)를 활용할 수 없게 되므로 색인 기반 접근은 더미 노드를 사용하지 않고 처리하는 것이 더 효과적이다. \n\n색인 기반 삽입의 의사코드는 그림 4.6과 같다. 기본적으로 새 노드를 생성한 다음에 삽입할 위치의 이전 노드를 얻어 새 노드의 다음 노드를 이전 노드의 다음 노드로 설정하고, 이전 노드의 다음 노드를 새 노드로 바꾸면 된다.",
    "source": "ds04_1.3_단일 연결구조 기반 비정렬 리스트 구현-2.1.3 색인 기반 접근 메소드",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: 2.1.3 색인 기반 접근 메소드",
      "section_number": "1.3",
      "section_heading": "2.1.3 색인 기반 접근 메소드",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0064"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.4  찾기 연산 \n\n1  find(item):  2    curr := head  3    while curr do  4    if curr.item == item then return true  5    curr := curr.next  6    return false \n\n## <그림 4.7> 비정렬 리스트: 선형 검색 메소드 \n\n연결 구조 기반 리스트에서 선형 검색의 의사코드는 그림 4.7과 같다. 배열 기반에서는 있다 없다를 반환해주는 찾기 연산 대신에 있을 경우 색인을 반환해주는 연산을 정의하고 이를 실제 찾기 연산과 삭제 연산에서 활용하는 형태로 최적화를 할 수 있다. 하지만 단일 연결구조 기반에서 삭제는 삭제할 노드의 이전 노드까지 필요하므로 값이 포함된 노드를 반환해주는 연산을 만들어 배열 기반처럼 최적화할 수 없다.",
    "source": "ds04_1.4_단일 연결구조 기반 비정렬 리스트 구현-.4  찾기 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: .4  찾기 연산",
      "section_number": "1.4",
      "section_heading": "## 2.1.4  찾기 연산",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0065"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.5  맨 앞과 맨 뒤 삽입 추출 연산 \n\n연결구조 기반 리스트 자료구조는 맨 앞 삽입과 추출은 효과적이며 꼬리 포인터를 유지하면 맨 뒤 삽입도 효과적으로 할 수 있지만 중간에 삽입과 추출 또는 맨 뒤 추출은 해당 위치까지 순차적으로 이동해야 하기 때문에 효과적으로 처리할 수 없다. 꼬리 포인터를 유지하지 않을 경우에는 꼬리 포인터를 반환하여 주는 연산을 만들어 중복 코드를 제거하는 것이 효과적이다. \n\n맨 앞에 삽입과 추출하는 pushfront와 popfront 연산의 의사코드는 각각 그림 4.8과 그림 4.9와 같다. 앞서 언급한 바와 같이 연결 구조에서는 처리하는 순서가 매우 중요하다. 또 추출 연산의 경우에는 프로그래밍 언어에\n\n\n1 pushfront(item):  2 newNode := allocate Node(item, head)  3 head := newNode  4 ++numItems \n\n<그림 4.8> 비정렬 리스트: pushfront 메소드 \n\n1 popfront():  2 if isEmpty() then throw InvalidStateException  3 ret := head.item  4 delNode := head  5 head := head.next  6 free delNode  7 - numItems  8 return ret \n\n<그림 4.9> 비정렬 리스트: popfront 메소드 \n\n따라 기존에 동적 생성한 노드를 반납해 주어야 한다. 노드가 하나만 있는 경우에는 head를 넘포인터로 만들어 주어야 하는데, 노드가 하나 있을 때 head를 head.next로 설정하면 자동으로 넘포인터로 갱신된다. \n\n1 pushback(item):  2 newNode := allocate Node(item, ⊥)  3 if isEmpty() then head := newNode  4 else  5 tail := head  6 while tail.next := ⊥ do  7 tail := tail.next  8 tail.next := newNode  9 ++numItems \n\n<그림 4.10> 비정렬 리스트: pushback 메소드 \n\n맨 뒤에 삽입과 추출하는 pushback과 popback 연산의 의사코드는 각각 그림 4.10과 그림 4.11과 같다. 꼬 리 포인터를 유지하고 있으면 pushback은 바로 처리할 수 있지만 꼬리 포인터를 유지하고 있지 않으면 꼬리 포인터까지 이동해야 한다. \n\n노드의 삭제는 이전 노드의 연결 정보를 수정해야 하므로 그림 4.11처럼 두 개의 포인터를 이용할 수 있다. 두 개의 포인터를 이용할 경우에는 더미 노드를 사용하면 코드를 좀더 간결하게 처리할 수 있다. 이때 더미 노드는 동적 생성할 필요는 없다. C++처럼 항상 동적 생성하지 않는 언어이면 자동 생성하는 것이 함수가 끝나기 전에 반납하지 않아도 되기 때문에 편리하다. 더미 노드를 사용할 경우에는 항상 최종적으로 head을 dummy.next로 갱신해 주어야 한다. 이것을 통해 head가 혹시 갱신되어야 하더라도 올바르게 갱신해 준다. \n\n더미 노드를 사용하지 않고 다음을 두 번째 라인으로 추가하면 \n\nif numItems == 1 then return popfront() \n\nprev를 head로 설정하고, curr는 head.next로 설정하여 꼬리 노드를 탐색을 진행할 수 있다. 이 경우 나머지 부분은 그림 4.11과 같지만 11번째 라인은 필요가 없다. \n\n두 개의 포인터를 이용하지 않고 하나만 사용할 경우에 코드는 그림 4.12과 같이 수정되어야 한다. peekfront는 head 포인터를 이용하여 간단하게 구현할 수 있지만 peekback의 경우 꼬리 포인터를 유지하지 않으면 꼬리까지 이동해야 하므로 효과적으로 제공할 수 없다.\n\n\n1 popback():  2 if isEmpty() then throw InvalidStateException  3 dummy := Node(_, head)  4 prev := address of dummy  5 curr := head  6 while curr.next do  7 prev := curr  8 curr := curr.next  9 ret := curr.item  10 prev.next := _  11 head := dummy.next  12 free curr  13 - - numItems  14 return ret \n\n<그림 4.11> 비정렬 리스트: 두 개의 포인터를 이용한 popback 메소드 \n\n1 popback():  2 if isEmpty() then throw InvalidStateException  3 dummy := Node(_, head)  4 prev := address of dummy  5 while prev.next.next do  6 prev :=prev.next  7 ret := prev.next.item  8 delNode := prev.next  9 prev.next := _  10 head := dummy.next  11 free delNode  12 - - numItems  13 return ret \n\n<그림 4.12> 비정렬 리스트: 단일 포인터를 이용한 popback 메소드",
    "source": "ds04_1.5_단일 연결구조 기반 비정렬 리스트 구현-.5  맨 앞과 맨 뒤 삽입 추출 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: .5  맨 앞과 맨 뒤 삽입 추출 연산",
      "section_number": "1.5",
      "section_heading": "## 2.1.5  맨 앞과 맨 뒤 삽입 추출 연산",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0066"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.6 삭제 연산 \n\n삭제는 삭제할 노드를 찾은 후 삭제할 노드의 이전 노드의 연결 정보를 삭제할 후속 노드로 바꾸어 주어야 한다. 삭제할 이전 노드가 필요하기 때문에 두 개의 포인터와 더미 노드를 이용하는 것이 프로그래밍할 때 편하다. 이와 같은 형태로 구현한 removeFirst 연산의 의사코드는 그림 4.13과 같다. \n\n중복된 모든 요소를 삭제하는 연산은 요소를 하나만 삭제하는 연산을 반복하는 형태로 구현하면 된다. 이때 그 림 4.14처럼 노드를 삭제한 후에는 prev의 위치는 바뀌지 않고 curr는 삭제된 노드의 후속 노드를 가리킨 상태에서 반복이 진행되도록 해야 한다.",
    "source": "ds04_1.6_단일 연결구조 기반 비정렬 리스트 구현-.6 삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: .6 삭제 연산",
      "section_number": "1.6",
      "section_heading": "## 2.1.6 삭제 연산",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0067"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.7 꼬리 포인터의 추가 \n\n꼬리 포인터를 추가하면 삽입 연산의 경우 빈 상태일 때는 머리 포인터 뿐만 아니라 꼬리 포인터도 새 노드를 가리 기도록 해야 한다. 반면에 pushback과 peekback은 꼬리 포인터를 이용하여 간단하게 구현할 수 있다. 하지만 popback은 꼬리 노드의 이전 노드 연결 정보를 널포인터로 갱신해야 하기 때문에 선형 비용이 필요하고, 더미 노드와 두 개의 포인터를 이용해 구현하는 것이 편리하다. 삭제 연산의 경우 꼬리 노드가 삭제되거나 유일 노드 를 삭제해야 할 경우 꼬리 포인터의 갱신이 필요하다. 보통 삭제할 노드가 curr이면 다음과 같이 꼬리 포인터를 갱신해야 한다.\n\n\n1 removeFirst(item):  2 dummy := Node(_, head)  3 prev := address of dummy  4 curr := - head  5 while curr do  6 if curr.item == item then break  7 prev := curr  8 curr := curr.next  9 if curr then  10 prev.next := curr.next  11 free curr  12 --nextItem  13 head := dummy.next \n\n<그림 4.13> 비정렬 리스트: removeFirst 매소드 \n\n1 removeAll(item):  2 dummy := Node(_, head)  3 prev := address of dummy  4 curr := - head  5 while curr do  6 if curr.item == item then  7 next := curr.next  8 prev.next := next  9 free curr  10 --nextItem  11 curr := next  12 else  13 prev := curr  14 curr := curr.next  15 head := dummy.next \n\n<그림 4.14> 비정렬 리스트: removeAll 매소드 \n\n1 if curr==tail then tail := prev  2 if head==⊥ then tail := ⊥",
    "source": "ds04_1.7_단일 연결구조 기반 비정렬 리스트 구현-.7 꼬리 포인터의 추가",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 비정렬 리스트 구현: .7 꼬리 포인터의 추가",
      "section_number": "1.7",
      "section_heading": "## 2.1.7 꼬리 포인터의 추가",
      "parent_section": "2. 단일 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0068"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 단일 연결구조 기반 정렬 리스트 구현",
    "source": "ds04_3_단일 연결구조 기반 정렬 리스트 구현",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 정렬 리스트 구현",
      "section_number": "3",
      "section_heading": "## 3. 단일 연결구조 기반 정렬 리스트 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0069"
  },
  {
    "type": "텍스트북",
    "text": "### 3.1 차이점 \n\n연결 구조 기반 정렬 리스트는 비정렬 리스트와 다음과 같은 차이점이 있다. \n\n- 비정렬 리스트는 기본적으로 중복을 허용하지만 정렬 리스트는 중복 허용할 수 있고, 허용하지 않을 수도 있다. \n\n- 색인 기반 접근 메소드 중 set, insert를 그대로 사용하면 정렬된 상태가 깨질 수 있다. \n\n- 연결 구조 기반의 경우 비정렬이나 정렬이나 find는 선형 검색을 할 수밖에 없다. 하지만 정렬은 검색할 때 중간에 중단할 수 있다. \n\n- pushback, pushfront도 그대로 사용하면 정렬된 상태가 깨질 수 있다.\n\n\n• 중복을 허용하는 정렬 리스트의 경우 같은 요소는 인접해 있기 때문에 중복된 요소를 모두 제거하는 연산은 이 점을 고려하여 구현해야 한다. \n\n3장에서 살펴본 것과 비교하면 연결 구조는 정렬에서도 선형 검색을 해야 한다는 것을 제외하고 차이점이 같다. \n\n정렬 리스트에서 꼬리 포인터를 유지하면 리스트의 범위를 쉽게 알 수 있고, 최솟값과 최댓값도 쉽게 알 수 있으며, 삽입 연산을 처리할 때 꼬리 포인터를 이용한 최적화도 가능하다.",
    "source": "ds04_3.1_단일 연결구조 기반 정렬 리스트 구현-### 3.1 차이점",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 정렬 리스트 구현: ### 3.1 차이점",
      "section_number": "3.1",
      "section_heading": "### 3.1 차이점",
      "parent_section": "3. 단일 연결구조 기반 정렬 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0070"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2  찾기 연산 \n\n1 find(item):  2    curr := head  3    while curr do  4    if curr.item == item then return true  5    else if curr.item>item then return false  6    curr := curr.next  7    return false \n\n## <그림 4.15> 정렬 리스트: 선형 검색 메소드 \n\n연결구조 기반 정렬 리스트의 찾기 연산은 그림 4.15와 같다. 그림 4.15에 제시된 의사코드는 다섯 번째 줄을 제 외하고는 비정렬 리스트의 찾기 연산과 차이가 없다. 연결구조는 정렬되어 있어도 이진 검색을 할 수 없지만 중간에 중단할 수 있기 때문에 다섯 번째 줄이 추가되어 있다. 이와 같은 특징은 찾기 연산 뿐만 아니라 삭제 연산에서도 활용해야 한다.",
    "source": "ds04_3.2_단일 연결구조 기반 정렬 리스트 구현-찾기 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 정렬 리스트 구현: 찾기 연산",
      "section_number": "3.2",
      "section_heading": "## 3.2  찾기 연산",
      "parent_section": "3. 단일 연결구조 기반 정렬 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0071"
  },
  {
    "type": "텍스트북",
    "text": "## 3.3  삽입 연산 \n\n1 add(item):  2    newNode := allocate Node(item, ⊥)  3    if isEmpty() or head.item >= item then  4    newNode.next := head  5    head := newNode  6    else  7    prev := head  8    curr := head.next  9    while curr != ⊥ and curr.item < item then  10    prev := curr  11    curr := curr.next  12    prev.next := newNode  13    newNode.next := curr  14    ++numItems \n\n## <그림 4.16> 정렬 리스트: 머리 포인터만 유지하는 삽입 메소드 \n\n머리 포인터만 유지할 경우에는 머리 노드를 이용한 최적화만 가능하고, 꼬리 포인터를 유지하면 꼬리 포인터를 이용한 최적화까지 가능하다. 우선 빈 상태인지 살펴보고, 머리 노드의 요소 값과 같거나 작으면 맨 앞에 삽입하면 된다. 꼬리 포인터가 있는 경우에는 꼬리 노드의 요소 값과 같거나 클 경우에는 맨 뒤에 삽입하면 된다. 머리 노드를 이용하여 최적화하고 있기 때문에 두 개의 포인터를 이용할 경우에도 더미 노드를 사용할 필요가 없고 두 번째 노드부터 삽입 위치를 찾기 위한 비교를 진행하면 된다.\n\n\n1 add(item):  2 newNode := allocate Node(item, \\_)  3 if isEmpty() or head.item >= item then  4 newNode.next := head  5 head := newNode  6 else if tail.item<=item then  7 tail.next := newNode  8 tail := newNode  9 else  10 prev := head  11 curr := head.next  12 while curr != \\_ and curr.item < item then  13 prev := curr  14 curr := curr.next  15 prev.next := newNode  16 newNode.next := curr  17 ++numItems \n\n<그림 4.17> 정렬 리스트: 머리와 꼬리 포인터를 유지하는 삽입 메소드",
    "source": "ds04_3.3_단일 연결구조 기반 정렬 리스트 구현-삽입 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 정렬 리스트 구현: 삽입 연산",
      "section_number": "3.3",
      "section_heading": "## 3.3  삽입 연산",
      "parent_section": "3. 단일 연결구조 기반 정렬 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0072"
  },
  {
    "type": "텍스트북",
    "text": "## 3.4 삭제 연산 \n\n1 removeAll(item):  2 if isEmpty() then return  3 dummy := Node(\\(\\_\\), head)  4 prev := address of dummy  5 curr := head  6 while curr!=\\(\\_\\) and curr.item<=item do  7 if curr.item==item then  8 while curr!=\\(\\_\\) and curr.item==item do  9 next := curr.next  10 free next  11 curr := next  12 --numItems  13 prev.next := curr  14 head := dummy.next  15 break  16 prev := curr  17 curr := curr.next \n\n<그림 4.18> 정렬 리스트: removeAll 메소드 \n\n삭제 연산은 정렬되어 있다는 것을 활용한다는 것을 제외하고는 비정렬과 비교하여 큰 차이는 없다. 다만, removeAll은 정렬 리스트이기 때문에 제거할 중복된 요소가 모두 인접해 있다는 것을 이용하여 삭제를 진행해야 한다. 연결 구조 기반 정렬 리스트에서 removeAll은 그림 4.18과 같다.",
    "source": "ds04_3.4_단일 연결구조 기반 정렬 리스트 구현-삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "단일 연결구조 기반 정렬 리스트 구현: 삭제 연산",
      "section_number": "3.4",
      "section_heading": "## 3.4 삭제 연산",
      "parent_section": "3. 단일 연결구조 기반 정렬 리스트 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0073"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 연결 구조 기반 리스트 응용 \n\n연결 구조 리스트를 뒤집는 것을 생각하여 보자. 첫 요소부터 새 리스트에 pushfront를 하면 리스트를 쉽게 뒤집을 수 있다. 하지만 이 경우에는 리스트 크기만큼 노드를 새롭게 만들어야 한다. 따라서 더 효과적인 방법은 기존 리스트의 연결을 수정하여 리스트를 뒤집는 것이다. 방법은 간단하다. rev라는 포인터를 준비하여 이것이 뒤집은 새 리스트의 머리 포인터가 되도록 기존 리스트의 노드를 차례로 방문하면서 새 노드를 만들지 않고 기존\n\n\n1 reverse(): \n\n2 if numItems<=1 then return \n\n3 rev := ⊥ \n\n4 curr := head \n\n5 while curr!= ⊥ do \n\n6 next := curr.next \n\n7 curr.next := rev \n\n8 rev := curr \n\n9 curr.next := next \n\n10 head := rev \n\n<그림 4.19> 연결 구조 리스트 뒤집기 \n\n<표 4.2> 배열과 단일 연결구조의 각종 연산의 시간 복잡도 비교 \n\n<table><tr><td rowspan=\"3\"></td><td colspan=\"2\">배열 기반 리스트</td><td colspan=\"4\">연결 구조 기반 리스트</td></tr><tr><td rowspan=\"2\">비정렬</td><td rowspan=\"2\">정렬</td><td colspan=\"2\">비정렬</td><td colspan=\"2\">정렬</td></tr><tr><td>모리 포인터</td><td>모리 포인터</td><td>모리 포인터</td></tr><tr><td>find</td><td>O(n)</td><td>O(log n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>pushfront</td><td>O(1)*</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td>-</td></tr><tr><td>popfront</td><td>O(1)*</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>pushback</td><td>O(1)</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td>-</td></tr><tr><td>popback</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>add</td><td>-</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(n)</td></tr><tr><td>removeFirst</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)<br/>O(n)</td><td>O(n)</td></tr></table>\n\n*순서를 유지할 필요가 없거나 순환 배열 방식인 경우 \n\n노드를 그림 4.19와 같이 pushfront하면 된다. \n\n연결 구조 리스트에서 중간 노드 찾기는 현재 저장되어 있는 요소의 개수 numItems를 이용하면 쉽게 구현할 수 있다. 그런데 numItems를 이용하지 않고 구현하는 방법은 없을까? 두 개의 포인터를 이용하면 가능하다. 하나는 한 건의 이동하고, 다른 하나는 두 건의 이동하도록 한 후에 두 건의 이동한 포인터가 리스트를 벗어난 순간 한 건의 이동한 포인터가 가리키는 노드가 중간 노드가 된다. 이때 더미 노드를 사용하고 둘 다 더미 노드를 초깃값을 사용하면 효과적으로 구현할 수 있다. 이것을 응용하면 뒤에서 k번째 노드를 얻는 메소드도 쉽게 구현할 수 있다. 먼저 첫 포인터를 k개 이동한 후에 그다음부터는 두 노드를 하나씩 이동하게 되면 첫 포인터가 널 포인터가 되었을 때 두 번째 포인터가 가리키는 노드가 뒤에서 k번째 노드가 된다.",
    "source": "ds04_4_연결 구조 기반 리스트 응용",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "연결 구조 기반 리스트 응용",
      "section_number": "4",
      "section_heading": "## 4. 연결 구조 기반 리스트 응용",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0074"
  },
  {
    "type": "텍스트북",
    "text": "## 5. 배열과 단일 연결구조의 비교 \n\n배열 기반 리스트와 단일 연결구조 기반 리스트의 각종 연산의 시간 복잡도를 비교하면 표 4.2와 같다. 배열 기반의 경우 동적 배열 기법에 사용에 따른 추가 비용이 발생한다. 따라서 배열 기반의 경우에는 초기 용량을 적절하게 확보한 다음 사용해야 한다. 물론 연결 구조는 데이터를 추가할 때마다 동적 할당이 필요하며, 공간 측면에서도 연결 정보를 유지하기 위한 추가 공간의 사용이 불가피하다. 또 소멸할 때도 모든 노드를 반납해야 하기 때문에 O(n)의 비용이 소요된다. 캐싱 측면에서는 연속 공간을 확보하는 배열 기반 리스트가 더 효과적이다.\n\n![](images/11_0.jpg)\n\n \n\n<center><그림 4.20> skip list</center>",
    "source": "ds04_5_배열과 단일 연결구조의 비교",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "배열과 단일 연결구조의 비교",
      "section_number": "5",
      "section_heading": "## 5. 배열과 단일 연결구조의 비교",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds04/images/11_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0075"
  },
  {
    "type": "텍스트북",
    "text": "## 6. 스킵 리스트 \n\n연결구조는 데이터를 정렬하여 유지하더라도 이진 검색을 할 수 없는 단점이 있다. 이를 극복하기 위해 고안된 연결 구조가 스킵 리스트(skip list)이다. 스킵 리스트는 그림 4.20과 같이 각 노드가 후속 노드에 대한 하나의 연결 정보만 가지고 있는 것이 아니라 여러 개를 가질 수 있다. 최대 가질 수 있는 연결 정보는 시스템에서 고정한 상태에서 각 노드는 랜덤한 수의 연결 정보를 가지도록 구현한다. 이것은 얼마나 많은 노드가 어떤 순서로 삽입될지 모르기 때문이다. 이때 머리 노드는 항상 최대 수의 연결을 가지도록 구성한다. 검색은 머리 노드에서 시작하여 가장 최상위 연결을 이용하여 검색하고자 하는 값보다 클 때 또는 리스트 끝에 도달할 때까지 이동한다. 이 과정에서 일치한 것을 찾지 못하였으면 이전 노드의 다음 연결을 이용하여 이전 과정을 반복한다. 이렇게 하면 평균적으로 \\(O(\\log n)\\) 에 검색할 수 있다.",
    "source": "ds04_6_스킵 리스트",
    "meta_data": {
      "tables": [],
      "book_title": "제4장 연결구조 기반 리스트: 단일 연결구조",
      "chapter": "",
      "section": "스킵 리스트",
      "section_number": "6",
      "section_heading": "## 6. 스킵 리스트",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0076"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 이중 연결구조 \n\n![](images/0_0.jpg)\n\n<위치 5.1> 이중 연결구조 \n\n이중 연결구조에서 각 노드는 그림 5.1처럼 다음 노드에 대한 연결 뿐만 아니라 이전 노드에 대한 연결을 유지 한다. 이와 같이 유지하면 현재 노드에서 앞과 뒤로 모두 검색할 수 있다. 따라서 단일 연결구조와 달리 한 개의 포인터만 이용하여 모든 연산을 구현할 수 있으며, 꼬리 포인터를 유지하면 뒤에서 추출도 O(1)에 제공할 수 있다. 더욱이 특정 노드의 위치를 알면 그 노드를 바로 삭제할 수 있고, 그 앞과 뒤에 새 노드를 쉽게 추가할 수 있다. 하지만 노드마다 유지하는 정보가 많다는 단점이 있다. \n\n이중 연결구조는 꼬리 포인터를 유지하면 앞에서, 뒤에서 삽입과 추출을 모두 O(1)에 제공할 수 있으므로 이것이 필요할 때 활용하는 것이 가장 효과적이고, 단일 연결구조는 꼬리 포인터를 유지하지 않고, 앞에서 삽입과 추출이 필요할 때 사용하는 것이 효과적이다.",
    "source": "ds05_1_이중 연결구조",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조",
      "section_number": "1",
      "section_heading": "## 1. 이중 연결구조",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds05/images/0_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0077"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 이중 연결구조 기반 비정렬 리스트 구현",
    "source": "ds05_2_이중 연결구조 기반 비정렬 리스트 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 비정렬 리스트 구현",
      "section_number": "2",
      "section_heading": "## 2. 이중 연결구조 기반 비정렬 리스트 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0078"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1 노드 구조체와 멤버 변수 \n\n1 Node:  2 item: data type  3 prev: address type  4 next: address type \n\n<그림 5.2> 이중 연결구조 노드 구조체 \n\n이중 연결구조에서 노드 구조체는 그림 5.2과 같다. 단일 연결구조와 비교하여 이전 노드 연결이 추가되었으며, 이 때문에 노드를 생성할 때 값, 이전 노드 연결 정보, 다음 노드 연결 정보 3가지를 제공하는 생성자의 추가가 필요하다. 필요한 멤버 변수는 단일 연결구조와 비교하여 차이가 없다.",
    "source": "ds05_2.1_이중 연결구조 기반 비정렬 리스트 구현-노드 구조체와 멤버 변수",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 비정렬 리스트 구현: 노드 구조체와 멤버 변수",
      "section_number": "2.1",
      "section_heading": "## 2.1 노드 구조체와 멤버 변수",
      "parent_section": "2. 이중 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0079"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.1 단일 연결구조 기반 구현과 차이점 \n\n이중 연결구조에서 각 노드는 다음 노드와 이전 노드에 대한 연결 정보를 유지하기 때문에 단일 연결구조에 비해  갱신해야 하는 연결이 많다. 갱신해야 하는 연결이 많다 보니 넘포인터에 대한 검사도 더 많이 필요하게 된다. 특정  노드에 대한 포인터만 있으면 해당 노드를 삭제할 수 있고, 그 노드 앞과 뒤에 새 노드를 추가할 수 있으므로 단일  연결구조와 달리 getNode(index)를 통해 색인 기반 연산들을 모두 구현할 수 있다. \n\n단일 연결구조에서는 두 개의 포인터를 이용하여 삭제가 필요한 연산들을 구현하였지만 이중 연결구조에서는 하나의 포인터만 사용하여 간결하게 구현할 수 있다. 반면에 더미 노드의 사용을 통해 필요한 널포인터 검사는 여전히 줄일 수 있다. 하지만 실제 더미 노드를 사용하였을 때와 사용하지 않을 때를 비교하면 코드 개선 효과가 별로 없어 이중 연결구조에서는 더미 노드를 보통 사용하지 않는다. \n\n노드의 수정이 필요 없고, 뒤로 이동할 필요가 없는 연산은 단일 연결구조 구현과 차이가 없다. 따라서 이 장에서 차이가 있는 연산만 제시하고 설명한다.",
    "source": "ds05_1.1_이중 연결구조 기반 비정렬 리스트 구현-.1 단일 연결구조 기반 구현과 차이점",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 비정렬 리스트 구현: .1 단일 연결구조 기반 구현과 차이점",
      "section_number": "1.1",
      "section_heading": "## 2.1.1 단일 연결구조 기반 구현과 차이점",
      "parent_section": "2. 이중 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0080"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.2  맨 앞과 맨 뒤 삽입 추출 연산 \n\n1 pushfront(item):  2 newNode := dynamically allocate Node(item, 1, head)  3 if head != 1 then head.prev := newNode  4 head := newNode  5 ++numItems \n\n<그림 5.3> 비정렬 리스트: pushfront 메소드 \n\n1 popfront():  2 if isEmpty() then throw InvalidStateException  3 ret := head.item  4 popNode := head  5 head := head.next  6 if head != 1 then head.prev := 1  7 free popNode  8 - - numItems  9 return ret \n\n<그림 5.4> 비정렬 리스트: popfront 메소드 \n\n맨 앞에 삽입과 추출하는 pushfront와 popfront 연산의 의사코드는 각각 그림 5.3와 그림 5.4과 같다. 단일 연결구조와 비교하면 각각 한 줄이 추가되어 있다. pushfront의 경우 기존 머리 노드의 이전 노드를 새 노드로 연결해 주어야 하고, popfront의 경우 두 번째 노드가 머리 노드가 되면서 이 노드의 이전 노드 연결을 넘포인터로 바꾸어 주어야 한다. 두 경우 모두 머리 포인터가 넘포인터인지 여부를 검사한 후에 갱신해야 한다. \n\n맨 뒤에 삽입과 추출하는 pushback과 popback 연산의 의사코드는 각각 그림 5.5와 그림 5.6와 같다. pushback 은 새 노드의 이전 노드 정보를 기존 꼬리 노드로 바꾸어주는 부분이 추가된 것을 제외하고는 단일 연결구조와 비교하여 차이가 없다. 단일 연결구조에서 popback은 보통 더미 노드와 두 개의 포인터를 이용하여 구현한다. 하지만 이중 연결구조에서 노드는 이전 노드에 대한 연결을 유지하기 때문에 하나의 포인터만 이용하여 충분히 구현할 수 있다. 하나의 포인터만 이용할 경우에는 꼬리 노드의 이전 노드 연결 정보가 넘포인터인지 검사한 후에 그것에 맞는 조치를 해야 한다. 이 부분은 더미 노드를 사용하면 제거할 수 있지만 더미 노드의 생성과 머리 노드의 조정이 추가로 필요하기 때문에 코드의 간결성이 개선된다고 보기 어렵다.\n\n\n1 pushback(item):  2 newNode := allocate Node(item, \\(\\perp\\))  3 if isEmpty() then head := newNode  4 else  5 tail := getTail()  6 tail.next := newNode  7 newNode.prev := tail  8 ++numItems \n\n<그림 5.5> 비정렬 리스트: pushback 메소드 \n\n1 popback():  2 if isEmpty() then throw InvalidStateException  3 tail := getTail()  4 ret := tail.item  5 if tail.prev != \\(\\perp\\) then tail.prev.next := \\(\\perp\\)  6 else head := \\(\\perp\\)  7 free tail  8 --numItems  9 return ret \n\n<그림 5.6> 비정렬 리스트: popback 메소드",
    "source": "ds05_1.2_이중 연결구조 기반 비정렬 리스트 구현-.2  맨 앞과 맨 뒤 삽입 추출 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 비정렬 리스트 구현: .2  맨 앞과 맨 뒤 삽입 추출 연산",
      "section_number": "1.2",
      "section_heading": "## 2.1.2  맨 앞과 맨 뒤 삽입 추출 연산",
      "parent_section": "2. 이중 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0081"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.3  삭제 연산 \n\n1 removeFirst(item):  2 curr := head  3 while curr != \\(\\perp\\) do  4 if curr.item == item then  5 if curr.prev != \\(\\perp\\) then curr.prev.next = curr.next;  6 if curr.next != \\(\\perp\\) then curr.next.prev := curr.prev;  7 if curr == head then head := curr.next  8 free curr  9 --nextItem  10 break  11 curr := curr.next \n\n<그림 5.7> 비정렬 리스트: removeFirst 메소드 \n\nremoveFirst 연산의 의사코드는 그림 5.7과 같다. 앞서 살펴본 popback처럼 단일 연결구조와 달리 더미 노 드와 두 개의 포인터를 이용하지 않고 하나의 포인터만 사용하여 구현하고 있다. 이중 연결구조에서도 더미 노드를 활용할 수 있지만 그것을 통해 코드의 간결성이 별로 개선되지 않으므로 사용하지 않는 것이 더 효과적이다. 중복된 모든 요소를 삭제하는 연산은 요소를 하나만 삭제하는 연산을 반복하는 형태로 구현하면 된다.",
    "source": "ds05_1.3_이중 연결구조 기반 비정렬 리스트 구현-.3  삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 비정렬 리스트 구현: .3  삭제 연산",
      "section_number": "1.3",
      "section_heading": "## 2.1.3  삭제 연산",
      "parent_section": "2. 이중 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0082"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1.4  프리 포인터의 추가 \n\n이중 연결구조는 꼬리 포인터의 추가로 얻어지는 이득이 많다. 따라서 이중 연결구조는 꼬리 포인터를 추가하지 않고 구현하는 것은 실제 의미가 없다. 이중 연결구조에서 꼬리 포인터를 추가하면 맨 뒤에 삽입 뿐만 아니라 추출도 O(1)에 제공할 수 있다. \n\n꼬리 포인터를 추가하게 되면 빈 상태에서 삽입은 꼬리 포인터도 갱신해 주어야 하며, 유일 노드를 제거해야 할 때도 꼬리 포인터를 갱신해 주어야 한다. pushback과 popback은 꼬리 포인터를 이용하여 효과적으로 구현할\n\n\n1 removeAll(item):  2    curr :== head  3    while curr do  4      next := curr.next  5      if curr.item == item then  6          if curr.prev != = then curr.prev.next = curr.next;  7          if curr.next != = then curr.next.prev := curr.prev;  8          if curr == head then head := curr.next  9          free curr  10          - - nextItem  11      curr := next \n\n<그림 5.8> 비정렬 리스트: removeAll 메소드 \n\n수 있으며, 꼬리 포인터의 갱신이 필요하다. 삭제 연산의 경우에는 꼬리 노드가 삭제될 경우 갱신이 필요하며, 보통 curr가 삭제할 노드일 때 다음과 같이 갱신되어야 한다. \n\n1 if curr==tail then  2    tail := if curr==head then  else curr.prev \n\n이와 같이 갱신한 이후 tail의 다음 노드 연결 정보를 널포인터로 갱신해야 하는데, 이 갱신은 노드의 삭제 과정에서 이미 했기 때문에 추가로 해줄 필요는 없다.",
    "source": "ds05_1.4_이중 연결구조 기반 비정렬 리스트 구현-.4  프리 포인터의 추가",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 비정렬 리스트 구현: .4  프리 포인터의 추가",
      "section_number": "1.4",
      "section_heading": "## 2.1.4  프리 포인터의 추가",
      "parent_section": "2. 이중 연결구조 기반 비정렬 리스트 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0083"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 이중 연결구조 기반 정렬 리스트 구현 \n\n이중 연결구조 기반 정렬 리스트를 구현할 때 특별하게 고려할 것은 없다. 단일 연결구조 기반 정렬 리스트와 마찬 가지로 add 연산은 빈 상태, 머리 노드보다 같거나 작은 경우, 꼬리 노드보다 같거나 큰 경우, 나머지 경우로 나누어 처리하면 된다. 찾기와 삭제는 정렬되어 있어도 이진 검색을 할 수 없다. 그러나 중간에 찾고자 하는 것보다 큰 값을 발견하면 검색을 중간에 중단할 수 있다.",
    "source": "ds05_3_이중 연결구조 기반 정렬 리스트 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이중 연결구조 기반 정렬 리스트 구현",
      "section_number": "3",
      "section_heading": "## 3. 이중 연결구조 기반 정렬 리스트 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0084"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 연결구조 기반 리스트 구현의 변형",
    "source": "ds05_4_연결구조 기반 리스트 구현의 변형",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "연결구조 기반 리스트 구현의 변형",
      "section_number": "4",
      "section_heading": "## 4. 연결구조 기반 리스트 구현의 변형",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0085"
  },
  {
    "type": "텍스트북",
    "text": "## 4.1 순환 연결구조 \n\n![](images/3_0.jpg)\n\n<center><그림 5.9> 순환 연결구조</center> \n\n단일 또는 이중 연결구조는 머리 포인터 뿐만 아니라 꼬리 포인터까지 유지할 수 있으며, 이중 연결구조는 꼬리 포인터를 유지하여 얻을 수 있는 이점이 많다. 하지만 꼬리 포인터를 추가하면 멤버 변수의 수가 하나 증가한다. 이것이 부담되는 것은 아니다. 하지만 머리 포인터와 꼬리 포인터를 모두 유지하지 않고 하나의 포인터만 유지하여 같은 효과를 얻을 수 있다. 방법은 그림 5.9처럼 꼬리 포인터만 유지하고 꼬리 노드의 다음 연결 정보로 널 포인터를 유지하는 것이 아니라 머리 노드를 유지하도록 하면 된다. 이 경우 꼬리 포인터를 통해 머리 노드와 꼬리 노드를 모두 상수 시간에 접근할 수 있다. 이와 같은 형태의 연결구조를 순환 연결구조(circular linked list)라 한다.\n\n\n1 pushfront(item):  2 newNode := dynamically allocate Node(item)  3 if isEmpty() then  4 newNode.next := newNode  5 tail := newNode  6 else  7 newNode.next := tail.next  8 tail.next := newNode  9 ++numItems \n\n## <그림 5.10> 순환 연결구조 리스트: pushfront 메소드 \n\n하지만 이를 통해 얻어지는 이점은 유지하는 포인터의 개수를 하나 줄이는 것밖에 없고 구현만 복잡해지기 때 문에 의미가 있는 구현 방법은 아니다. 예를 들어 순환 단일 연결구조에서 pushfront 의사코드는 그림 5.10과 같다. 순환 연결구조의 경우 리스트가 빈 상태일 때 처음으로 노드를 추가하더라도 이 노드 자체가 순환되어야 한다. 일반 연결구조에서는 머리 노드부터 검색을 시작하여 넘포인터를 만나면 검색을 종료할 수 있지만 순환 연결구조 에서는 순환되므로 이것이 가능하지 않고 노드의 개수를 반복의 종료 조건으로 활용해야 한다. 반복자 구현에서도 널포인터를 반복의 종료 조건으로 사용할 수 없다. 또 더미 노드의 사용도 불편하다.",
    "source": "ds05_4.1_연결구조 기반 리스트 구현의 변형-순환 연결구조",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "연결구조 기반 리스트 구현의 변형: 순환 연결구조",
      "section_number": "4.1",
      "section_heading": "## 4.1 순환 연결구조",
      "parent_section": "4. 연결구조 기반 리스트 구현의 변형",
      "parent_section_number": "4",
      "images": [
        "ds05/images/3_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0086"
  },
  {
    "type": "텍스트북",
    "text": "## 4.2 배열을 이용한 연결구조 \n\n연결구조는 매번 데이터를 삽입할 때마다 노드를 생성하고 이를 기존 리스트에 연결한다. 연결구조는 이를 통해 중간에 용량이 부족할 때 두 배 확장해야 하는 번거로움이 없고, 이중 연결구조에서는 노드의 위치만 알고 있다면 그 노드를 바로 삭제할 수 있고, 그 노드 앞 또는 뒤에 새 노드를 쉽게 추가할 수 있다. 하지만 매번 데이터를 삽입할 때마다 동적 생성 비용이 소요되며, 연속 공간에 데이터를 유지하지 않기 때문에 캐싱에 불리하다. 이 때문에 배열을 이용하여 연결구조를 구현하면 연결구조의 이점과 배열 이점을 골고루 갖춘 형태로 연결구조를 구현할 수 있다. \n\n1 Node:  2 item: data type  3 next: array index type \n\n## <그림 5.11> 배열 기반 연결구조의 노드 구조체 \n\n배열을 이용한 단일 연결구조를 구현하기 위해서는 일반 연결구조와 마찬가지로 노드를 나타내는 구조체가 필요하다. 하지만 일반 연결구조와 달리 그림 5.11와 같이 다음 연결 정보는 주소가 아니라 배열의 색인이다. 즉, 구조체 배열을 통해 연결구조를 만들게 되며, 데이터를 삽입할 때마다 노드를 만드는 것이 아니라 미리 일정 용량 구조체 배열을 만들어 사용한다. 그런데 이와 같이 만들면 배열에 있는 노드 중 어떤 것이 사용 중이고 어떤 것이 사용 가능한 노드인지 알아야 한다. 이 때문에 그림 5.12처럼 논리적으로는 두 개의 연결구조 리스트를 유지한다. \n\n하나는 데이터가 저장된 노드의 리스트이고, 다른 하나는 사용 가능한 빈 노드들의 리스트이다. 이렇게 하면 노드를 추가할 때 사용 가능한 빈 노드 중 맨 앞에 있는 노드를 가지고 와서 사용하면 되고, 기존 노드를 삭제할 때는 이 노드를 사용 가능한 빈 노드 리스트로 옮겨야 한다. 노드 배열을 사용하기 때문에 일반 연결구조와 달리 준비한 노드를 모두 사용한 상태일 수 있다. 따라서 일반 연결구조와 달리 배열 기반 리스트처럼 동적 배열 기법의 사용이 필요하다.\n\n![](images/5_0.jpg)\n\n<center><그림 5.12> 배열 기반 연결구조</center>",
    "source": "ds05_4.2_연결구조 기반 리스트 구현의 변형-배열을 이용한 연결구조",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "연결구조 기반 리스트 구현의 변형: 배열을 이용한 연결구조",
      "section_number": "4.2",
      "section_heading": "## 4.2 배열을 이용한 연결구조",
      "parent_section": "4. 연결구조 기반 리스트 구현의 변형",
      "parent_section_number": "4",
      "images": [
        "ds05/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0087"
  },
  {
    "type": "텍스트북",
    "text": "## 4.2.1 멤버 변수와 생성자 \n\n배열 기반 연결구조는 사용하는 배열과 관련된 정보와 연결구조 구현을 위한 정보를 멤버 변수로 유지해야 한다. 현재 용량을 나타내는 capacity, 현재 저장된 요소의 개수를 나타내는 numItems, 노드 배열 nodes, 머리 노드 색인 head, 빈 노드 리스트의 머리 노드 색인 freeHead, 총 5개의 멤버 변수가 필요하다. 일반 연결구조에서는 꼬리 노드의 경우 다음 연결 정보로 널 포인터를 유지하지만 배열 기반 연결구조에서 다음 연결 정보는 색인이므로 언어에 따라 -1 아니면 배열의 용량을 사용해야 한다. 여기서는 이 값을 그로 표현하여 의사코드를 서술한다. \n\n1 for i:=1 to capacity do  2 nodes[i].next := i+1  3 nodes[capacity-1] := 4  freeHead := 1 \n\n## <그림 5.13> 배열 기반 연결구조의 초기화 \n\n또 처음 리스트를 생성하면 모든 노드를 빈 노드 리스트로 그림 5.13과 같이 만들어야 한다.",
    "source": "ds05_2.1_연결구조 기반 리스트 구현의 변형-.1 멤버 변수와 생성자",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "연결구조 기반 리스트 구현의 변형: .1 멤버 변수와 생성자",
      "section_number": "2.1",
      "section_heading": "## 4.2.1 멤버 변수와 생성자",
      "parent_section": "4. 연결구조 기반 리스트 구현의 변형",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0088"
  },
  {
    "type": "텍스트북",
    "text": "## 4.3 각종 연산 \n\n각종 연산의 구현은 기존 연결구조와 다음 측면에서 차이가 있다. 기존 연결구조에서 head는 포인터이지만 배열 기반 연결구조에서는 색인이다. 따라서 curr := curr.next로 다음 노드로 이동하지 않고 curr := nodes[ curr].next로 다음 노드로 이동한다. \n\n노드를 추가할 때에는 빈 노드 리스트에서 다음과 같이 노드를 가져와야 한다. \n\n1 newNodeIdx := freeHead  2 freeHead := nodes[freeHead].next \n\n이것은 빈 노드 리스트에서 빈 노드를 popfront하는 형태이다. 노드를 삭제할 경우에는 삭제한 노드를 빈 노드 리스트에 다음과 같이 추가해야 한다. \n\n1 nodes[idx].next := freeHead  2 freeHead := idx \n\n여기서 idx는 삭제할 노드의 색인이며, 이것은 빈 노드 리스트에 삭제한 노드를 pushfront하는 형태이다. \n\n실제 배열 기반 단일 연결구조에서 pushback과 popback은 그림 5.14와 그림 5.15와 같다. 제시된 것과 같이\n\n\n1 pushback(item):  2 if numItems == capacity then  3 increaseCapacity()  4 if isEmpty() then pushFront(item)  5 else  6 newNodeIdx := freeHead  7 freeHead := nodes[freeHead].next  8 tail := getNode(numItems)  9 nodes[newNodeIdx].item := item  10 nodes[tail].next := newNodeIdx  11 nodes[newNodeIdx].next := -1  12 ++numItems \n\n<그림 5.14> 배열 기반 연결구조의 pushback 메소드 \n\n1 if isEmpty() then throw InvalidStateException  2 prev := NIL  3 curr := head  4 while nodes[curr].next != NIL do  5 prev := curr  6 curr := nodes[curr].next  7 ret := nodes[curr].item  8 if prev!=NIL then nodes[prev].next := NIL  9 else head:=NIL  10 nodes[curr].next := free  11 freeHead := curr  12 --numItems  13 return ret \n\n<그림 5.15> 배열 기반 연결구조의 popback 메소드 \n\n배열 기반 연결구조에서는 더미 노드를 사용하는 것이 번거롭다. 빈 리스트에서 노드를 하나 가지고 와서 사용할 수 있지만 나중에 정리하는 것이 더 번거롭다. \n\n5. 배열과 연결구조의 비교 \n\n배열 기반 리스트와 연결구조 기반 리스트의 각종 연산의 시간 복잡도를 비교하면 표 5.1과 같다. 배열 기반의 경우 동적 배열 기법에 사용에 따른 추가 비용이 발생한다. 따라서 배열 기반의 경우에는 초기 용량을 적절하게 확보하여 사용해야 한다. 물론 연결구조는 데이터를 추가할 때마다 동적 할당이 필요하며, 공간 측면에서도 연결 정보를 유지 하기 위한 추가 공간의 사용이 불가피하다. 또 소멸할 때도 모든 노드를 반납해야 하므로 O(n)의 비용이 소요된다. 캐싱 측면에서는 연속 공간을 확보하는 배열 기반 리스트가 더 효과적이다.\n\n\n<표 5.1> 배열과 단일 연결구조의 각종 연산의 시간 복잡도 비교 \n\n<table><tr><td rowspan=\"3\">배열 기반 리스트</td><td colspan=\"2\">단일 연결구조 기반 리스트</td><td colspan=\"2\">이중 연결구조 기반 리스트</td></tr><tr><td rowspan=\"2\">비정렬</td><td rowspan=\"2\">정렬</td><td rowspan=\"2\">비정렬</td><td rowspan=\"2\">정렬</td></tr><tr></tr><tr><td>find</td><td>O(n)</td><td>O(log n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td></td></tr><tr><td>pushfront</td><td>O(1)*</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td>-</td><td>O(1)</td><td>O(1)</td><td>-</td><td></td><td></td></tr><tr><td>popfront</td><td>O(1)*</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td></td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td></td></tr><tr><td>pushback</td><td>O(1)</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td>-</td><td>O(n)</td><td>O(1)</td><td>-</td><td></td><td></td></tr><tr><td>popback</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td></td></tr><tr><td>add</td><td>-</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(n)</td><td>-</td><td>-</td><td>O(n)</td><td>O(1)</td><td></td></tr><tr><td>removeFirst</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n</td><td></td><td></td></tr><tr><td>get, set</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td></td><td></td></tr></table>\n\n*순서를 유지할 필요가 없거나 순환 배열 방식인 경우",
    "source": "ds05_4.3_연결구조 기반 리스트 구현의 변형-각종 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "연결구조 기반 리스트 구현의 변형: 각종 연산",
      "section_number": "4.3",
      "section_heading": "## 4.3 각종 연산",
      "parent_section": "4. 연결구조 기반 리스트 구현의 변형",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0089"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 개요 \n\n스택, 큐, 덱은 모두 선형 ADT이다. 이들은 다양한 방법으로 구현할 수 있다. 이 장에서는 3가지 ADT의 특징을 살펴보고, 이들에 대한 다양한 구현 방법을 살펴본다.",
    "source": "ds06_1_개요",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "개요",
      "section_number": "1",
      "section_heading": "## 1. 개요",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0090"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 스택 \n\n스택은 2장에서 살펴본 LIFO를 지원하는 선형 ADT이다. 괄호 검사, 그래프 탐색에서 깊이 우선 탐색할 때 스택을 활용한다. 스택은 이처럼 가장 최근에 한 것이 무엇인지 알아야 할 때 많이 사용한다. 또한 프로그램에서 함수가 실행될 때 각 함수의 공간은 LIFO 구조로 생성되기 때문에 함수는 스택 메모리 공간에 생성된다고 한다.",
    "source": "ds06_2_스택",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "스택",
      "section_number": "2",
      "section_heading": "## 2. 스택",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0091"
  },
  {
    "type": "텍스트북",
    "text": "### 2.1 스택의 구현 \n\n한 쪽 방향으로만 삽입과 추출이 이루어지기 때문에 배열과 연결구조를 이용하여 모두 쉽게 구현할 수 있다. 배열의 경우에는 스택의 top이 배열의 끝이 되며, 연결구조의 경우에는 스택의 top이 연결구조의 머리 노드가 되며, 단일 연결구조로도 충분히 스택을 구현할 수 있다. 배열로 구현하면 용량이 제한적이며, 이를 극복하기 위해서는 동적 배열 기법을 사용해야 한다.",
    "source": "ds06_2.1_스택-### 2.1 스택의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "스택: ### 2.1 스택의 구현",
      "section_number": "2.1",
      "section_heading": "### 2.1 스택의 구현",
      "parent_section": "2. 스택",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0092"
  },
  {
    "type": "텍스트북",
    "text": "### 2.2 스택의 응용 \n\n1. `validParenthesis(P):`\n2. `S := empty Stack`\n3. `for c in P do`\n4. `if c=='(' or c=='{ ' or c=='[' then`\n5. `S.push(c)`\n6. `else if c=='}' or c==']' or c=='}' then`\n7. `p = S.top()`\n8. `if p=='(' and c=='}' or p=='{ ' and c=='}' or p=='[' and c==']' then`\n9. `S.pop()`\n10. `return S.isEmpty()`\n\n\n스택은 가장 최근에 본 것, 처리한 것을 기억해야 할 때 활용할 수 있는 자료구조이다. 예를 들어 괄호 검사는 열린 괄호를 만나면 가장 최근에 만난 닫힌 괄호와 일치하는지 검사해야 한다. 이를 위해 닫힌 괄호를 만날때마다 스택에 push하고, 열린 괄호를 만나면 스택에서 pop하여 괄호의 종류가 일치하는지 검사하면 된다. 괄호를 검사 하는 의사코드는 그림 6.1과 같다. 괄호 간의 사용 순서가 있는 경우에는 닫힌 괄호를 스택에 push하기 전에 스택 top에 있는 괄호와 비교하여 순서가 같거나 높은 경우에만 push해야 한다. 예를 들어 괄호, 중괄호('{', '}'), 대괄호('['', ']') 순서로 사용해야 한다고 가정하였을 때, 중괄호가 스택 top에 있을 때 열린 대괄호를 만나면 순서가 잘못된 것이다. \n\n3+4×2와 같은 정수와 사칙 연산으로 구성된 표현식을 평가하는 방법을 생각하여 보자. 표현식의 평가는 연산자 간의 우선순위를 고려해야 하며, 괄호가 있을 경우에는 괄호 내의 식부터 평가해야 한다. 보통 우리가 서술하는 표현식은 사이표기법(infix)이라 한다. 사이표기법에서 이항 연산자는 두 피연산자 사이에 위치한다. 사이표기법으로 서술된 표현식을 후치표기법(postfix)으로 바꿀 수 있다면 스택을 이용하여 간단하게 평가할 수 있다. 예를 들어 3+4×2의 후치표기법은 342×+이다. 후치표기법은 앞에서부터 차례로 분석하면서 숫자를 만나면 스택에 push하고, 연산자를 만나면 스택에서 두 개를 pop하여 처음 추출한 것이 오른쪽 피연산자가 되도록 연산을 수행한 후 결과값을 다시 스택에 push하면 된다. 최종적으로 스택에 있는 값이 평가 결과가 된다. \n\n1 infixToPostfix(P):  2 S := empty Stack  3 ret := empty String  4 for c in P do  5 if c is a number then ret.append(number)  6 else if c=='(' then S.push(c)  7 else if c=')' then  8 while S.top()!='(' do  9 op = S.pop()  10 ret.append(op)  11 S.pop()  12 else if c is a operator then  13 while not S.isEmpty() and S.top()!='(' and  14 precedence(S.top())>precedence(c) do  15 op = S.pop()  16 ret.append(op)  17 S.push(operator)  18 while not S.isEmpty() do  19 op = S.pop()  20 ret.append(op)  21 return ret \n\n<그림 6.2> 스택을 이용한 괄호 검사 \n\n사이표기법을 후치표기법으로 바꿀 때 다음과 같은 특성을 만족한다. \n\n- 사이표기법에서 피연산자의 순서와 후치표기법에서 피연산자의 순서는 바뀌지 않는다. \n\n- 우선순위가 높은 연산자는 후치표기법에서 먼저 나타나야 한다. \n\n우선순위가 높은 연산자를 먼저 후치표기법에 추가하기 위해 스택의 사용이 필요하다. 스택에 연산자를 push하기 전에 자신보다 높은 우선순위 연산자가 스택에 있는지 살펴보아야 하며, 있을 경우에는 그것을 pop하여 후치표기법에 추가해야 한다. \n\n사이표기법을 후치표기법으로 바꾸는 의사코드는 그림 6.2과 같다. 문자 단위로 처리할 경우 이들을 모아 숫자로 만들어야 하며, 단항 - 연산자까지 처리하고자 하면 사전에 이항 - 연산자와 구분하기 위한 전처리가 필요하다.\n\n\n물론 사이표기법을 후치표기법으로 바꾸기 전에 사이표기법이 올바른 표현식인지 검사하는 것이 필요하다. 올바른 표현식인지 미리 검사를 하면 유효한 사이표기법만 바꾸도록 코드를 구성할 수 있어 더 효과적이다.",
    "source": "ds06_2.2_스택-### 2.2 스택의 응용",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "스택: ### 2.2 스택의 응용",
      "section_number": "2.2",
      "section_heading": "### 2.2 스택의 응용",
      "parent_section": "2. 스택",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0093"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 异 \n\n귀는 FIFO(First-In-First-Out) 구조의 ADT이다. FCFS(First-Come-First-Service) 방식으로 처리되는 서비스는 귀를 이용할 수 있다. 예를 들어 개인 PC에서 프린터 귀는 대표적인 FCFS 방식이다. 또한 그래프 탐색에서 너비 우선 탐색할 때에도 귀를 이용한다. 스택은 프로그래밍 경시 대회 문제나 면접 문제를 풀 때 다양하게 활용되는 반면에 귀는 너비 우선 탐색 문제를 제외하면 이와 같은 문제보다는 실제 서비스 구축할 때 많이 사용된다. \n\n우선순위 귀를 정렬 리스트를 이용해 구현하는 것을 생각해 볼 수 있지만 배열 기반과 연결구조 기반 정렬 리 스트를 이용하여 구현하면 모두 삽입이 O(n)이므로 효과적이지 못하다. 따라서 우선순위 귀는 선형 자료구조를 이용하여 구현하지 않고 트리를 이용하여 구현한다. 이에 대해서는 11장에서 자세히 다룬다,",
    "source": "ds06_3_异",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "异",
      "section_number": "3",
      "section_heading": "## 3. 异",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0094"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1 異의 구현 \n\n귀는 뒤 쪽에 추가되고 앞에서 추출되는 구조이다. 삽입되는 방향과 추출하는 방향이 서로 반대되는 구조이다. 큐도 배열과 연결구조를 이용하여 모두 구현할 수 있지만 배열로 구현할 경우 순환 배열을 사용해야 하고, 연결구조의 경우에는 단일 연결구조로 구현이 가능하지만 꼬리 포인터를 유지해야 한다. 즉, 일반적인 FIFO 기반의 귀는 이중 연결구조를 사용하지 않고도 효과적으로 구현할 수 있다.",
    "source": "ds06_3.1_异-異의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "异: 異의 구현",
      "section_number": "3.1",
      "section_heading": "## 3.1 異의 구현",
      "parent_section": "3. 异",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0095"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 度 \n\n덱은 귀의 변형으로 앞 뒤로 모두 삽입할 수 있고 추출할 수 있어야 한다. 이 때문에 덱을 다른 말로 double-ended queue라고 한다. 예를 들어 브라우저에서 방문 목록의 유지는 덱을 이용하여 구현할 수 있다. 방문 목록은 뒤로 추가 삭제가 필요하고, 오래된 방문 기록을 삭제하기 위해서는 앞에서 삭제가 필요하다.",
    "source": "ds06_4_度",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "度",
      "section_number": "4",
      "section_heading": "## 4. 度",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0096"
  },
  {
    "type": "텍스트북",
    "text": "## 4.1 度の 行 \n\n배열을 이용할 경우 순환 배열을 사용해야 하며, 연결구조를 이용할 경우에는 머리와 꼬리 포인터를 모두 유지하는 이중 연결구조로 구현해야 한다. C++는 덱을 순환 배열이나 이중 연결구조로 구현하지 않고 용량이 부족할 때 고정된 크기의 공간을 추가하는 형태로 구현하고 있다. 따라서 일반적인 동적 배열 기법과 달리 공간을 확장할 때 새 공간을 확보하고 기존 데이터를 옮기는 비용이 소요되지 않는다. 하지만 공간이 뒤로만 확장되는 것이 아니라 양방향으로 확장되어야 하므로 내부 구현은 매우 복잡하다.",
    "source": "ds06_4.1_度-度の 行",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "度: 度の 行",
      "section_number": "4.1",
      "section_heading": "## 4.1 度の 行",
      "parent_section": "4. 度",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0097"
  },
  {
    "type": "텍스트북",
    "text": "## 4.1.1 또 다른 동적 배열 기법 \n\n1 Node:  2 items[]: CHUNKSIZE array  3 next: address type \n\n<그림 6.3> 또 다른 동적 배열 기법에서 사용하는 노드 구조체\n\n![](images/3_0.jpg)\n\n<center>(1) d1, d2, d3를 pushBack한 모습 (2) 1에서 d0를 pushFront한 모습 (3) 2에서 d4부터 d7를 pushBack한 모습</center> \n\n## <그림 6.4> std::deque에서 사용하는 동적 배열 기법 \n\n배열 기반 리스트에서 일반적으로 사용하는 동적 배열 기법은 기존보다 용량이 두 배 큰 공간을 확보한 다음 기존 데이터를 복사하는 방식을 사용한다. 이렇게 하지 않고 새 공간을 확보하여 연결하는 방법으로 공간을 확장할 수 있다. 이것은 연결구조와 비슷한 원리이다. 다만, 연결구조는 한번에 데이터를 하나 저장할 수 있는 공간을 확보 하지만 이 방법은 정해진 용량의 배열만큼 확보해서 사용한다. 이때 사용하는 용량의 크기를 CHUNKSIZE라 한다. 실제 연결구조처럼 생각하면 그림 6.3과 같은 구조체를 이용할 수 있다. 하지만 이와 같은 구조를 이용하면 임의 접근을 제공하기 어렵다. \n\n따라서 C++의 std::deque에서 사용하는 기법은 이것과 조금 다르다. 사용하는 CHUNKSIZE 배열을 블 록이라 하면 이들 블록을 가리키는 블록 배열을 그림 6.4처럼 사용한다. 여기서 맨 앞에 있는 데이터는 blocks[ headblock][ head] 형태로 접근하며, 맨 뒤에 있는 데이터는 blocks[ tailblock][ tail] 형태로 접근한다. 블록 배열의 크기보다 많은 수의 블록이 필요하면 그림 6.4의 (3)처럼 블록 배열은 기존 동적 배열 기법을 사용하여 두 배씩 확장한다. \n\n1 pushback(item):  2 if !isEmpty() then ++taill  3 if tail<CHUNKSIZE then  4 if tailblock+1>capacity then increaseCapacity()  5 ++tailblock  6 tail := 1  7 if blocks[tailblock]==1 then  8 blocks[tail] := allocate array of CHUNKSIZE  9 blocks[tailblock][tail] = item  10 ++numItems \n\n## <그림 6.5> deque의 pushback 메소드 \n\n이와 같은 방식에서 pushback 연산의 의사코드는 그림 6.5와 같다. 이 구조에서 tail은 맨 마지막 요소가 저장된 위치이다. 따라서 pushback은 tail을 다음 섹인으로 이동해야 한다. 그런데 기존 tail이 현재 블록의 마지막 색인에 해당하면 다음 블록의 첫 색인으로 이동해야 한다. head와 tail의 초기값으로 -1을 사용하면 처음 에 무존건 ++tail을 할 수 있지만 이 경우 처음으로 데이터를 pushback한 경우에는 head도 첫 색인이 되도록 바꾸어 주어야 한다. \n\n보통 떼에서는 색인 기반 연산이 필요 없지만 이 절에서 사용하는 동적 배열 기법을 리스트 기반 자료구조에 활용한다면 임의 접근을 할 수 있는 색인 기반 연산을 제공할 수 있다. 이것은 연결구조 기반 리스트와 비교하였을\n\n\n1 get(index):  2 checkRange(index)  3 firstBlockItems := CHUNKSIZE-head  4 if firstBlockItems > index then return blocks[headblock][head + index]  5 else:  6 index := index - firstBlockItems  7 return blocks[headblock + index / CHUNKSIZE + 1][index % CHUNKSIZE] \n\n<그림 6.6> deque의 get 메소드 \n\n때 큰 이점이 될 수 있다. 이 방식에서 색인 기반 연산을 구현하기 위해서는 주어진 색인이 어느 블록에 있는지 먼저 찾아야 한다. 우선 첫 블록에 있는지 확인하고, 그 다음 블록부터는 마지막 블록을 제외하고 꽉 차여 있는 상태이므로 나눗셈과 나머지를 이용하여 그림 6.6과 같이 어느 블록 어느 위치에 주어진 색인이 해당하는지 계산할 수 있다.",
    "source": "ds06_1.1_度-.1 또 다른 동적 배열 기법",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제6장 스택, 큐, 덱",
      "section": "度: .1 또 다른 동적 배열 기법",
      "section_number": "1.1",
      "section_heading": "## 4.1.1 또 다른 동적 배열 기법",
      "parent_section": "4. 度",
      "parent_section_number": "4",
      "images": [
        "ds06/images/3_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0098"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 개요 \n\n**그래프(graph)**는 **노드와** 노드를 연결하는 **간선**(edge)으로 이루어지는 구조를 말한다. 그래프에서 간선은 방향성이 있을 수 있고, 없을 수 있다. 경로(path)는 두 개의 노드를 연결하는 일련의 노드를 말한다. 보통 노드보다는 연결하는 일련의 간선을 말한다. 노드 a에서 b까지 경로 a, v₁, v₂, ..., vₖ, b가 존재하기 위해서는 간선 (a, v₁), (v₁, v₂), ..., (vₖ, b)가 존재해야 한다. \n\n**트리(tree)**는 주기(cycle)가 없는 연결된 그래프이다. 주기가 없다는 것은 한 노드에서 시작하여 다시 해당 노드로 되돌아오는 경로가 없다는 것을 말하며, 연결되어 있다는 것은 한 노드에서 다른 모든 노드로 가는 경로가 있다는 것을 말한다. 트리를 다르게 표현하면 한 노드에서 다른 노드로 가는 경로가 유일한 연결된 그래프이다. 트리는 보통 간선의 방향을 표시하지 않는다. 간선의 방향이 없어야 실제 연결된 그래프가 될 수 있다. \n\n![](images/0_0.jpg)\n\n \n\n<center>그림 7.1> 루트가 있는 트리</center> \n\n보통 트리는 **루트(root)**라는 특수 노드가 존재한다. 그림 7.1에서 A 노드가 루트 노드이다. 루트 노드 개념이 없는 트리(unrooted tree)도 가능하다. 루트 노드가 있는 트리의 경우 트리를 그림 때 가장 위에 루트 노드를 그리며, 트리에 대한 탐색은 항상 이 노드로부터 시작한다. 루트 노드가 있는 트리에서 위에서 아래로 간선의 방향이 있다고 가정하면 루트 노드는 들어오는 간선은 없고 나가는 간선만 있다. 그림 7.1과 같은 트리에서 B에서 D로 나가는 간선으로 연결된 두 노드가 있을 때, B를 D의 부모 노드, D를 A의 자식 노드라 한다. 하지만 실제 트리를 그림 때 방향성 있는 간선을 이용하여 그리지 않는다. \n\n트리의 특징은 다음과 같다. \n\n- 주기가 없는 연결된 그래프이다. \n\n- 주기가 없지만 간선을 하나 추가하면 주기가 생기는 그래프이다. \n\n- 하나의 간선을 제거하면 연결되어 있지 않는 그래프가 된다. \n\n- 모든 두 노드 간의 유일한 경로가 존재하는 그래프이다.\n\n\n그래프에 n개의 노드가 있고, 연결되어 있으며, 간선의 수가 n - 1이면 이 그래프는 트리가 된다. 참고로 이 단락에 제시된 정의들은 빈 트리(노드가 하나도 없는 경우)에 대해서는 성립하지 않는다. \n\n이 장에서는 루트가 있는 트리만 다룬다. 한 노드는 여러 개의 자식 노드를 가질 수 있으며, 한 노드가 최대 2개의 자식 노드를 가질 수 있는 트리를 이진 트리(binary tree)라 한다. 연결구조도 자식이 최대 하나인 트리로 생각할 수 있다. \n\n트리에 있는 각 노드를 이용하여 각 노드가 루트 노드가 되는 부분 트리(subtree)를 만들 수 있다. 이 때문 에 트리를 재귀 구조(recursive structure)라 한다. 재귀 구조이기 때문에 트리에서 각종 알고리즘의 구현은 재귀 프로그래밍으로 구현하면 매우 편리하게 구현할 수 있다.",
    "source": "ds07_1_개요",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "개요",
      "section_number": "1",
      "section_heading": "## 1. 개요",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds07/images/0_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0099"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 용어 \n\n 루트 노드: 부모가 없는 노드이며, 트리에 오직 하나의 루트 노드만 존재한다. \n\n 중간 노드(internal node, intermediate node): 루트를 포함하여 자식을 가지고 있는 노드를 말한다. \n\n 단말 노드(leaf node): 자식이 없는 노드를 말한다. \n\n 형제 노드(sibling node): 부모가 같은 노드를 말한다. \n\n 조상 노드(ancestor node): 노드의 부모 노드부터 루트 노드까지 경로 상에 있는 모든 노드는 해당 노드의 조상 노드가 된다. \n\n 후손 노드(descendant node): 노드의 자식 노드들부터 단말 노드들까지 경로 상에 있는 모든 노드 (후손 노드의 경우에는 경로가 여러 개 존재할 수 있음)가 후손 노드가 된다. \n\n 노드의 레벨: 루트 노드로부터의 거리+1이다. 따라서 루트 노드의 레벨은 1이다. 루트 노드의 레벨을 0이라고 하는 경우도 있다. 레벨은 교재마다 정의에 차이가 있다. 루트 노드의 레벨을 0이라 하면 노드의 깊이와 레벨은 같은 개념이 된다. \n\n 노드의 깊이(depth): 루트 노드로부터의 거리를 말한다. \n\n 노드의 높이(height): 노드에서 가장 먼 후손 단말 노드까지의 경로 길이(간선의 수)를 말한다. \n\n 트리의 높이: 루트 노드의 높이를 말한다. 빈 트리의 높이는 일관성을 위해 종종 -1로 표현한다. \n\n이진 트리에서 왼쪽, 오른쪽 자식 노드라는 용어도 사용된다.",
    "source": "ds07_2_용어",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "용어",
      "section_number": "2",
      "section_heading": "## 2. 용어",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0100"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 트리의 구현 \n\n지금까지 살펴본 선형 자료구조는 대부분의 프로그래밍 언어 라이브러리에서 제공한다. 하지만 어떤 데이터를 트리 로 표현하고 싶을 때 이것을 제공해주는 직접적인 라이브러리는 없다. 물론 라이브러리를 통해 제공되는 자료구조 중 트리구조를 사용하는 것도 있지만 일반적인 트리를 표현하고 싶을 때 이를 할 수 있도록 해주는 라이브러리를 보통 제공해주지 않는다. \n\n일반적인 트리는 연결구조와 비슷하게 트리 노드 구조체를 정하고 이를 연결하여 트리를 표현하게 된다. 트리 노드 구조체는 보통 그림 7.2와 같이 정의한다. 이 트리 노드는 자식 수의 제한이 없으며, 제한이 없는 자식과 연결 하기 위해 선형 리스트 자료구조로 자식 목록을 유지한다. 트리 중 자식이 최대 2개인 이진 트리의 경우에는 트리\n\n\n1  TreeNode:  2  label: label type  3  childs: list data structure \n\n## <그림 7.2> 트리 노드 구조체 \n\n1  TreeNode:  2  label: label type  3  left: address of TreeNode  4  right: address of TreeNode \n\n## <그림 7.3> 이진 트리 노드 구조체 \n\n노드를 그림 7.3과 같이 정의한다. 이진 트리에서 right을 제외하고 left를 next로 생각하면 단일 연결구조의 노드와 차이가 없다. 또 제시된 트리 노드에 다음과 같이 부모 링크를 추가하는 경우도 있다. \n\n## 1 parent: address of TreeNode \n\n부모 링크를 유지하면 자식에서 위로 탐색이 필요할 때 효과적으로 활용할 수 있지만 각 노드가 유지하는 정보가 많아지며, 노드를 추가, 삭제할 때 갱신해야 하는 것이 많아지는 단점이 있다. \n\n트리 노드 구조체가 있으면 트리 노드만 이용하여 트리를 구성할 수 있고 연결구조처럼 트리라는 클래스를 만들고 그것의 멤버 변수로 root와 필요하면 노드의 개수를 나타내는 numNodes를 유지하여 표현할 수 있다. \n\n보통 트리 노드에는 다음과 같은 메소드를 추가하여 트리를 구축하는데 활용할 수 있다. \n\n● numChilds: 자식 노드의 개수 \n\n● getLabel: 노드의 레이블 조회하기 \n\n● addChild: 자식 노드의 추가 \n\n● removeChild: 섹인을 이용한 자식 노드의 제거 \n\n● getChild: 섹인을 이용한 특정 자식 노드 접근하기",
    "source": "ds07_3_트리의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "트리의 구현",
      "section_number": "3",
      "section_heading": "## 3. 트리의 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0101"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1 합성 패턴 \n\n객체지향 설계 패턴 중 합성 패턴(composite pattern)이라는 것이 있다. 합성 패턴은 개별 객체나 객체의 집합을 구분하지 않고 동일하게 접근할 수 있게 해주는 패턴이다. 하지만 객체지향에서 트리를 표현해야 할 때 이 패턴을 사용할 수도 있다. 이 패턴은 이전 절처럼 트리 노드 구조체를 하나 만들어 트리를 표현하지 않고, 트리를 중간 노드와 단말 노드를 구분하여 표현한다. \n\n보통 합성 패턴은 Node라는 추상 클래스를 정의한 후에 그것을 상속받는 NonLeaf와 Leaf를 정의하여 트리를 표현한다. 여기서 중간 노드에 해당하는 NoneLeaf만 자식 목록을 유지한다. 이 패턴을 사용하면 보통 트리에 있는 노드는 Node 타입의 참조 변수를 이용하여 조작한다. 따라서 자식의 추가, 삭제 등 중간 노드만 할 수 있는 기능도 Node 클래스에 선언 또는 정의되어 있어야 한다. 이들을 추상 메소드로 선언하고 Leaf는 이들을 빈 메소드나 예외가 발생하도록 재정의하거나 거꾸로 Node에 빈 메소드나 예외가 발생하는 형태로 정의하고, NonLeaf에서는 올바르게 동작하도록 재정의할 수 있다.\n\n\n합성 패턴을 이용하여 트리를 표현하면 중간 노드와 단말 노드가 명확하게 구분되며, 중간 노드를 단말 노드로 또는 단말 노드를 중간 노드로 바꾸는 것이 어렵다. 따라서 트리에 노드가 추가됨에 따라 단말 노드가 중간 노드가 될 수 있는 형태에서는 이 패턴을 사용하여 트리를 표현하기 어렵다.",
    "source": "ds07_3.1_트리의 구현-합성 패턴",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "트리의 구현: 합성 패턴",
      "section_number": "3.1",
      "section_heading": "## 3.1 합성 패턴",
      "parent_section": "3. 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0102"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 트리의 탐색 \n\n트리에 있는 모든 노드를 탐색하여 특정 노드를 찾거나 전체 노드를 한번씩 방문하면서 처리해야 할 때 사용하는 것이 트리 탐색 알고리즘이다. 트리는 그래프의 한 종류이므로 트리 탐색도 그래프 탐색 알고리즘을 보통 사용한 다. 그래프를 탐색할 때 가장 널리 사용하는 탐색 방법은 깊이 우선 탐색(DFS, Depth First Search)과 너비 우선 탐색(BFS, Breadth First Search)이다. 둘 다 시간 복잡도는 같지만 탐색하는 순서가 다르다. \n\n깊이 우선은 한 쪽 방향으로 가장 단말까지 방문하는 형태인 반면에 너비 우선은 루트부터 같은 레벨에 있 는 노드부터 방문하는 형태이다. 깊이 우선은 스택 자료구조를 이용하거나 재귀 호출을 이용하여 구현하고, 너비 우선은 FIFO 큐 자료구조를 이용하여 구현한다. 깊이 우선에서 스택을 사용할 경우 스택에 push하는 순서가 방문 하는 순서에 영향을 준다. 보통 일반 그래프에서 탐색은 방문한 노드를 다시 처리하지 않도록 방문 여부를 나타내는 visited 배열의 사용이 필요하지만 트리는 주기가 없기 때문에 한번 방문한 노드를 다시 방문할 수 없어 visited 배열의 사용이 필요없다. \n\n1 DFS(Tree, node)  2 for each child of node do  3 DFS(Tree, child) \n\n## <그림 7.4> 재귀호출을 이용한 DFS \n\n1 DFS(Tree, node)  2 S := empty stack  3 S.push(node)  4 while S is not empty do  5 currNode := S.pop()  6 for each child of currNode do  7 S.push(child) \n\n## <그림 7.5> 스택을 이용한 DFS \n\n재귀호출을 이용한 깊이 우선 탐색 알고리즘의 의사코드는 그림 7.4와 같으며, 스택을 이용한 깊이 우선 탐색 알고리즘은 그림 7.5와 같다. 보통 방문하는 과정에서 노드에 대한 처리가 필요하면 재귀호출을 이용하는 경우에는 반복문 이전에 인자로 전달한 노드에 대한 처리를 하고, 스택을 이용한 버전의 경우에는 while 반복문 내에서 pop 한 이후에 처리한다. \n\n1 BFS(Tree, node)  2 Q := empty stack  3 Q.push(node)  4 while Q is not empty do  5 currNode := Q.pop()  6 for each child of currNode do  7 Q.push(child) \n\n## <그림 7.6> 큐를 이용한 BFS \n\n너비 우선 탐색은 재귀 버전으로 작성할 수 없고, FIFO 큐를 이용해야 하며, 그것의 의사코드는 그림 7.6과 같다.\n\n\n제시된 코드는 스택을 이용한 DFS와 비교하여 스택 대신에 큐를 사용하는 것 외에 차이가 전혀 없다. \n\n![](images/4_0.jpg)\n\n \n\n<그림 7.7> DFS, BFS 탐색을 위한 트리 \n\n그림 7.7에 주어진 트리에 대한 DFS와 BFS 탐색에 의한 방문 순서를 생각하여 보자. 둘다 스택과 큐를 이용한 버전을 생각한다고 고려하고, 왼쪽 자식을 먼저 스택 또는 큐에 삽입한다고 가정하자. DFS는 0을 시작으로 스택에 1과 2를 push하게 된다. 이 경우 그다음 방문하게 되는 노드는 2이다. 2를 방문하면 5와 6을 push하게 되며 그다음 6을 처리하게 된다. 따라서 방문한 순서는 다음과 같다. \n\n\\[\n0, 2, 6, 11, 10, 5, 1, 4, 3, 9, 8, 7\n\\]\n\n이 순서는 그렇게 직관적이지 않다. 재귀버전을 이용하였고 왼쪽 자식에 대해 먼저 재귀 호출이 이루어진다면\n방문하는 순서는 다음과 같다. \n\n\\[\n0, 1, 3, 7, 8, 9, 4, 2, 5, 6, 10, 11\n\\]\n\nBFS를 이용하면 레벨 순서로 방문하게 되므로 방문하는 순서는 매우 직관적이다. \n\n\\[\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n\\]\n\nDFS와 BFS의 시간 복잡도를 검토해 보자. 이때 트리에 있는 노드의 수는 n이라 가정하자. 스택과 큐를 이용하는 버전을 생각하여 보자. 각 스택 또는 큐에 트리의 노드는 한번 push되고 한번 pop된다. 따라서 이중 반복문으로 되어 있지만 스택과 큐와 관련된 전체 비용은 O(n)이다. 실제 각 노드마다 자식을 잇는 간선을 고려하게 되므로 바깥 while문은 n번 반복하지만 그때마다 내부 for문은 가변적이다. 하지만 내부 for문이 반복하는 전체 횟수는 간선 수에 비례한다. 트리에서 간선 수는 총 n - 1개 존재하므로 총 반복 비용도 O(n)이다. 따라서 탐색의 전체 비용은 O(n)이다.",
    "source": "ds07_4_트리의 탐색",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "트리의 탐색",
      "section_number": "4",
      "section_heading": "## 4. 트리의 탐색",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds07/images/4_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0103"
  },
  {
    "type": "텍스트북",
    "text": "## 5. 이진 트리 \n\n이진 트리는 앞서 언급한 바와 같이 최대 두 개의 자식을 가질 수 있는 트리를 말한다. 루트 노드를 제외하고 모두\n부모 노드를 가지고 있다. 각 레벨 l에 있을 수 있는 최대 노드의 수는 2<sup>l-1</sup>이다. 따라서 높이가 h인 이진 트리에\n있을 수 있는 최대 노드의 수는 \n\n\\[\n2^0 + 2^1 + \\cdots + 2^h = 2^{h+1} - 1\n\\]\n\n이며, 최소 노드의 수는 레벨마다 노드가 하나 있는 경우이므로 h+1이다. 따라서 트리의 높이가 h이면 노드 수 n의\n범위는 h+1 ≤ n < 2<sup>h+1</sup>이다. 이 범위를 h의 범위로 바꾸면 log<sub>2</sub> n - 1 < h ≤ n - 1이다. 그러므로 n개의 노드로\n만들 수 있는 트리의 최소 높이는 ⌈log<sub>2</sub> n⌉이고, 최대 높이는 n - 1이다.\n\n![](images/5_0.jpg)\n\n<center><그림 7.8> 이진 트리의 종류</center>",
    "source": "ds07_5_이진 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "이진 트리",
      "section_number": "5",
      "section_heading": "## 5. 이진 트리",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds07/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0104"
  },
  {
    "type": "텍스트북",
    "text": "## 5.1 이진 트리의 종류 \n\n포화 이진 트리(full binary tree)는 모든 노드의 자식 수가 0 또는 2인 이진 트리를 말한다. 완전 이진 트리(complete binary tree)는 마지막 레벨을 제외하면 모두 채워져 있고, 마지막 레벨의 단말 노드는 왼쪽에서부터 채워진 형태로 되어 있는 이진 트리를 말한다. 완전 이진 트리에서 모든 중간 노드의 자식 수가 2이고 단말 노드의 수가 n이면 전체 노드의 수는 2n - 1이다. 완벽 이진 트리(perfect binary tree)는 모든 중간 노드의 자식 수가 2이며, 모든 단말은 같은 레벨에 있는 이진 트리를 말한다. 완벽 이진 트리는 완전 이진 트리이며, 포화 이진 트리이다. \n\n균형(balance) 이진 트리는 모든 노드의 왼쪽 부분 트리의 높이와 오른쪽 부분 트리의 높이의 차이가 1이하인 경우를 말한다. 완벽 균형 이진 트리는 루트에서 모든 단말까지의 거리가 같은 이진 트리를 말한다. 균형 개념은 꼭 이진 트리에만 적용하는 개념은 아니다. 보통 트리와 관련된 연산은 트리의 높이에 비례하는 경우가 대부분이며, 트리가 완전 이진 트리이어야 가장 최적의 높이가 되며, 이때 트리의 높이는 log n에 비례한다. 하지만 항상 트리가 완전 이진 트리가 되도록 유지하는 것이 어렵기 때문에 그다음 목표를 하는 것이 균형 트리이다. 트리가 균형이면 트리의 높이는 여전히 log n에 비례한다. 트리의 균형 여부를 알기 위해서는 각 노드의 높이를 알아야 하고, 각 노드의 왼쪽과 오른쪽 부분트리의 높이의 차이를 계산해야 한다. 이 차이를 보통 균형 인수(balance factor)라 한다. 균형 인수는 오른쪽 부분트리의 높이에서 왼쪽 부분트리의 높이 뺀 값이다. \n\n완전 이진 트리에서 노드의 레이블을 루트부터 BFS를 통해 만나는 순서대로 부여할 수 있다. 0색인 또는 1 색인을 사용할 수 있는데, 프로그램면 언어에서 많이 사용하는 0색인을 생각하면 노드 i가 주어졌을 때 그것의 부모 노드 레이블은 (i - 1)/2이며, 왼쪽 자식 노드는 2i + 1이다. 이 개념이 중요한 이유는 이진 트리를 구현할 때 항상 완전 이진 트리를 유지할 수 있다면 노드의 연결에 의해 트리를 표현하지 않고 배열을 이용하여 트리를 표현할 수 있다. 11장에서 살펴보는 힙(heap) 자료구조가 이와 같이 배열을 이용하여 이진 트리를 표현한다.",
    "source": "ds07_5.1_이진 트리-이진 트리의 종류",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "이진 트리: 이진 트리의 종류",
      "section_number": "5.1",
      "section_heading": "## 5.1 이진 트리의 종류",
      "parent_section": "5. 이진 트리",
      "parent_section_number": "5",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0105"
  },
  {
    "type": "텍스트북",
    "text": "## 5.2 이진 트리의 순회 \n\n여기서 순회(traversal)란 트리에 있는 모든 노드를 방문하는 것을 말한다. 탐색과 다른 점은 탐색도 순회를 할 수 있어야 하지만 찾고자 하는 것을 찾으면 탐색은 중단된다. 트리를 순회하는 방법에는 크게 다음과 같은 4가지 방법이 있다. \n\n• 전위(pre-order) 순회: 루트 노드를 방문하고 왼쪽 부분 트리를 오른쪽 보다 먼저 방문하는 순회 방법 \n\n• 중위(in-order) 순회: 왼쪽 부분 트리를 먼저 방문한 후에 루트 노드를 방문하고 그 다음 오른쪽 부분 트리를 방문하는 순회 방법 \n\n• 후위(post-order) 순회: 왼쪽 부분 트리를 먼저 방문한 후에 오른쪽 부분 트리를 방문하고 루트 노드를 가장 늦게 방문하는 방법\n\n\n 레벨 기준(level order) 순회: 낮은 레벨에 있는 노드 순으로 방문하는 방법 \n\n전위, 중위, 후위 방법은 모두 항상 왼쪽 부분 트리를 오른쪽보다 먼저 방문한다. 따라서 루트 노드를 방문하는 순 서에 의해 차이가 있다. 전위는 루트부터, 중위는 루트를 중간에, 후위는 루트를 가장 마지막에 방문하는 방법이다. 8장에서 살펴보는 이진 검색 트리의 경우 용도에 따라 그것에 맞는 순회 방법을 사용해야 한다. \n\n보통 다른 일반 트리의 경우에는 이와 같이 전위, 중위, 후위 방법을 사용하지 않고 DFS, BFS 탐색 방법을 사용한다. 실제 전위 방법은 재귀호출 방식의 DFS와 방문 순서가 같으며, 레벨 기준 순회는 BFS를 말한다. \n\n## 연습문제 \n\n1. 다음에 같은 이진 트리가 주어졌을 때 전위, 중위, 후위 순으로 순회하였을 때 방문하는 순서를 제시하시오. \n\n![](images/6_0.jpg)",
    "source": "ds07_5.2_이진 트리-이진 트리의 순회",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제7장 트리",
      "section": "이진 트리: 이진 트리의 순회",
      "section_number": "5.2",
      "section_heading": "## 5.2 이진 트리의 순회",
      "parent_section": "5. 이진 트리",
      "parent_section_number": "5",
      "images": [
        "ds07/images/6_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0106"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 이진 검색 트리 \n\n![](images/1_0.jpg)\n\n<center><그림 8.1> 이진 검색 트리</center> \n\n이진 검색 트리는 그림 8.1과 같이 각 노드에 검색할 키 값을 유지하는 이진 트리이며, 각 노드의 키 값이 왼쪽 후손 노드의 키 값보다 항상 크고, 오른쪽 후손 노드의 키 값보다는 항상 작은 이진 트리이다. 검색을 목적으로 하기 때문에 보통 중복된 요소를 유지하지 않는다. 이진 검색 트리는 삽입된 순서에 의해 모습이 결정되며, 정렬된 순서로 삽입할 경우 매우 편향된 이진 트리가 된다. \n\n그림 8.1에 제시된 이진 검색 트리를 전위, 중위, 후위 순회를 하면 방문하는 순서는 다음과 같다. \n\n● 전위: 60, 45, 41, 40, 43, 55, 50, 63, 62, 65 \n\n● 중위: 40, 41, 43, 45, 50, 55, 60, 62, 63, 65 \n\n● 후위: 40, 43, 41, 50, 55, 45, 62, 65, 63, 60 \n\n순회 결과를 보면 중위 순회만 의미가 있어 보인다. 이진 검색 트리에 대한 중위 순회를 하면 검색기에 대해 오름 차순으로 정렬된 순서로 방문하게 된다. 그러면 전위와 후위는 사용할 일은 없나? 전위는 현재의 이진 검색 트리와 같은 모습의 이진 검색 트리를 만들고 싶을 때 사용할 수 있다. 전위 순회 방법으로 키 값을 확보한 후에 해당 순서로 트리를 구성하면 원래 이진 검색 트리를 그대로 얻을 수 있다. 후위는 항상 단말부터 접근하기 때문에 C++와 같은 언어에서 단말부터 차례로 노드를 반납하고 싶으면 해당 순회 방법으로 방문하면서 해당 노드를 반납하면 된다. 물론 보통 소멸자는 후위 순위로 방문하면서 노드를 반납하는 방법을 사용하지는 않는다. 후위 순위로 방문하지 않아도 충분히 모두 반납할 수 있기 때문이다.",
    "source": "ds08_2_이진 검색 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리",
      "section_number": "2",
      "section_heading": "## 2. 이진 검색 트리",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds08/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0107"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 이진 검색 트리의 구현 \n\n1 TreeNode:  2 key: key type  3 left: address of TreeNode  4 right: address of TreeNode \n\n## <그림 8.2> 이진 검색 트리 노드 구조체 \n\n이진 검색 트리는 그림 8.2와 같은 노드 구조체를 정의하고 멤버 변수로 root와 노드의 개수를 나타내는 numNodes를 유지하는 BST 클래스를 정의하여 구현한다. 이때 그림 8.2와 달리 부모 노드에 대한 연결을 트리 노드 구조체에 추가로 유지할 수 있다. 이진 검색 트리는 트리의 일종이며, 재귀적 구조이므로 보통 재귀 방식으로 구현하는 것이 가장 직관적이고 간결하다. 물론 모든 연산을 비재귀적으로도 충분히 구현할 수 있다.",
    "source": "ds08_3_이진 검색 트리의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현",
      "section_number": "3",
      "section_heading": "## 3. 이진 검색 트리의 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0108"
  },
  {
    "type": "텍스트북",
    "text": "### 3.1 재귀적 구현 \n\n1. size(): 2. return size(root) 3. 4. size(node): 5. if node == \\(\\perp\\) then return 0 6. return 1+size(node.left)+size(node.right) \n\n<그림 8.3> 이진 검색 트리: size 메소드 \n\n노드의 개수는 유지하고 있는 numNodes를 반환하는 형태로 간단히 구현할 수 있지만 재귀 방식의 구현에 익숙해지기 위해 노드의 개수를 반환하여주는 연산을 재귀적으로 구현해 보자. 재귀적으로 구현하기 위해서는 재귀적으로 해당 연산을 표현할 수 있어야 한다. 노드의 개수는 루트의 왼쪽 부분 트리에 있는 노드의 수에 오른쪽 부분 트리에 있는 노드 수를 더하고 거기에 루트 노드를 고려하여 1을 추가하면 된다. 항상 재귀적으로 구현할 경우 재귀 종료 조건이 중요하다. 노드의 개수의 경우 더 이상 자식 노드가 없으면 0을 반환하면 된다. \n\n노드의 개수를 반환하여 주는 재귀 방식의 의사코드는 그림 8.3과 같다. 여기서 종료 조건으로 다음을 하나 더 추가하여 \n\nif node.right == \\(\\perp\\) and node.right == \\(\\perp\\) then return 1 \n\n재귀 호출의 수를 줄이는 것이 더 효과적이라고 생각할 수 있지만 재귀 호출마다 매번 비교 연산이 하나 더 추가되며, 코드가 더 길어지므로 그림 8.3처럼 간결한 프로그래밍하는 것이 더 효과적이다. 보통 BST의 size 연산은 매개변수가 없는 연산이므로 BST의 size는 재귀 버전의 size에 root 멤버 변수를 인자로 전달하는 형태로 구현하게 된다. \n\n1. height(node): 2. if node == \\(\\perp\\) then return -1 3. return 1+max(height(node.left), height(node.right)) \n\n<그림 8.4> 이진 검색 트리: height 메소드 \n\n노드의 높이도 유사하게 구현할 수 있다. 노드의 높이는 왼쪽 부분 트리의 높이와 오른쪽 부분 트리의 높이를 비교하여 큰 폭에 1을 추가하면 된다. 이 경우에 높이의 정의를 잘 생각하여 종료 조건을 결정해야 한다. 루트 노드가 하나가 있는 트리의 높이는 0이고, 빈 트리의 높이는 -1이다. \n\n1. findNode(key, node): 2. if node.key == key then return node 3. nextNode := if node.key > key then node.left else node.right 4. if nextNode != \\(\\perp\\) then return findNode(key, nextNode) 5. else return node \n\n<그림 8.5> 이진 검색 트리: findNode 메소드 \n\n찾기 연산은 루트 노드부터 비교하여 찾고자 하는 것이 루트 노드의 키 값보다 작으면 왼쪽 부분 트리로 크면 오른쪽 부분 트리로 검색을 계속 진행하면 된다. 찾기 연산은 나중에 삽입, 삭제할 때도 필요하기 때문에 찾고자 하는 노드가 있을 경우 해당 노드를 반환하고, 없으면 해당 키 값을 삽입할 부모 노드를 반환하도록 만드는 것이 편리하다. 이것을 해주는 찾기 연산의 의사코드는 그림 8.5와 같다. 그림 8.5에 제시된 코드는 인자로 주어진 node가 널포인터인 경우를 고려하고 있지 않다. 따라서 실제 find 연산에서는 root가 널포인터인 경우에는 이 메소드를 호출하지 않아야 한다.\n\n\n이진 검색 트리처럼 비선형 자료구조를 이해할 때 다음에 제시된 시각화 사이트에서 삽입과 삭제에 따라 어떻게 트리가 변화하는지 관찰해 보는 것이 많은 도움이 된다. \n\n● https://www.cs.usfca.edu/~galles/visualization/ \n\n● https://visualgo.net/en/ \n\n1 addNode(node, newNode):  2 if node.key == newNode.key then return  3 nextNode := if node.key > newNode.key then node.left else node.right  4 if nextNode != ⊥ then return addNode(nextNode, newNode)  5 else  6 if node.key > newNode.key then node.left := newNode  7 else node.right := newNode  8 ++numNodes \n\n## <그림 8.6> 이진 검색 트리: addNode 메소드 \n\n이진 검색 트리에서 키 값의 삽입은 항상 단말로 삽입된다. 먼저 삽입할 키 값을 유지하는 노드를 생성한 다음 현재 트리를 탐색한다. 이미 같은 값의 키를 발견하면 중복된 요소이므로 값의 삽입은 중단된다. 이 과정은 이미 작성한 findNode 메소드를 활용할 수 있다. findNode 메소드를 활용하지 않고 작성하면 재귀적으로 구성된 addNode 메소드의 작성이 필요하다. 현재 트리가 빈 상태일 수 있으므로 이것을 고려하면 코드가 더 복잡해지므로 빈 상태에서는 root가 새 노드를 가리키도록 하고, addNode 메소드는 빈 상태가 아닐 경우에만 호출하도록 구성하는 것이 편리하다. 이와 같은 형태의 addNode 메소드의 의사코드는 그림 8.6과 같다. \n\n1 add(key):  2 newNode := allocate TreeNode(key)  3 if isEmpty() then root := newNode  4 else  5 parent := findNode(key, root)  6 if parent.key == key then return  7 if parent.key > key then parent.left := newNode  8 else parent.right := newNode  9 ++numNodes \n\n## <그림 8.7> 이진 검색 트리: add 메소드 \n\nfindNode를 활용한 새 키 값 삽입 연산의 의사코드는 그림 8.7와 같다. \n\n이진 검색 트리의 기본 연산 중 가장 복잡한 것이 노드의 삭제이다. 노드의 삭제는 다음 3가지 경우로 나누어질 수 있다. \n\n 단말의 삭제 \n\n 자식이 하나 있는 노드의 삭제 \n\n● 자식이 둘 있는 노드의 삭제 \n\n삭제는 항상 삭제할 노드부터 찾은 후에 이 노드가 위 3가지 중 어떤 경우에 해당하는지 파악해야 한다. 위 3가지 경우에 가장 간단한 것이 단말의 삭제이다. 해당 부모의 연결을 끊어 주고 노드를 반납하면 된다. 자신이 하나 있는 노드의 삭제는 삭제할 노드의 부모의 포인터를 삭제할 노드의 자신으로 바꾸어 주고 노드를 반납하면 된다. 두 가지 경우 모두 부모 노드의 갱신이 필요하다는 것이다. 지금 구현하는 이진 검색 트리에서 노드는 부모 링크를 유지하고\n\n\n1 remove(key):  2 S := empty stack  3 delNode := findNode(key, root, S)  4 if delNode.key != key then return  5 parent := S.pop()  6 if delNode.left != \\(\\perp\\) and delNode.right != \\(\\perp\\) then  7 parent := delNode  8 prevNode := delNode.left  9 while prevNode.right != \\(\\perp\\) do  10 parent := prevNode  11 delNode := prevNode.right  12 delNode.key := prevNode.key  13 delNode := prevNode  14 removeSingleChild(parent, delNode)  15 - - numNodes  16  17 removeSingleChild(parent, delNode):  18 if parent == \\(\\perp\\) then root := \\(\\perp\\)  19 else  20 childNode := if delNode.left != \\(\\perp\\) then delNode.left else delNode.right  21 if parent.key > key then parent.left := childNode  22 else parent.right := childNode  23 free delNode \n\n## <그림 8.8> 이진 검색 트리: remove 메소드 \n\n있지 않다. 따라서 노드를 찾을 때 부모 정보를 계속 만들어 나가야 한다. 그림 8.8에서 사용한 findNode 메소드는 인자로 전달한 스택에 탐색 과정에서 지나친 모든 노드를 차례로 유지한다. 루트부터 탐색이 진행되고 있으므로 탐색한 노드를 스택 자료구조에 포함하면 이 스택에 top에 있는 것이 현재 노드의 부모 노드가 된다.",
    "source": "ds08_3.1_이진 검색 트리의 구현-### 3.1 재귀적 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: ### 3.1 재귀적 구현",
      "section_number": "3.1",
      "section_heading": "### 3.1 재귀적 구현",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0109"
  },
  {
    "type": "텍스트북",
    "text": "자식이 둘이 있는 경우에는 그것을 직접 삭제하기가 불편하다. 따라서 그 노드의 키 값을 바꾸는 것을 생각해 볼 필요가 있다. 해당 노드의 왼쪽 부분 트리에서 가장 큰 값 또는 오른쪽 부분 트리에서 가장 작은 값이 해당 위치와 바꿀 수 있는 값이다. 현재 상황은 양쪽 모두 노드가 있는 경우이기 때문에 어느 쪽도 상관없다. 또 둘 다 단말이거나 자식이 하나 있는 노드이므로 교체한 후에 그값이 있는 노드를 삭제하면 실제 삭제 효과를 얻을 수 있다. 그림 8.8 에서는 왼쪽 부분 트리의 가장 큰 값을 이용한다. \n\n그림 8.8에서 removeSingleChild는 삭제할 노드가 단말이거나 자식이 하나 있는 노드일 경우 해당 노드를 제거하기 위해 사용하는 메소드이다. 자식이 두 개가 있는 노드의 경우에도 선행 노드 값으로 바꾼 후에 선행 노드 를 삭제하게 되는데, 선행 노드는 항상 단말이거나 자식이 하나있는 노드이므로 그림 8.8과 같이 최종적으로 모두 1stinlineremoveSingleChild를 통해 노드의 삭제를 마무리한다.",
    "source": "ds08_8.8_이진 검색 트리의 구현-자식이 둘이 있는 경우에는 그것을 직접 삭제하기가 불편하다. 따라서 그 노드의 키 값을 바꾸는 것을 생각해 볼 필요가 있다. 해당 노드의 왼쪽 부분 트리에서 가장 큰 값 또는 오른쪽 부분 트리에서 가장 작은 값이 해당 위치와 바꿀 수 있는 값이다. 현재 상황은 양쪽 모두 노드가 있는 경우이기 때문에 어느 쪽도 상관없다. 또 둘 다 단말이거나 자식이 하나 있는 노드이므로 교체한 후에 그값이 있는 노드를 삭제하면 실제 삭제 효과를 얻을 수 있다. 그림 8.8 에서는 왼쪽 부분 트리의 가장 큰 값을 이용한다.",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: 자식이 둘이 있는 경우에는 그것을 직접 삭제하기가 불편하다. 따라서 그 노드의 키 값을 바꾸는 것을 생각해 볼 필요가 있다. 해당 노드의 왼쪽 부분 트리에서 가장 큰 값 또는 오른쪽 부분 트리에서 가장 작은 값이 해당 위치와 바꿀 수 있는 값이다. 현재 상황은 양쪽 모두 노드가 있는 경우이기 때문에 어느 쪽도 상관없다. 또 둘 다 단말이거나 자식이 하나 있는 노드이므로 교체한 후에 그값이 있는 노드를 삭제하면 실제 삭제 효과를 얻을 수 있다. 그림 8.8 에서는 왼쪽 부분 트리의 가장 큰 값을 이용한다.",
      "section_number": "8.8",
      "section_heading": "자식이 둘이 있는 경우에는 그것을 직접 삭제하기가 불편하다. 따라서 그 노드의 키 값을 바꾸는 것을 생각해 볼 필요가 있다. 해당 노드의 왼쪽 부분 트리에서 가장 큰 값 또는 오른쪽 부분 트리에서 가장 작은 값이 해당 위치와 바꿀 수 있는 값이다. 현재 상황은 양쪽 모두 노드가 있는 경우이기 때문에 어느 쪽도 상관없다. 또 둘 다 단말이거나 자식이 하나 있는 노드이므로 교체한 후에 그값이 있는 노드를 삭제하면 실제 삭제 효과를 얻을 수 있다. 그림 8.8 에서는 왼쪽 부분 트리의 가장 큰 값을 이용한다.",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0110"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2 순회와 반복자 \n\n이진 검색 트리는 전위, 중위, 후위 순회 방법의 제공이 필요할 수 있다. 실제 후위 순위는 특별히 사용할 용도가 있지는 않다. 이들은 루트 노드를 접근하는 순서만 다르고 차이가 없다. 각 순회 방법의 의사코드는 그림 8.9와 같다. 각 순회 메소드는 root를 인자를 이용하여 호출해야 하며, 연산 내의 visitedOrder는 선형 리스트이며, 트리의 멤버 변수로 정의해 사용할 수 있고, 각 순회 연산을 호출할 때 인자로 전달할 수 있다. 멤버 변수로 사용할 경우에는 순회 연산자를 호출하기 전에 초기화하여 빈 상태로 만들어 주어야 한다. 각 순회는 각 노드를 정확하게 한번만 방문하기 때문에 각 순회의 시간 복잡도는 모두 O(n)이다. \n\n이진 검색 트리에 대한 반복자는 순회를 이용하여 구현할 수 있다. 보통 지금까지 반복자는 반복을 시작하는\n\n\n1 preorder(node):  2 visitedOrder.append(node.key)  3 if node.left != \\(\\bot\\) then preorder(node.left)  4 if node.right != \\(\\bot\\) then preorder(node.right)  5  6 inorder(node):  7 if node.left != \\(\\bot\\) then inorder(node.left)  8 visitedOrder.append(node.key)  9 if node.right != \\(\\bot\\) then inorder(node.right)  10  11 preorder(node):  12 if node.left != \\(\\bot\\) then postorder(node.left)  13 if node.right != \\(\\bot\\) then postorder(node.right)  14 visitedOrder.append(node.key) \n\n## <그림 8.9> 이진 검색 트리: 순회 메소드 \n\n시점에서 자료구조를 탐색하면서 값을 제공하는 형태이었다. 이 절에 제시된 순회를 이용할 경우에는 반복자를 만들기 전에 순회를 하여 선형 리스트에 키 값을 저장한 후에 반복은 이 리스트에 대한 반복을 하도록 할 수 있다. 이와 같은 반복자를 스냅샷(snapshot)을 이용한 반복자라 한다. 물론 이진 검색 트리에 대한 반복자는 스냅샷을 만들지 않고 제공할 수 있다.",
    "source": "ds08_3.2_이진 검색 트리의 구현-순회와 반복자",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: 순회와 반복자",
      "section_number": "3.2",
      "section_heading": "## 3.2 순회와 반복자",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0111"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2.1 next와 prev 연산 \n\n![](images/5_0.jpg)\n\n<center>(1) 노드 a의 후속 노드는? (2) 노드 a의 후속 노드는?</center> \n\n<center><그림 8.10> 노드의 후속 노드와 선행 노드</center> \n\n노드가 주어졌을 때 그것의 후속 노드를 찾아주는 연산이 next이고, 그것의 선행 노드를 찾아주는 연산이 prev 이다. 먼저 후속 노드를 찾아주는 연산을 생각하여 보자. 노드가 오른쪽 자식이 있으면 오른쪽 부분 트리에 있는 키 값은 항상 노드의 키 값보다 크다. 따라서 오른쪽 부분 트리에서 가장 작은 값이 주어진 노드의 후속 노드가 될 수 있다. 그림 8.10의 (1)에서 b는 a의 후속 노드가 될 수 있다. \n\n그러면 해당 노드의 조상 노드는 후속 노드가 될 수 없을까? 주어진 노드의 모든 조상 노드들이 왼쪽 조상이면 이 노드들은 주어진 노드보다 클 수가 없다. 그런데 조상 중에 오른쪽 조상이 있다면 이 노드는 주어진 노드보다 큰 값이다. 그림 8.10의 (1)에서 c는 a의 후속 노드가 될 수 있다. 하지만 해당 노드보다 조상 노드는 이 노드보다 더 크거나 작더라도 주어진 노드보다 값이 작은 노드이다. 그림 8.10의 (1)에서 e는 a보다 작은 노드이며, d는 c보다 더 크므로 a의 후속 노드가 될 수 없다. \n\n따라서 후속 노드가 될 수 있는 후보는 오른쪽 부분 트리에서 가장 작은 값이거나 조상 노드 중 첫 오른쪽 조상 노드이다. 그런데 두 후보가 모두 존재하면 오른쪽 부분 트리에서 가장 작은 값이 조상 노드 값보다 작기 때문에\n\n\n오른쪽 부분 트리가 있으면 무조건 후속 노드는 오른쪽 부분 트리에 있는 가장 작은 값이다. 그림 8.10의 (1)에서 \\(b < c\\)이므로 \\(b\\)가 \\(a\\)의 후속 노드임을 쉽게 알 수 있다. 이 논리는 선행 노드에도 동일하게 적용할 수 있다. 선행 노드의 경우에도 왼쪽 부분 트리가 있으면 해당 부분 트리에서 가장 큰 값이 무조건 선행 노드가 되며, 왼쪽 부분 트리가 없으면 첫 번째 만나는 왼쪽 조상 노드이다. \n\n1 next(key):  2 if isEmpty() then throw InvalidStateException  3 S := empty stack  4 node := findNode(key, root, S)  5 if node.key != key then throw InvalidArgumentException  6 nextNode := getNextNode(node, key, S)  7 return nextNode.key if nextNode!=⊥ else key  8  9 getNextNode(node, key, parents):  10 if node != ⊥ and node.right != ⊥ then  11 node := node.right  12 while node.left != ⊥ do  13 node = node.left  14 return node  15 else  16 while parents is not empty do  17 parent := parents.pop()  18 if parent.key > key then return parent  19 return ⊥ \n\n<그림 8.11> 이진 검색 트리: next 메소드 \n\n1 prev(key):  2 if isEmpty() then throw InvalidStateException  3 S := empty stack  4 node := findNode(key, root, S)  5 if node.key != key then throw InvalidArgumentException  6 prevNode := getPrevNode(node, key, S)  7 return prevNode.key if prevNode != ⊥ else key  8  9 getPrevNode(node, key, parents):  10 if node != ⊥ and node.left != ⊥ then  11 node := node.left  12 while node.right != ⊥ do  13 node = node.right  14 return node  15 else  16 while parents is not empty do  17 parent := parents.pop()  18 if parent.key < key then return parent  19 return ⊥ \n\n<그림 8.12> 이진 검색 트리: prev 메소드 \n\nnext와 prev 연산은 모두 먼저 주어진 키 값이 있는 경우에 그것의 선행 또는 후속 키 값을 찾아주는 연산이다. 따라서 주어진 키 값이 트리에 없는 경우에는 예외 처리를 해주어야 한다. 주어진 키 값이 있는 경우에는 키 값이 저장된 노드의 자식 부분 트리에서 해당 값을 찾을 수 없으면 조상 노드에 대한 탐색이 필요하다. 따라서 부모 링크를 유지하지 않을 경우 주어진 노드를 탐색할 때 삭제 연산처럼 스택에 부모 정보를 저장하여 활용해야 한다. 이 부분은 별도 모듈화하면 나중에 가장 가까운 이웃 찾기 연산을 구현할 때 활용할 수 있다. next와 prev의 의사코드는 각각 그림 8.11과 그림 8.12와 같다. 이 두 연산은 findNode 부분을 제외하면 재귀적 구조는 아니다. 이 연산에\n\n\n최댓값의 후속 요소를 찾으면 최댓값을 반환하고, 최솟값의 선행 요소를 찾으면 최솟값을 반환한다. 이 부분은 C++ 와 자바의 경우에는 std::optional이나 Optional을 이용할 수 있다. \n\n이 두 연산의 시간 복잡도를 생각하여 보자. 가정은 트리는 편향되어 있지 않고 균형 트리라 가정하자. 두 연산의 알고리즘은 같으므로 prev의 시간 복잡도를 검토하여 보자. 먼저 값을 찾아야 한다. 그다음 왼쪽 부분 트리의 가장 큰 값을 찾아야 한다. 이전 값을 찾는 것과 왼쪽 부분 트리의 가장 큰 값을 찾는 것은 트리 높이만큼의 비용이 소요 된다. 이때 왼쪽 부분 트리가 없는 경우에는 다시 최악의 경우 루트 노드까지 검사해야 한다. 따라서 트리 높이의 2 배 정도의 비용이 소요되므로 전체 비용은 트리가 균형이면 O(log n)이다.",
    "source": "ds08_2.1_이진 검색 트리의 구현-.1 next와 prev 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: .1 next와 prev 연산",
      "section_number": "2.1",
      "section_heading": "## 3.2.1 next와 prev 연산",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [
        "ds08/images/5_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0112"
  },
  {
    "type": "텍스트북",
    "text": "3.2.2 범위 검색 연산 \n\n1. rangeSearch(node, low, high, ret):  2. if node.left != 1 and node.left>=low then  3. rangeSearch(node.left, low, high, ret)  4. if node.key >= low and node.key <= high then ret.append(node.key)  5. if node.right != 1 and node.right >= high then  6. rangeSearch(node.right, low, high, ret) \n\n<그림 8.13> 이진 검색 트리: 범위 검색 메소드 \n\n범위 검색을 구현하는 방법은 다양하다. 몇 가지 검토해 보면 다음과 같다. 이때 찾고자 하는 범위는 low에서 high 사이이다. \n\n• 방법 1. low에 해당하는 값을 찾은 다음 해당 노드부터 차례로 next 연산을 호출하여 high까지 찾아간다. \n\n• 방법 2. inorder로 방문하면서 배열을 확보한 후에 정렬 배열에서 범위 검색을 한다. \n\n• 방법 3. inorder로 방문하면서 범위 시작부터 반환할 리스트에 키 값을 포함하고, 범위가 끝나면 순회를 중단한다. \n\n각 방법의 시간 복잡도를 검토해 보자. 방법 1에서 첫 번째 탐색 비용은 O(log n)이며, next 연산의 시간 복잡도는 O(log n)이므로 범위 내에 있는 값이 k이면 전체 비용은 O(k log n)이다. 그런데 이 방법을 실제 구현하기 위해서는 기존 next 연산을 그대로 사용할 수 없다. 기존 next 연산은 현재 무조건 루트 노드부터 다시 해당 값을 찾은 후에 후속 요소를 찾는다. 방법 2에서 inorder 탐색 비용은 O(n)이며, 이진 탐색으로 범위의 시작 값을 찾은 후 선형 접근해야 하므로 전체 비용은 O(n + log n + k)이다. 이 방법은 추가 공간의 사용도 필요하다. 방법 3은 inorder만으로 결과를 얻을 수 있으므로 전체 비용은 O(n)이다. 방법 3을 이용한 범위 검색 연산의 의사코드는 그림 8.13과 같다.",
    "source": "ds08_2.2_이진 검색 트리의 구현-3.2.2 범위 검색 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: 3.2.2 범위 검색 연산",
      "section_number": "2.2",
      "section_heading": "3.2.2 범위 검색 연산",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0113"
  },
  {
    "type": "텍스트북",
    "text": "3.2.3 가장 가까운 이웃 찾기 \n\n가장 가까운 이웃 찾기도 inorder로 방문하면서 배열을 확보한 후에 정렬 배열에서 가장 가까운 이웃을 찾을 수 있다. 이 경우에 트리가 균형이면 시간 복잡도는 O(n + log n)이다. 하지만 트리가 균형일 때 getPrevNode 와 getNextNode 연산을 호출하여 결과를 주면 시간 복잡도는 O(log n)이다. 이때 선행 또는 후속 요소가 없는 경우에는 어떤 값을 반환해 주어야 할까? 마땅한 값을 반환하여 해당 요소가 없다는 것을 효과적으로 알리는 것은 쉽지 않다. 더욱이 키 값의 타입이 정수가 아닐 수도 있다. 하지만 C++와 자바는 각각 std::optional과 Optional을 활용하면 쉽게 처리할 수 있다. 가장 가까운 이웃 찾기 연산의 의사코드는 그림 8.14와 같다. 이 연산 역시 findNode 부분을 제외하면 재귀적 구조는 아니다. 또 findNode는 삽입할 위치를 찾을 때도 활용하기 위해\n\n\n1 nearestNeighbor(key):  2 if isEmpty() then throw InvalidStateException  3 SP := empty stack  4 node := findNode(root, key, SP)  5 if node.key != key then  6 S.push(node)  7 node := ⊥  8 SN := clone SP  9 prevNode := getPrevNode(node, key, SP)  10 nextNode := getNextNode(node, key, SN)  11 ret.prev := if prevNode != ⊥ then prevNode.key else ⊥  12 ret.next := if nextNode != ⊥ then nextNode.key else ⊥  13 return ret \n\n<그림 8.14> 이진 검색 트리: 가장 가까운 이웃 찾기 \n\n찾는 키 값이 없으면 해당 키를 삽입할 단말 노드를 찾아주고 있으므로 찾는 키가 없는 경우에는 해당 노드를 스택에 추가하고 넘포인터로 만들어 getPrevNode와 getNextNode 연산을 호출해야 한다.",
    "source": "ds08_2.3_이진 검색 트리의 구현-3.2.3 가장 가까운 이웃 찾기",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: 3.2.3 가장 가까운 이웃 찾기",
      "section_number": "2.3",
      "section_heading": "3.2.3 가장 가까운 이웃 찾기",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0114"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2.4 균형 맞추기 \n\n지금까지 살펴본 각종 연산의 시간 복잡도를 분석할 때 트리가 균형이라고 가정하고 분석하였다. 하지만 이진 검색 트리는 키 값을 삽입하는 순서에 따라 매우 편향된 트리가 될 수 있다. 이렇게 되면 이진 검색 트리를 사용할 이유가 전혀 없어진다. 실제 이 때문에 자료구조에서 사용하는 이진 검색 트리는 9장에서 살펴볼 균형 이진 검색 트리이다. 균형 이진 검색 트리는 삽입과 삭제를 할 때마다 자동으로 트리의 균형을 유지해 준다. \n\n1 balanceTree():  2 visitedOrder.clear()  3 inorder(root)  4 clear()  5 balanceTree(1, n)  6  7 balanceTree(low, high)  8 if low == high then add(visitedOrder[low])  9 else if low < high then  10 mid := low + (high-low)/2  11 add(visitedOrder[mid])  12 balanceTree(low, mid-1)  13 balanceTree(mid+1, high) \n\n<그림 8.15> 이진 검색 트리: 가장 가까운 이웃 찾기 \n\n그러면 균형 이진 검색 트리가 아닐 경우 트리의 균형을 어떻게 맞출 수 있을까? 트리에 있는 모든 값을 확보한 다음에 이 값을 특정 순서로 삽입하여 균형 트리를 만들 수는 없을까? 트리에 있는 모든 값은 순회를 통해 얻을 수 있다. 전위 순회 방법으로 얻은 후에 이 순서로 삽입하면 트리의 모습은 하나도 변하지 않는다. 또 다른 순회 방법을 사용하여 얻은 후에 그 순서로 삽입하여도 균형 트리를 얻을 수 없다. 하지만 중위 순회 방법을 이용하여 오름차순으로 정렬된 데이터를 얻을 수 있다. 이때 트리가 균형이 되기 위해서는 정렬되었을 때 중간값이 루트값이 되어야 한다. 이것은 왼쪽, 오른쪽 부분 트리에 삽입되어야 하는 노드의 수가 차이가 없을 수록 균형 트리를 만들 수 있기 때문이다. 이 개념은 반복적으로 적용할 수 있다. 중간값을 삽입한 후에 왼쪽과 오른쪽의 중간값을 그 다음에 추가해야 그 아래 양쪽 부분 트리 높이의 차이를 최소화할 수 있다. 이를 이용한 균형 맞추기 연산의 의사코드는 그림 8.15와 같다.\n\n\n앞서 언급한 바와 같이 이 장에서 살펴본 이진 검색 트리를 실제 활용하지는 않는다. 하지만 활용한다면 삽입과 삭제할 때마다 트리의 균형을 다시 맞추는 것보다 삽입과 삭제할 때마다 높이를 검사하고 최적 높이에 비해 그 차이가 정해진 수준 이상이 되면 균형 맞추기를 하는 것이 효과적일 것이다.",
    "source": "ds08_2.4_이진 검색 트리의 구현-.4 균형 맞추기",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: .4 균형 맞추기",
      "section_number": "2.4",
      "section_heading": "## 3.2.4 균형 맞추기",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0115"
  },
  {
    "type": "텍스트북",
    "text": "## 3.3 비재귀적 구현 \n\n트리 관련 연산을 비재귀적으로 구현하는 것은 간단하지 않다. 물론 트리의 전체 노드를 탐색해야 하는 것이 아니면 반복문을 이용하여 어렵지 않게 구현할 수 있다. 또 단순히 트리의 전체 노드를 탐색해야 하는 것이면 DFS나 BFS 를 이용하여 구현할 수 있다. 재귀적으로 구현하였던 각 연산을 하나씩 비재귀적으로 바꾸어 보자. \n\n1 height(node):  2 if isEmpty() then return -1  3 Q := empty queue of (TreeNode, height)  4 Q.push(root, 0)  5 maxHeight := 0  6 while Q is not empty do  7 node, height := Q.pop()  8 maxHeight := max(maxHeight, height)  9 if node.right != - then Q.push(node.right, height+1)  10 if node.left != - then Q.push(node.left, height+1)  11 return maxHeight \n\n<그림 8.16> 이진 검색 트리: height 메소드 (비재귀적 버전) \n\n노드의 수는 전체 노드를 단순 탐색하면 된다. 따라서 BFS를 이용하여 간단하게 비재귀적으로 구현할 수 있다. 트리의 높이도 BFS나 DFS를 이용하여 구현할 수 있다. 노드의 수는 BFS나 DFS를 수행하면서 방문한 노드의 수를 카운트하면 되지만 트리의 높이는 방문한 노드의 높이를 계속 계산해야 한다. 이를 위해 그림 8.16처럼 큐에 노드를 push할 때 노드와 노드의 높이를 함께 push할 수 있고, 해시맵 같은 것을 이용하여 노드의 높이를 계속 저장할 수 있다. 실제 여기서 push하는 값은 노드의 높이가 아니라 깊이이다. 가장 깊이 있는 단말 노드의 깊이가 트리의 높이가 된다. \n\n1 findNode(node, key):  2 while node != - do  3 if node.key==key then return node  4 nextNode := if node.key then node.left else node.right  5 if nextNode != - then node := nextNode  6 else break  7 return node \n\n<그림 8.17> 이진 검색 트리: findNode 메소드 (비재귀적 버전) \n\n기존 재귀적 구현에서 add와 remove는 각각 삽입할 위치와 삭제할 노드를 찾기 위해 findNode를 이용하고 있고, 해당 부분만 재귀적으로 구성되어 있다. findNode는 루트부터 한 경로를 따라 단말까지 이동하는 것이므로 단순 반복문을 이용해 쉽게 비재귀적으로 구현할 수 있다. 따라서 findNode만 그림 8.17과 같이 비재귀적으로 바꾸면 두 연산도 비재귀적 구현으로 바뀌게 된다. \n\n3가지 순회 방법을 비재귀적으로 구현하는 것은 간단하지 않다. 전위 방법은 DFS와 순회 방법이 같기 때문에 비교적 쉽게 구현할 수 있다. 이때 주의할 것은 노드를 처리할 때 왼쪽 자식을 먼저 push하지 않고 오른쪽 자식을 먼저 push해야 루트, 왼쪽, 오른쪽 순으로 올바르게 처리가 된다. \n\n중위 순회는 왼쪽, 루트, 오른쪽 순서이기 때문에 스택을 이용한 DFS를 조금 수정해야 한다. 왼쪽부터 처리하기\n\n\n1 inorder(node):  2 S := empty stack of TreeNode  3 while true do  4 while node != ⊥ do  5 S.push(node)  6 node := node.left  7 if S is empty then break  8 else  9 curr := S.pop()  10 visitedOrder.append(curr.key)  11 node := curr.right \n\n<그림 8.18> 이진 검색 트리: inorder 메소드 (비재귀적 버전) \n\n위해서는 왼쪽 자식이 있으면 계속 왼쪽으로 먼저 이동해야 한다. 이를 위해 왼쪽 자식이 있으면 계속 처리를 미루고 스택에 push해야 한다. 더 이상 왼쪽 자식이 없으면 이때부터 스택에서 pop하여 처리하면 된다. 그다음이 약간 혼란스럽다. 그것의 부모를 처리하고 오른쪽으로 이동해야 할 것으로 생각할 수 있는데, 가장 왼쪽 노드는 그 노드를 루트가 되는 부분 트리의 루트이다. 따라서 이 노드를 처리한 다음에는 이 노드의 오른쪽 노드를 처리해야 순서가 맞다. 이 노드부터는 다시 원래 과정을 반복하면 왼쪽, 루트, 오른쪽 순으로 방문하게 된다. 중위 순회의 비재귀적 구현의 의사코드는 그림 8.18과 같다. \n\n1 postorder(node):  2 S := empty stack of TreeNode  3 while true do  4 while node != ⊥ do  5 if node.right != ⊥ then S.push(node.right)  6 S.push(node)  7 node := node.left  8 if S is empty then break  9 else  10 curr := S.pop()  11 if S is not empty and curr.right != ⊥ and curr.right==S.top() then  12 S.pop()  13 S.push(curr)  14 node = curr.right  15 else  16 visitedOrder.append(curr.key)  17 node := ⊥ \n\n<그림 8.19> 이진 검색 트리: postorder 메소드 (비재귀적 버전) \n\n후위 순회는 더 복잡하다. 왼쪽, 오른쪽, 루트 순서이므로 중위 순회를 조금 응용하면 구현할 수 있다. 중위 순 위와 마찬가지로 왼쪽을 먼저 처리해야 하므로 그 부분은 차이가 없다. 다만, 루트 대신에 오른쪽을 먼저 처리해야 한다. 이 때문에 중위에서 왼쪽으로 계속 내려갈 때 반대쪽을 스택에 push하여 왼쪽 다음에 바로 처리할 수 있도록 해야 한다. 그다음 더 이상 왼쪽으로 갈 수 없지만 오른쪽 자식이 있으면 이 노드를 처리하지 않고 오른쪽으로 먼저 이동하여야 한다. 이를 위해 pop한 노드가 오른쪽 자식이 있는지 살펴보아야 한다. 그런데 이 해당 자식은 내려오면서 미리 스택에 push하였기 때문에 이를 스택에서 제거하고 현재 노드를 스택에 push하여 오른쪽 노드를 루트보다 먼저 처리하도록 해야 한다. 후위 순회의 비재귀적 구현의 의사코드는 그림 8.19와 같다.",
    "source": "ds08_3.3_이진 검색 트리의 구현-비재귀적 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: 비재귀적 구현",
      "section_number": "3.3",
      "section_heading": "## 3.3 비재귀적 구현",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0116"
  },
  {
    "type": "텍스트북",
    "text": "## 3.4 부모 링크를 유지하는 구현 \n\n이진 검색 트리를 구현할 때 노드에 부모 링크를 유지할 수 있다. 부모 링크를 유지하면 삭제 연산, next, prev 등에서 스택을 통해 조상 노드 목록 만들 필요가 없다. 부모 링크를 유지하기 위해서는 키 값을 삽입할 때 부모 링크를 연결해 주어야 하고, 노드를 삭제할 때 부모 링크를 갱신해 주어야 한다. \n\n각 연산에 대해 구체적으로 어떤 수정이 필요한지 살펴보자. add 연산은 새 노드를 추가할 때 기존 단말 노드의 자식 노드로 추가한다. 이때 간단하게 새로 추가한 노드의 부모 링크를 설정만 해주면 된다. remove 연산은 궁극 에는 단말 또는 자식이 하나 있는 노드만 삭제하므로 removeSingleChild 메소드에서 자식이 하나 있는 노드의 경우 삭제할 노드의 자식 노드의 부모 링크를 갱신해주면 된다. \n\n1 next(key):  2 if isEmpty() then throw InvalidStateException  3 node := findNode(key, root)  4 if node.key != key then throw InvalidArgumentException  5 nextNode := getNextNode(node, key)  6 return nextNode.key if nextNode != ⊥ else key  7  8 getNextNode(node, key, parents):  9 if node.right != ⊥ then  10 node := node.right  11 while node.left != ⊥ do  12 node = node.left  13 return node  14 else  15 node := node.parent  16 while node != ⊥ do  17 if node.key>key then return node  18 node := node.parent  19 return ⊥ \n\n<그림 8.20> 이진 검색 트리: next 메소드 (부모 링크 유지 버전) \n\nnext와 prev는 스택을 이용하여 조상 노드 목록을 구하고 이를 이용하여 필요하면 루트 노드까지 올라가면서 선행 또는 후속 노드를 찾게 된다. 부모 링크를 유지하면 이것이 필요 없고 필요할 때 부모 링크를 유지하면 된다. 수정된 next 연산은 그림 8.20과 같다. 가장 가까운 이웃 찾기 연산도 노드에 유지하고 있는 부모 링크를 사용하도록 비슷하게 수정되어야 한다.",
    "source": "ds08_3.4_이진 검색 트리의 구현-부모 링크를 유지하는 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "이진 검색 트리의 구현: 부모 링크를 유지하는 구현",
      "section_number": "3.4",
      "section_heading": "## 3.4 부모 링크를 유지하는 구현",
      "parent_section": "3. 이진 검색 트리의 구현",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0117"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 선택 문제와 순위 문제 \n\n선택(selection) 문제란 k번째 요소를 찾는 문제를 말하며, 순위(rank) 문제란 주어진 요소가 몇 번째 요소인지 알 아내는 문제이다. 기본적으로 이진 검색 트리는 두 연산을 효과적으로 제공할 수 없다. 물론 중위 순위로 정렬된 데이터를 확보할 수 있으므로 두 연산 모두 O(n) 비용으로는 제공할 수 있다. 하지만 이진 검색 트리이고, 트리가 균형이면 이들 연산도 O(log n)에 제공할 수 있을 것으로 생각할 수 있다. 실제 각 노드가 그 노드가 루트가 되는 부분 트리의 크기를 유지하면 두 연산을 O(log n)에 제공할 수 있다. 하지만 이를 위해서는 노드 구조체에 크기 정 보가 추가되어야 하며, 삽입과 삭제에 따라 각 노드가 유지하는 크기 정보를 갱신해 주어야 한다. 그런데 이 갱신은 그렇게 복잡한 것은 아니다. 삽입은 항상 단말에 삽입되므로 그 노드부터 루트 노드까지 올라가면서 해당 노드들만 갱신하면 되며, 삭제의 경우도 삭제된 노드의 부모 노드부터 루트 노드까지 올라가면서 해당 노드들만 갱신하면 된다.",
    "source": "ds08_4_선택 문제와 순위 문제",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "[1, 4, 6, 7, 10, 13, 15]가 자료구조에 저장되어 있다고 가정하자. 이 자료구조에서 다음과 같은 두 가지 연산을 수행하고 싶다.",
      "section": "선택 문제와 순위 문제",
      "section_number": "4",
      "section_heading": "## 4. 선택 문제와 순위 문제",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0118"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 균형 이진 검색 트리 \n\n8장에서 살펴본 이진 검색 트리는 트리가 균형인 경우에 각종 연산을 \\(O(\\log n)\\)에 제공할 수 있다는 조건이 붙어 있다. 하지만 일반 이진 검색 트리는 데이터를 삽입하는 순서에 의해 트리 모습이 결정되며, 매우 편향될 수 있다. 물론 편향된 트리는 \\(O(n \\log n)\\)에 다시 균형을 맞출 수 있지만 이렇게 사용하는 것은 효과적이지 않다. 삽입과 삭제 할 때마다 시간 복잡도를 바꾸지 않고 계속 트리의 균형을 유지할 수 있으면 가장 최선일 것이다. 균형 이진 검색 트리(self balancing BST)는 항상 균형을 유지해 주는 이진 검색 트리이며, 삽입과 삭제 비용은 여전히 \\(O(\\log n)\\)인 트리이다. 한 종류의 균형 이진 검색 트리만 있는 것은 아니다. 이 장에서는 AVL 트리와 빨간-검정 트리에 대해 살펴본다.",
    "source": "ds09_1_균형 이진 검색 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "균형 이진 검색 트리",
      "section_number": "1",
      "section_heading": "## 1. 균형 이진 검색 트리",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0119"
  },
  {
    "type": "텍스트북",
    "text": "## 2. AVL 트리 \n\nAVL 트리는 Adelson-Velsky와 Landis가 고안한 균형 이진 검색 트리이다. 트리의 균형을 유지하기 위해서는 트리의 균형을 우선 측정할 수 있어야 한다. 7장에서 살펴본 것처럼 트리의 균형은 왼쪽과 오른쪽 부분 트리 높이의 차이를 이용하여 측정한다. 이것이 1이하이면 균형 트리라 한다. AVL 트리에서는 이 특성을 AVL 특성이라 한다. 특히, 이진 검색 트리에서 모든 노드가 AVL 특성을 만족하면 트리 높이가 \\(O(\\log n)\\)이다. 이것은 다음 정리를 이용하여 증명할 수 있다. \n\n**정리 9.1.** 이진 검색 트리에서 AVL 특성을 만족하는 노드의 높이가 \\(h\\)이면 이 노드가 루트가 되는 부분 트리 크기는 최소 피보나치 수 \\(F_{h+1}\\)보다 같거나 크다. \n\n여기서 크다는 것은 노드가 해당 값보다 많다는 것을 의미한다. 참고로 \\(k \\le 6\\)이면 \\(F_k \\le 2^{k/2}\\)이다. 따라서 노드의 수가 \\(n\\)일 때, 다음이 성립하면 \n\n\\[n \\ge F_{h+1} \\ge 2^{\\frac{h+1}{2}}\\]\n\n\\(h \\le 2 \\log n - 1\\)이므로 트리의 높이는 \\(O(\\log n)\\)이다. \n\n**증명** 귀납법으로 증명한다. \n\n- 귀납출발. \\(h = 0\\)이면 부분 트리의 크기가 1이며 \\(F_2 = 1\\)이므로 \\(n \\ge F_2\\)가 성립한다. \n\n- 귀납가정. AVL 특성을 만족하는 노드 \\(a\\)의 높이가 \\(h\\)보다 작으면 정리가 성립한다고 가정하자. \n\n- 귀납단계. AVL 특성을 만족하는 노드 \\(a\\)의 높이가 \\(h\\)이면 두 자식의 부분 트리 중 하나는 \\(h-1\\)이고, 다른 쪽은 최소 \\(h-2\\)이다. 귀납 가정에 의해 높이가 \\(h-1\\)인 부분 트리의 크기는 \\(F_h\\)보다 같거나 크고, 다른 쪽은 최소\n\n\n\\(F_{h-1}\\)보다 같거나 크다. 노드의 크기는 \\(N(a) = N(L) + N(R) + 1\\)이므로 귀납 가정에 의해 다음이 성립한다. \n\n\\[N(a) \\ge F_h + F_{h-1} + 1 = F_{h+1} + 1\\]\n\n따라서 \\(N(a) \\ge F_{h+1}\\)이 성립한다. \n\n이 정리는 위와 같이 피보나치 수를 이용하여 증명할 수 있고 다음과 같이 증명할 수 있다. \\(N_h\\)가 높이가 \\(h\\)인 트리의 크기라 가정하면 \\(N_h \\ge 1 + N_{h-1} + N_{h-2}\\)이며, 여기에 \\(N_{h-1} \\ge 1 + N_{h-2} + N_{h-3}\\)을 적용하면 다음이 성립한다는 것을 알 수 있다. \n\n\\[N_h \\ge 1 + 2N_{h-2} + N_{h-3} + 2 \\ge 2N_{h-2}\\]\n\n이것을 반복적으로 적용하면 다음이 성립한다는 것을 알 수 있다. \n\n\\[N_h \\ge 2N_{h-2} \\ge 2^2N_{h-4} \\ge 2^3N_{h-6} \\ge \\cdots \\ge 2^{\\frac{h}{2}}N_0 \\ge 2^{\\frac{h}{2}}\\]\n\n따라서 \\(h < 2\\log N_h\\)이다. \n\n트리의 값을 삽입하거나 삭제하면 트리의 균형이 깨질 수 있지만 균형 이진 검색 트리는 트리가 다시 균형을 찾도록 조정을 하며, 조정하는 비용도 \\(O(\\log n)\\)이다. 즉, 트리를 전체적으로 재구성하는 방법을 사용하지 않는다. 이를 위해 각 노드에서 그 노드가 루트가 되는 부분 트리의 균형을 측정할 수 있어야 한다. 이 측정을 위해 각 노드마다 트리의 높이를 유지하거나 트리의 균형 인자를 유지한다. 이 교재에서는 트리의 높이를 유지하는 형태로 AVL 트리를 구현한다. 또 AVL 트리는 삽입 후 트리의 균형을 조정하기 위해 해당 노드부터 루트 노드까지 올라가면서 조정을 한다. 따라서 부모 링크를 유지하는 형태로 구현하는 것이 효과적이다. 이에 AVL 트리에서 트리 노드 구조체는 그림 9.1과 같다. \n\n1. AVLNode: \n\n2. key: key type \n\n3. parent: address of TreeNode \n\n4. left: address of TreeNode \n\n5. right: address of TreeNode \n\n6. height: integral type \n\n<그림 9.1> AVL 트리 노드 구조체",
    "source": "ds09_2_AVL 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "AVL 트리",
      "section_number": "2",
      "section_heading": "## 2. AVL 트리",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0120"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1 삽입과 삭제 연산 \n\n트리의 균형은 노드가 추가되거나 삭제되면 바뀔 수 있다. 그런데 노드가 추가 또는 삭제되면 해당 노드의 부모 노드부터 루트 노드까지 경로에 있는 노드이 높이 정보만 바뀐다. 나머지는 그림 9.2에서 알 수 있듯이 그대로 유지된다. 노드가 추가 또는 삭제되기 전에 트리가 균형을 유지하고 있었다면 그 이전과 비교하여 최대 2까지 차이가 발생할 수 있다. \n\nAVL 트리에서 삽입은 일반 이진 검색 트리에서 삽입과 동일하게 진행한다. 그다음 삽입된 노드의 부모 노드부터 루트 노드까지 올라가면서 높이 정보를 갱신한다. 이 갱신은 그림 9.3에 제시된 의사코드를 통해 할 수 있다. 각 노드는 해당 노드가 루트가 되는 부분 트리의 높이 정보를 유지하고 있으므로 그것을 이용하여 높이를 조정한다. \n\n이 과정에서 균형이 깨진 노드를 발견하면 트리를 재구성하여 균형 성질을 복원한다. 이와 같은 조정은 한번만 일어나는 것은 아니며 루트 노드까지 올라가면서 여러 번 일어날 수 있다. 하지만 삽입 이전에 트리 높이가 \\(O(\\log n)\\)\n\n![](images/2_0.jpg)\n\n<ấp 9.2> 이진 검색 트리에서 노드의 추가에 따른 높이의 변화 \n\n1 adjustHeight(node):  2 leftHeight := node.left.height if node.left != _ else -1  3 rightHeight := node.right.height if node.right != _ else -1  4 node.height := 1 + max(leftHeight, rightHeight) \n\n## <그림 9.3> AVL 트리: adjustHeight 메소드 \n\n이므로 조정은 최대 O(log n)번으로 제한된다. 이 과정의 의사코드는 그림 9.4와 같다. 트리가 조정되면 노드의 부 모가 변경될 수 있으므로 먼저 부모 노드를 확보한다 다음 트리를 조정하고, 미리 확보한 부모 노드를 이용하여 계속 루트 노드까지 조정이 필요한지 검사하면서 조정을 진행해야 한다. 그림 9.4의 의사코드에서는 꼬리 재귀 형태로 루트 노드까지 반복하도록 구현하고 있다. \n\n균형이 깨진 노드를 조정하여 복원하는 기본 방법은 왼쪽 회전과 오른쪽 회전이다. 그림 9.5처럼 노드를 기준으로 균형 인자가 +2이면 왼쪽 회전을 해야 하고, -2이면 오른쪽 회전을 해야 한다. 왼쪽 회전이란 회전의 중심이 되는 노드를 왼쪽으로 내리고 중심이 된 노드의 오른쪽 자식을 위로 올리는 것을 말하며, 오른쪽 회전이란 회전의 중심이 되는 노드를 오른쪽으로 내리고 중심이 된 노드의 왼쪽 자식을 위로 올리는 것을 말한다. \n\n왼쪽, 오른쪽 회전을 하기 위해 해야 할 일은 그림 9.6을 통해 설명하면 다음과 같다. 해당 그림에서 부분 트리 T1 부터 T3에 있는 노드의 높이는 하나도 변하지 않는다. 회전을 통해 노드의 높이가 바뀔 수 있는 노드는 A와 B 뿐이 다. 왼쪽 회전과 오른쪽 회전의 의사코드는 각각 그림 9.7의 (1)과 (2)와 같다. 특별한 것은 없고 그림 ??을 참고하여 필요한 연결 정보들을 갱신하면 된다. 이때 루트가 변경될 수 있으므로 주의해야 하며, T2는 부모가 변경되는데 T2 가 없을 수 있다는 점도 주의해야 한다. 또 회전을 한 다음에는 영향을 받은 A와 B 노드의 높이를 갱신해 주어야 한다. 이때 갱신하는 순서도 주의해야 한다. 각 회전의 비용은 상수 비용으로 일정하다. \n\n그런데 단일 왼쪽 회전과 단일 오른쪽 회전을 통해 모든 균형을 바로 잡을 수 없다. 특별한 두 가지 경우에는 이중 회전이 필요하다. 왼쪽 회전을 해야 할 때 그림 9.8처럼 오른쪽 부분 트리의 왼쪽 부분 트리가 더 깊으면 단일 왼쪽 회전을 하면 안 되고 그림 9.9처럼 오른쪽 부분 트리를 먼저 오른쪽 회전을 한 후에 왼쪽 회전을 해야 한다. 같은 원리로 오른쪽 회전을 해야 할 때 그림 9.10처럼 왼쪽 부분 트리의 오른쪽 부분 트리가 더 깊으면 단일 왼쪽 회전을 하면 안 되고 그림 9.11처럼 오른쪽 부분 트리를 먼저 왼쪽 회전을 한 후에 오른쪽 회전을 해야 한다. 이중 회전을 고려한 rebalanceLeft와 rebalanceRight의 의사코드는 각각 그림 9.12과 그림 9.13와 같다. 이중 회전을 하더라도 일정한 비용만 소요되므로 시간 복잡도에는 영향이 없다. 전체 비용은 트리 높이에 비례한다. \n\n삭제의 경우에는 실제 삭제가 일어나는 곳은 removeSingleChild이다. 여기서 삭제된 노드의 부모 노드부터 재조정을 시작하여 루트 노드까지 올라가면서 조정을 하면 된다.\n\n\n1 rebalance(node):  2 if node == \\_ then return  3 parent := node.parent  4 leftHeight := node.left.height if node.left != \\_ else -1  5 rightHeight := node.right.height if node.right != \\_ else -1  6 if abs(rightHeight-leftHeight) == 2 then  7 if leftHeight > rightHeight then rebalanceRight(node)  8 else rebalanceLeft(node)  9 adjustHeight(node)  10 rebalance(parent) \n\n## <그림 9.4> AVL 트리: rebalance 메소드",
    "source": "ds09_2.1_AVL 트리-삽입과 삭제 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "AVL 트리: 삽입과 삭제 연산",
      "section_number": "2.1",
      "section_heading": "## 2.1 삽입과 삭제 연산",
      "parent_section": "2. AVL 트리",
      "parent_section_number": "2",
      "images": [
        "ds09/images/2_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0121"
  },
  {
    "type": "텍스트북",
    "text": "## 2.2 합병과 분할 \n\n두개의 AVL 트리를하나의 AVL 트리로합치거나하나의 AVL 트리를두개의 AVL 트리로분할수있다. 문제는 단순하게합치거나분리하면결과트리의균형이깨질수있다. 이절에서는서로중첩되지않은두AVL: 트리의 합병에대해서만살펴본다. 참고로일반정렬리스트의합병은합병정렬에서합병연산을이용하여할수있으므로 O(n)에할수있다. 더욱이두리스트가중첩되어있지않으면더쉽게합병할수있다. \n\nAVL 트리 T1과 T2가 서로 중첩되어 있지 않을 때 합병하는 방법을 생각하여 보자. 중첩되어 있지 않다는 것은 T1의 모든 키가 T2의 가장 작은 값보다 작거나 T1의 모든 키가 T2의 가장 큰 값보다 큰 경우를 말한다. 전자를 가정하여 합병하는 방법을 생각하여 보면 다음 3가지 방법을 직관적으로 생각해 볼 수 있다. \n\n• 방법 1. T2에서 가장 작은 값의 자식으로 T1을 추가한다. \n\n• 방법 2. T1에서 가장 큰 값의 자식으로 T2를 추가한다. \n\n• 방법 3. 노드를 하나 추출하여 합병 트리의 루트 노드로 사용한다. \n\n방법 3을 사용할 경우 새 루트 노드가 될 수 있는 노드는 T1의 가장 큰 노드 또는 T2의 가장 작은 노드이다. 3 방법 중 방법 3이 트리 균형에 가장 적게 영향을 주게 된다. 하지만 T1과 T2의 높이 차이가 크면 이와 같은 합병을 통해 균형을 유지할 수는 없다. 이 경우 루트와 결합하는 것이 아니라 중간 노드와 방법 3을 이용하여 결합하는 방법을 통해 균형을 유지할 수 있다. 그림 9.14처럼 T1의 높이가 T2보다 크면 T1의 루트에서 오른쪽으로 내려 오면서 T2와 같은 크기의 부분 트리를 찾는다. 그다음 해당 부분 트리와 방법 3을 이용하여 결합하면 트리의 균형을 유지할 수 있다. 그림 9.14에서는 15가 루트 노드가 되는 부분 트리가 결합하고자 하는 트리의 높이와 같기 때문에 해당 부분 트리를 이용하여 결합하고 있다.",
    "source": "ds09_2.2_AVL 트리-합병과 분할",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "AVL 트리: 합병과 분할",
      "section_number": "2.2",
      "section_heading": "## 2.2 합병과 분할",
      "parent_section": "2. AVL 트리",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0122"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 빨간 검정 트리 \n\n빨간 검정(red-black) 트리도 AVL처럼 항상 균형을 유지하는 균형 이진 검색 트리이다. 이 트리의 각 노드는 빨간 또는 검정 노드이어야 한다. 빨간-검정 트리의 요구사항은 다음과 같다. \n\n• 요구사항 1. 각 노드는 빨간 또는 검정 노드이어야 한다. \n\n• 요구사항 2. 루트 노드는 항상 검정 노드이어야 한다. \n\n• 요구사항 3. 두 개가 연속 빨간 노드일 수 없다. 노드가 빨간 노드이면 그것의 자식은 빨간 노드일 수 없다.\n\n![](images/4_0.jpg)\n\n \n\n<center>(1) 왼쪽 회전</center> \n\n<center>(2) 오른쪽 회전</center> \n\n<center><그림 9.5> 왼쪽과 오른쪽 회전 예</center> \n\n![](images/4_1.jpg)\n\n \n\n<center><그림 9.6> AVL 단일 회전</center> \n\n1 rotateLeft(B):\n2 P := B.parent\n3 A := B.right\n4 \\(T_2\\) := A.left\n5 if P == \\(\\bot\\) then root := A\n6 else if P.key > A.key\n7 then P.left := A\n8 else P.right := A\n9 A.parent := P\n10 A.left := B\n11 B.right := \\(T_2\\)\n12 if \\(T_2\\) != \\(\\bot\\)\n13 then \\(T_2\\).parent := B\n14 B.parent := A\n15 adjustHeight(B)\n16 adjustHeight(B.parent) \n\n1 rotateRight(A):\n2 P := A.parent\n3 B := A.left\n4 \\(T_2\\) := B.right\n5 if P == \\(\\bot\\) then root := B\n6 else if P.key > B.key\n7 then P.left := B\n8 else P.right := B\n9 B.parent := P\n10 B.right := A\n11 A.left := \\(T_2\\)\n12 if \\(T_2\\) != \\(\\bot\\)\n13 then \\(T_2\\).parent := A\n14 A.parent := B\n15 adjustHeight(A)\n16 adjustHeight(A.parent) \n\n<center>(1) 단일 왼쪽 회전</center> \n\n<center>(2) 단일 오른쪽 회전</center> \n\n<center><그림 9.7> AVL 왼쪽, 오른쪽 단일 회전</center>\n\n![](images/5_0.jpg)\n\n<center><그림 9.8> AVL 단일 왼쪽 회전을 하면 안 되는 경우</center> \n\n![](images/5_1.jpg)\n\n<center><그림 9.9> AVL 이중 왼쪽 회전</center> \n\n![](images/5_2.jpg)\n\n<center><그림 9.10> AVL 단일 오른쪽 회전을 하면 안 되는 경우</center>\n\n![](images/6_0.jpg)\n\n<center><그림 9.11> AVL 이중 오른쪽 회전</center> \n\n1 rebalanceLeft(node):  2 rightChild := node.right  3 if rightChild != _ then  4 leftHeight := rightChild.left.height if rightChild.left != _ else -1  5 rightHeight := rightChild.right.height if rightChild.right != _ else -1  6 if leftHeight > rightHeight then rotateRight(rightChild)  7 rotateLeft(node) \n\n<center><그림 9.12> AVL 트리: rebalanceLeft 메소드</center> \n\n1 rebalanceRight(node):  2 leftChild := node.left  3 if leftChild != _ then  4 leftHeight := leftChild.left.height if leftChild.left != _ else -1  5 rightHeight := leftChild.right.height if leftChild.right != _ else -1  6 if leftHeight > rightHeight then rotateLeft(rightChild)  7 rotateRight(node) \n\n<center><그림 9.13> AVL 트리: rebalanceRight 메소드</center> \n\n![](images/6_1.jpg)\n\n<center><그림 9.14> AVL 트리의 합법</center>\n\n\n• 요구사항 4., 모든 실패 검색에 대해 루트 노드부터 지나가는 검정 노드의 수는 같아야 한다. \n\n요구사항 4에 의해 위 요구사항을 모두 만족하는 트리는 균형 트리에 가까울 것이라는 것을 짐작할 수 있다. 실제 빨간 검정 트리의 모든 노드가 AVL 특성을 만족하지 않지만 위 4가지 요구사항을 모두 만족하면 그 트리의 높이는 O(log n)이다. \n\n![](images/7_0.jpg)\n\n<center><그림 9.15> 빨간 검정 트리</center> \n\n빨간 검정 트리는 삽입과 삭제가 이루어지더라도 트리가 계속 4가지 요구조건을 만족해야 한다. 이를 위해 노드 의 색을 변경하거나 AVL처럼 오른쪽, 왼쪽 회전을 한다. AVL트리는 삽입할 때 단말까지 탐색하여 노드를 추가하고 다시 루트 노드까지 올라가면서 트리의 균형을 조정한다. AVL에서 삭제도 유사한 과정을 거친다. 반면에 빨간 검정 트리는 단말까지 한번의 탐색으로 모든 과정을 처리한다. 다만, 트리의 높이 측면에서는 AVL이 더 최적이다. 즉, 빨간 검정 트리는 트리의 높이를 조금 희생하면서 효율성을 높인 균형 이진 검색 트리이다. 그림 9.15에 주어진 빨간 검정 트리는 유효한 빨간 검정 트이지만 유효한 AVL 트리는 아니다.",
    "source": "ds09_3_빨간 검정 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "빨간 검정 트리",
      "section_number": "3",
      "section_heading": "## 3. 빨간 검정 트리",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds09/images/4_0.jpg",
        "ds09/images/4_1.jpg",
        "ds09/images/5_0.jpg",
        "ds09/images/5_1.jpg",
        "ds09/images/5_2.jpg",
        "ds09/images/6_0.jpg",
        "ds09/images/6_1.jpg",
        "ds09/images/7_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0123"
  },
  {
    "type": "텍스트북",
    "text": "3.1 삽입 \n\n![](images/7_1.jpg)\n\n<center><그림 9.16> 빨간 검정 트리 삽입 규칙</center> \n\n빨간 검정 트리에서 노드의 삽입은 다음과 같이 이루어진다. 빈 트리이면 검정 노드로 값이 추가된다. 빈 트리가\n\n\n아니면 일반 이진 검색 트리에서 삽입 과정을 수행한다. \n\n![](images/8_0.jpg)\n\n<center><그림 9.17> 20, 10, 30, 5 순으로 삽입하였을 때 빨간 검정 트리의 모습</center> \n\n이 과정에서 두 자식이 모두 빨간 노드인 노드를 만나면 노드와 그 자식 노드의 색을 모두 변경한다. 이때 노드가  루트 노드이면 빨간 노드를 다시 검정 노드로 바꾼다. 예를 들어 그림 9.17의 세 번째 트리에 5를 추가할 때 이  규칙의 적용이 필요하다. 삽입을 위해 루트부터 탐색을 시작하게 된다. 이때 루트 노드의 두 자식 노드가 모두 빨간  노드이다. 따라서 루트 노드를 빨간 색, 그것의 자식인 10과 20을 검정 색으로 변경해야 한다. 그런데 루트 노드가  빨간 색으로 변경되었으므로 이를 다시 검정 노드로 변경해야 한다. \n\n새 노드가 단말로 추가될 때 부모 노드가 검정 노드이면 빨간 노드로 추가하고 종료한다. 반면에 그림 9.16의 (1)과 (2)처럼 빨간 노드이고 직선 형태이면 왼쪽 또는 오른쪽 회전하고 위로 올라간 노드는 검정 노드로 내려온 노드는 빨간 노드로 색을 변경한다. 그림 9.16의 (3)과 (4)처럼 직선이 아니면 먼저 직선으로 바꾼 후 회전을 한다. 이것은 AVL에서 이중 회전과 비슷하다. \n\n빨간 검정 트리에서 삭제는 일반 이진 검색 트리에서 삭제 과정과 동일하게 진행된다. 일반 이진 검색 트리에서 자식이 둘인 노드를 삭제할 경우 그것의 선행 또는 후속 노드 값으로 노드의 값을 대체하고 실제 삭제는 선행 또는 후속 노드를 삭제하게 된다. 이와 같이 삭제하기 때문에 삭제는 항상 단말 또는 자식이 하나 있는 노드를 삭제하게 된다. 이때 a를 삭제할 노드, b를 삭제할 노드를 대신할 노드라 하자. 만약 a가 단말이면 b는 널포인터이고 색은 검정이라 가정한다. \n\n노드의 삭제 이후 빨간 검정 트리의 요구사항을 계속 충족하도록 조정을 해 주어야 한다. 가장 간단한 경우는 a 또는 b가 빨간 노드인 경우이다. 연속하여 두 노드가 빨간 노드일 수 없으므로 a와 b가 모두 빨간 노드일 수 없다. 그러면 삭제할 노드는 삭제하고 대체한 노드는 검정 노드로 만들면 경로에 있는 검정 노드의 수에 변하가 없기 때문에 빨간 검정 트리의 요구사항이 계속 충족된다. \n\n또 다른 경우는 a와 b가 모두 검정 노드인 경우이다. 그러면 a를 b로 대체하고 이중 검정 노드로 표시한다. 그다음 이중 검정 노드를 다시 단일 검정 노드로 바꾸어야 한다. 이를 위해 a의 형제 노드를 살펴본다. 형제 노드가 검정 노드이고 그것의 자식 노드 중 빨간 노드가 있으면 그것에 맞는 회전을 해야 한다. 형제 노드가 검정 노드이고, 그것의 자식도 모두 검정 노드이면 회전 없이 색만 변경하면 된다. 형제 노드가 빨간 노드이면 또 회전을 하여 이 노드를 위로 올려야 한다. 더 자세한 세부 과정은 이 교재에서는 생략한다.",
    "source": "ds09_3.1_빨간 검정 트리-3.1 삽입",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "빨간 검정 트리: 3.1 삽입",
      "section_number": "3.1",
      "section_heading": "3.1 삽입",
      "parent_section": "3. 빨간 검정 트리",
      "parent_section_number": "3",
      "images": [
        "ds09/images/7_1.jpg",
        "ds09/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0124"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 기타",
    "source": "ds09_4_기타",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "기타",
      "section_number": "4",
      "section_heading": "## 4. 기타",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0125"
  },
  {
    "type": "텍스트북",
    "text": "## 4.1 이진 검색 트리 \n\n지금까지 대표적인 균형 이진 검색 트리인 AVL 트리와 빨간 검정 트리를 살펴보았다. 실제 라이브러리에서 균형 이진 검색 트리가 필요하면 AVL 트리보다 성능이 좋은 빨간 검정 트리를 더 많이 사용한다. AVL 트리, 빨간 검정 트리 외에 이진 검색 트리를 살펴보면 splay 트리라는 것과 RST 트리라는 것이 있다. Splay 트리는 자주 검색하는 것이 루트 노드에 가까울수록 검색 평균 비용이 향상된다는 원리를 이용하는 트리이다. 이를 위해 자주 검색하는 것을 루트 노드에 가깝게 유지한다.\n\n![](images/9_0.jpg)\n\n![](images/9_1.jpg)\n\n<center>(1) 삽입 전 모습</center> \n\n<center>(2) 일반 BST처럼 단말로 삽입</center> \n\n![](images/9_2.jpg)\n\n![](images/9_3.jpg)\n\n<center>(3) reheap up 첫 번째</center> \n\n<center>(4) reheap up 두 번째</center> \n\n<center><그림 9.18> 랜덤 검색 트리에서 삽입 과정</center> \n\nRST(Randomized Search Tree)는다른말로 Treap(Tree와 Heap이결합된용어)이라한다. RST는이진검색 트리와힙자료구조의특성을결합한트리이다. 이트리에서각노드는키와우선순위값을유지한다. 이트리는 다음요구사항을충족한다. \n\n● 요구사항 1. 노드의 키에 대해서는 이진 검색 트리의 조건을 충족한다. \n\n● 요구사항 2. 노드의 우선순위에 대해서는 힙 특성을 충족한다. \n\n힙 자료구조는 11장에서 자세히 살펴보는데, 힙은 레벨을 기준으로 우선순위가 높은 것이 하위 레벨(루트에 가깝게) 에 유지되는 이진 트리이다. \n\n이 트리에서 삽입은 그림 9.18과 같이 키 기준으로 일반 이진 검색 트리와 동일하게 삽입이 이루어진 다음 우선 순위를 바탕으로 reheap up 과정을 수행하여 우선순위가 높은 것이 더 낮은 레벨에 위치하도록 조정한다. 또 reheap up 과정에서 회전을 통해 트리의 균형도 유지한다. 보통 각 노드의 우선순위는 임의로 결정한다.",
    "source": "ds09_4.1_기타-이진 검색 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "기타: 이진 검색 트리",
      "section_number": "4.1",
      "section_heading": "## 4.1 이진 검색 트리",
      "parent_section": "4. 기타",
      "parent_section_number": "4",
      "images": [
        "ds09/images/9_0.jpg",
        "ds09/images/9_1.jpg",
        "ds09/images/9_2.jpg",
        "ds09/images/9_3.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0126"
  },
  {
    "type": "텍스트북",
    "text": "## 4.2 기타트리 \n\n접두사트리(prefix tree, radix tree)는키가n개의문자로구성된알파벳을사용하면자식의수가최대n개가질 수있는트리이다. 공간을최소화하여정해진단어들이트리에있는지여부를빠르게알려줄수있는트리이다. 키 길이가길고키의앞부분을공유하는값들이없으면효율성이떨어질수있다. 파일시스템에저장된데이터에 대한색인작업을위해널리사용하는B트리, B+ 트리도있다. 세그먼트트리(segment tree)는구간정보를빠르게 계산할수있는동시에구간에있는값을언제든지갱신할수있도록해주는트리이다.",
    "source": "ds09_4.2_기타-기타트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제9장 균형 이진 검색 트리",
      "section": "기타: 기타트리",
      "section_number": "4.2",
      "section_heading": "## 4.2 기타트리",
      "parent_section": "4. 기타",
      "parent_section_number": "4",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0127"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 집합 자료구조 \n\n집합 자료구조는 수학적 개념이 명확한 자료구조이다. 중복된 요소를 유지하지 않으며, 효과적으로 데이터를 삽입할 수 있고, 어떤 요소가 포함되어 있는지 여부를 빠르게 알 수 있다. 기본적으로 add, contains, remove 연산을 제공한다. 또 합집합, 교집합, 차집합 등 집합 간 연산도 제공할 수 있다. 그러면 집합 자료구조를 어떻게 구현할 수 있을까? 크게 다음과 같은 3가지 방법이 있다. \n\n 방법 1. 직접 주소 방법(direct addressing)을 이용한다. \n\n 방법 2. 균형 이진 검색 트리를 이용한다. \n\n 방법 3. 해심을 이용한다. \n\n9장에서 살펴본 균형 이진 검색 트리를 이용하여 집합을 구현하면 집합의 3가지 기본적인 연산을 모두 O(log n) 에 제공할 수 있다. 방법 3은 이 장 후반부에 자세히 살펴본다. 간단하게 설명하면 초기 용량만 적절하게 확보하면 집합의 기본 연산을 모두 O(1)에 제공할 수 있다.",
    "source": "ds10_1_집합 자료구조",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "집합 자료구조",
      "section_number": "1",
      "section_heading": "## 1. 집합 자료구조",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0128"
  },
  {
    "type": "텍스트북",
    "text": "## 1.1 직접 주소 방법 \n\n직접 주소 방법은 다른 말로 찾아보기 테이블(lookup table)이라 하며, 집합 도메인의 크기만큼의 임의 접근이 가 능한 배열을 사용한다. 예를 들어 영소문자를 유지하는 집합이 필요하면 크기가 26인 배열을 사용할 수 있다. 실제 집합 자료구조는 요소의 유무만 파악할 수 있으면 되기 때문에 실제 요소를 저장하지 않고 있어도 된다. 따라서 앞서 살펴본 영소문자 집합의 경우에는 용량이 26인 논리형 배열만 있으면 된다. \n\n직접 주소 방법을 사용하기 위해서는 요소를 테이블에 매핑하는 방법이 있어야 하며, 충돌이 발생하지 않아야 한다. 여기서 충돌이란 서로 다른 요소가 테이블의 같은 위치로 매핑되는 경우를 말한다. 직접 주소 방법의 도메인 크기만큼의 임의 접근 가능한 공간이 필요하다. 따라서 도메인이 매우 클 경우에는 사용하기 어렵다. 물론 비트 벡터를 사용하면 필요한 공간의 크기를 대폭 줄일 수 있지만 여전히 도메인이 제한적이지 않으면 사용하기 어렵다. 또 다른 단점은 저장하는 개수와 무관하게 항상 고정된 크기의 공간이 필요하다. \n\n직접 주소 방법의 특징을 요약하면 다음과 같다. \n\n 충돌이 발생하지 않는 데이터와 저장위치를 매핑하여 주는 함수가 필요하다. \n\n 용량이 데이터 도메인 크기인 임의접근이 가능한 공간이 필요하다.\n\n\n- 데이터를 직접 유지할 필요가 없다. \n\n- 저장한 개수와 무관하게 고정된 크기의 공간을 사용한다.",
    "source": "ds10_1.1_집합 자료구조-직접 주소 방법",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "집합 자료구조: 직접 주소 방법",
      "section_number": "1.1",
      "section_heading": "## 1.1 직접 주소 방법",
      "parent_section": "1. 집합 자료구조",
      "parent_section_number": "1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0129"
  },
  {
    "type": "텍스트북",
    "text": "1.1.1 비트 벡터 \n\n어떤 요소의 존재 여부를 가장 적은 공간에 나타내는 방법이 비트 벡터이다. 비트 벡터는 확보한 공간의 각 비트를 통해 특정 요소의 존재 여부를 나타낸다. 참고로 C++에서 `std::vector<bool>`을 사용하면 내부적으로 비트 벡터로 구현한다. \n\n비트 벡터는 보통 바이트 배열을 이용하여 구현한다. 용량이 4인 바이트 배열을 이용하면 총 32개의 요소에 대한 존재 여부를 나타낼 수 있다. 요소를 0부터 n-1 사이의 값으로 매핑하는 방법이 있으면 비트 벡터를 사용하여 직접 주소 방법을 구현할 수 있다. 비트 벡터를 구현하기 위해서는 `get, set, unset` 등의 연산을 제공해야 한다. 이때 이들 메소드는 모두 색인을 인자로 받는다. 이들 연산은 인자로 k가 제공되었을 때 바이트 색인과 비트 색인을 얻을 수 있어야 한다. \n\n1. `get(k):`\n2. `byteIdx := k>>3`\n3. `bitIdx := k&0b0111`\n4. `return vector[byteIdx] & mask[bitIdx] != 0` \n\n<그림 10.1> 비트 벡터: get 메소드 \n\n지금까지는 모두 1색인을 이용하여 의사코드를 제시했지만 비트 벡터는 실제 구현에 가깝게 의사코드를 제시 하기 위해 0색인을 이용하여 설명하고 서술하고자 한다. 인자로 제공된 값 k가 11이면 바이트 색인과 비트 색인은 어떻게 계산하는지 생각하여 보자. 각 바이트에는 8개 비트가 있으므로 바이트 색인은 8로 나누면 되고, 비트 색인은 k를 8로 나누었을 때 나머지가 된다. 실제 나누거나 나머지 연산을 이용하지 않고 비트 연산을 이용하여 바이트 색인과 비트 색인을 그림 10.1과 같이 계산할 수 있다. 여기서 mask 배열은 다음 값으로 초기화된 배열이다. \n\n\\[ [0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01] \\]\n\nmask 배열을 사용하지 않고 `0b10000000>>(k&0b0111)`로 사용할 mask 값을 계산하여 사용할 수 있다. \n\n1. `set(k):`\n2. `vector[k>>3] |= mask[k&7]` \n\n<그림 10.2> 비트 벡터: set 메소드 \n\nset 연산은 해당 위치를 1로 바꾸어야 한다. 따라서 `get`과 같은 방법으로 mask를 구해 논리합을 해주면 된다. 0과 논리합은 원래 값을 얻을 수 있고, 1과 논리합은 무조건 1이 된다는 것을 이용하는 것이다. `set` 연산의 의사 코드는 그림 10.2와 같다. `get`과 달리 불필요한 지역 변수를 제외하였다. `set` 연산에서 논리합을 하지 않고 XOR 하면 해당 위치의 비트를 토글하는 효과를 얻을 수 있다. \n\n1. `unset(k):`\n2. `vector[k>>3] &= ~mask[k&7]` \n\n<그림 10.3> 비트 벡터: unset 메소드 \n\n`unset` 연산은 해당 위치를 0로 바꾸어야 한다. 0으로 바꾸기 위해서는 해당 위치는 0이고 나머지는 모두 1인 mask가 필요하다. 이 mask는 기존 mask을 토글하면 쉽게 얻을 수 있으며, 이 mask를 바이트 배열의 바이트와\n\n\n논리곱하면 해당 위치만 0이 되고 나머지는 그대로 유지된다. unset 연산의 의사코드는 그림 10.3과 같다.",
    "source": "ds10_1.1_집합 자료구조-1.1.1 비트 벡터",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "집합 자료구조: 1.1.1 비트 벡터",
      "section_number": "1.1",
      "section_heading": "1.1.1 비트 벡터",
      "parent_section": "1. 집합 자료구조",
      "parent_section_number": "1",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0130"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 맵 자료구조 \n\n맵은 키와 데이터 쌍을 유지하는 집합 자료구조이다. 집합 자료구조와 마찬가지로 키는 중복될 수 없고, 일반적으로 키 간의 순서가 존재하지 않는다. 하지만 일반 집합 자료구조처럼 키의 존재를 확인하는 것이 핵심이 아니라 키가 저장되어 있을 때 그것과 연결된 데이터를 추출하는 것이 핵심이다. 기본 연산은 put, get, containsKey이다. put은 집합의 add 연산과 달리 이미 키가 존재할 경우 연결된 데이터를 수정하게 된다. 맵 자료구조도 집합과 유사하게 직접 주소 지정 방법, 균형 이진 검색 트리, 해싱을 이용하여 구현할 수 있다.",
    "source": "ds10_2_맵 자료구조",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "맵 자료구조",
      "section_number": "2",
      "section_heading": "## 2. 맵 자료구조",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0131"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1 웹 서비스 접속 로그 \n\n특정 웹 서비스 운영자는 클라이언트가 접근할 때마다 날짜, 시간, IP 주소 3개 정보를 로그에 유지하고 있다. 이 운영자는 이 로그 데이터로부터 다음과 같은 정보를 얻고 싶다. \n\n● 정보 1. 특정 IP 주소에서 지난 1시간 동안 접속한 적이 있는지 여부 \n\n● 정보 2. 특정 IP 주소에서 지난 1시간 동안 접속한 횟수 \n\n● 정보 3. 지난 1시간 동안 접속한 IP의 수 \n\n특별한 자료구조를 이용하지 않고 지난 1시간 동안 접속한 로그를 순차적으로 분석하면 필요한 모든 정보를 얻을 수 있다. 하지만 이와 같은 방법을 사용하면 비용이 O(n)이다. 여기서 n은 지난 1시간 동안 축적된 로그 수 이다. 이 비용을 개선할 수 없을까? 지난 1시간 동안 특정 IP의 접속 수를 별도 자료구조를 이용하여 유지한다면 비용은 어떻게 개선되는지 살펴보자. 이 자료구조는 IP 주소를 이용하여 임의 접근이 가능하고, 해당 위치에는 IP 주소와 접속 수를 바로 얻을 수 있다고 가정하자. 그러면 정보 1은 IP주소에 해당하는 위치의 접속 수가 0보다 큰지 검사하면 되고, 정보 2는 접속 수를 반환하면 된다. 따라서 두 정보를 모두 O(1)에 제공할 수 있다. 정보 3은 이 자료구조를 이용하여도 효과적으로 얻을 수 없지만 별도 가운팅하면 이 역시 O(1)에 제공할 수 있다. 이 자료구조와 정보 3은 그림 10.4와 같이 지속적으로 갱신해야 한다. \n\n1 for every second do  2 for each log entering the interval do  3 if counter[log.ip]==0 then numIPs += 1  4 counter[log.ip] += 1  5 for each log leaving the interval do  6 counter[log.ip] -= 1  7 if counter[log.ip]==0 then numIPs -= 1 \n\n## <그림 10.4> AVL 트리: adjustHeight 메소드 \n\n그러면 IP 주소를 이용하여 임의 접근이 가능한 자료구조는 어떻게 구현할 수 있는지 생각하여 보자. 실제 이 자료구조는 이 절에서 살펴보는 맵 자료구조이다. 이와 같은 맵 자료구조는 직접 주소 저장 방식을 이용하여 구현할 수 있지만 이 예의 경우 IP4 주소를 가정하면 2³² 용량의 배열이 필요하다. 하지만 앞서 언급한 바와 같이 직접 주소 저장 방식은 저장하는 개수와 상관없이 항상 일정한 용량의 배열이 필요하다. 지난 1시간 동안 접속한 수가 매우 적으면 낭비되는 공간이 너무 많다. 균형 이진 검색 트리를 이용하면 공간 낭비 없이 정보 1과 정보 2를 O(log n) 에 제공할 수 있다. 여기서 n은 지난 1시간 동안 접속한 서로 다른 IP 수이다. 이 정도면 성능이 충분히 만족할 수준이다. 하지만 다음 절에서 살펴볼 해싱을 이용하면 직접 주소 저장 방식처럼 O(1)에 정보 1과 2를 얻을 수\n\n\n있으며, 직접 주소 저장 방식과 달리 도메인 크기의 용량이 필요한 것이 아니라 저장하는 서로 다른 IP 수에 비례한 크기의 용량이 필요하다. \n\n해싱(hashing)은 시간 복잡도 측면에서는 직접 주소 지정 방식과 같은 수준이며, 공간 복잡도 측면에서는 균 형 이진 검색 트리를 이용하는 것과 비교하여 같은 수준이다. 또 내부적으로 배열을 사용하기 때문에 캐싱에도 유리하다는 이점도 있다.",
    "source": "ds10_2.1_맵 자료구조-웹 서비스 접속 로그",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "맵 자료구조: 웹 서비스 접속 로그",
      "section_number": "2.1",
      "section_heading": "## 2.1 웹 서비스 접속 로그",
      "parent_section": "2. 맵 자료구조",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0132"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 해싱 \n\n지금까지 살펴본 자료구조에서 삽입, 삭제, 검색 연산을 생각하여 보자. 배열 기반 비정렬 리스트에서 삽입, 삭제, 검색은 각각 O(1), O(n), O(n)이고, 배열 기반 정렬 리스트에서 삽입, 삭제, 검색은 각각 O(n), O(n), O(log n)이다. 연결구조 기반 비정렬 리스트에서 삽입, 삭제, 검색은 각각 O(1), O(n), O(n)이고, 연결구조 기반 정렬 리스트에서 삽입, 삭제, 검색은 각각 O(n), O(n), O(n)이다. 균형 이진 검색 트리에서 삽입, 삭제, 검색은 모두 O(log n)이다. 따라서 데이터를 빈번히 삽입, 삭제하고 검색해야 하면 지금까지 살펴본 자료구조 중 가장 성능이 좋은 것은 균형 이진 검색 트리이다. 이 장에서 살펴본 직접 주소 저장 방식을 사용하면 모두 O(1)에 제공할 수 있다. 하지만 도메인 크기만큼의 공간 복잡도를 요구하며, 저장할 데이터를 저장할 위치와 매핑해주는 효과적인 함수가 필요하다. 해싱은 직접 주소 저장 방식처럼 3가지 연산을 모두 O(1)에 제공하면서 공간 복잡도는 도메인 크기에 비례하는 것이 아니라 저장하는 요소에 비례한다. \n\n해싱의 개념을 이해하기 위해 간단한 예를 생각하여 보자. 직원이 최대 100명인 회사가 있고, 각 직원의 식별번호가 0부터 차례로 부여되었다고 하자. 이 경우 용량이 100인 배열을 이용하여 직접 주소 저장 방식을 사용할 수 있다. 직원이 최대 100명이지만 식별번호가 다섯자리 정수일 때, 직접 주소 저장 방식을 사용하고자 하면 총 100,000 용량의 배열이 필요하다. 하지만 직원은 100명밖에 없으므로 공간이 많이 낭비된다. 이 낭비를 줄이기 위해 용량이 100인 배열을 사용하고 저장할 위치를 식별번호의 마지막 두 자리만 사용하면 어떻게 되나? \n\n이와 같이 해싱에서 저장할 위치를 결정해 주는 함수를 해시함수(hash function)라 하고, 데이터가 실제 저장되는 임의 접근이 가능한 공간을 해시 테이블(hash table)이라 한다. 해시 테이블에서 데이터를 저장하는 개별 공간을 슬롯(slot)이라 한다. 해싱에서 해시함수의 입력 값을 보통 키 값이라 하며, 해시함수의 최종 출력은 해시 테이블의 위치 또는 데이터를 저장할 슬롯의 위치이다. \n\n식별번호의 마지막 두 자리만 사용하면 서로 다른 식별번호가 같은 위치로 매핑될 수 있다. 이와 같은 경우에 충돌(collision)이 발생하였다고 말한다. 해시함수가 단사함수(injective function)이 아니면 충돌의 발생은 불가피하다. 적은 공간을 사용하면서 해시함수를 잘 만들어 충돌이 거의 발생하지 않도록 할 수 있고, 충돌이 발생하여도 이를 효과적으로 처리할 수 있다면 공간 복잡도를 직접 주소 지정 방식에 비해 획기적으로 개선하면서 여전히 직접 주소 지정 방식과 같은 O(1)에 삽입, 삭제, 검색을 제공할 수 있다. 이와 같이 적은 공간을 사용하면서 해시함수를 이용하여 직접 주소 지정 방식과 같은 수준의 성능을 제공하는 기술을 해싱이라 한다. \n\n해싱은 3가지 요소가 필요하다. 첫째, 임의 접근이 가능한 데이터를 저장할 해시 테이블이 필요하다. 목표는 해시 테이블의 용량을 최소화하는 것이다. 하지만 n개의 요소를 저장할 것이면 최소 n개의 데이터를 저장할 크기의 공간이 필요하다. 둘째, 데이터를 저장할 위치로 매핑해주는 해시함수가 필요하다. 좋은 해시함수가 되기 위해서는 충돌이 최소화되어야 한다. 해싱에서 접근 비용을 고려할 때 해시값 계산 비용은 포함하지 않는다. 이 비용은 실제 저장할 키 값에 의존하지만 기존 저장된 요소의 개수에 비례하지 않기 때문에 시간 복잡도를 O(1)으로 계산한다. 셋째, 충돌은 불가피하기 때문에 충돌 해결 전략이 필요하다.",
    "source": "ds10_3_해싱",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱",
      "section_number": "3",
      "section_heading": "## 3. 해싱",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0133"
  },
  {
    "type": "텍스트북",
    "text": "### 3.1 해시함수 \n\n해시함수 \\(h\\)는 가능한 키 값의 집합 \\(S\\)를 0에서 \\(m-1\\)로 매핑해 주는 함수이며, 이때 \\(m\\)을 \\(h\\)의 차수(cardinality)라 한다. 해시함수 \\(h\\)의 요구사항은 다음과 같다. \n\n- 요구사항 1. 계산 속도가 빨라야 한다. \n\n- 요구사항 2. 모든 \\(s \\in S\\)에 대해 \\(\\Pr[h(s) = i] = \\frac{1}{m}\\)이어야 한다. \n\n두 번째 요구사항을 다르게 표현하면 \\(s \\neq s'\\)에 대해 \\(\\Pr[h(s) = h(s')] \\le \\frac{1}{m}\\)이어야 한다. \n\n보통 \\(|S| > m\\)이므로 \\(h(s) = h(s')\\)인 \\(s \\neq s'\\)인 쌍 \\((s, s')\\)의 존재는 불가피하다. 요구사항 2 때문에 충족되는 해시함수를 이용하여 \\(n\\)개의 요소를 해시하면 특정 값으로 해시되는 요소의 개수는 평균 \\(\\frac{n}{m}\\)이다. 저장할 \\(n\\)개 요소의 분포가 실제 충돌에 큰 영향을 준다. \n\n문자열을 저장할 때 사용할 해시함수에 대해 생각하여 보자. 문자열의 길이를 해시함수로 사용하면 같은 길이의 문자열은 모두 해시값이 같게 된다. 또 해시 테이블의 용량보다 긴 길이의 문자열은 저장할 곳이 없다. 즉, 최종적으로 해시함수의 차수는 해시 테이블의 용량과 같아야 한다. 따라서 어떤 해시함수를 사용하던 최종적으로는 보통 해시 테이블의 용량으로 나머지 연산을 취하여 최종 저장 위치를 결정할 수밖에 없다. \n\n문자열을 구성하는 문자를 전혀 활용하지 않고 랜덤한 값을 생성하여 해시값으로 사용하는 것도 생각해 볼 수 있지만 같은 문자열은 매번 같은 위치로 매핑되어야 하므로 이와 같은 방법을 사용할 수 없다. 문자열의 첫 문자만 이용하여 해시함수를 만들면 같은 문자로 시작하는 모든 문자열의 해시값은 같게 된다. 따라서 문자열의 일부만 이용하는 것은 충돌이 많이 발생할 수 있으므로 문자열의 모든 문자를 이용하여 해시함수를 만들어야 한다. 문자열의 모든 문자를 더한 값을 해시값을 사용하는 해시함수를 생각하여 보자. 이 경우 “god”와 “dog”의 해시값은 같아진다. 따라서 문자열의 모든 문자를 이용하더라도 문자가 등장하는 위치에 따라 해시값에 반영되는 것이 달라져야 한다. \n\n실제 해시함수로 많이 사용하는 함수는 다음과 같다. \n\n- 정수 해시함수: \\(\\mathcal{H}_p = \\{h_p^a(x) = ((ax + b) \\mod p) \\mod m\\}\\), 여기서 \\(p > x\\)보다 큰 소수이며, \\(a\\)와 \\(b\\)는 \\(1 \\le a \\le p-1\\), \\(0 \\le b \\le p-1\\) 범위의 임의의 정수이다. \n\n- 문자열 해시함수: \\(\\mathcal{H}_p = \\{h_p^x(S) = \\sum_{i=0}^{|S|-1} S[i]x^i \\mod p\\}\\), 여기서 \\(p\\)는 소수이고, \\(x\\)는 \\(1 \\le x \\le p-1\\) 범위의 임의의 수이다. \n\n한 함수를 정의한 것이 아니라 함수 집합을 정의하고 있다. 예를 들어 \\(p\\)와 \\(x\\)를 하나 선택하면 문자열 해시함수 집합에 있는 한 함수를 선택하게 되는 것이다. 자바 언어의 경우 \\(x = 31\\)을 사용하고 있으며 \\(p\\)는 사용하고 있지 않다. 문자열 해시함수를 의사코드로 표현하면 그림 10.5와 같다. 내부적으로 뒷 문자부터 처리하고 있는데 앞부터 처리하여도 된다. 보통 문자열 해시함수를 이용하여 해시값을 계산한 다음 다시 이것을 정수 해시함수를 이용하여 최종 해시값을 계산한다. \n\n1 hashString(S): \n\n2 ret := 0 \n\n3 for i:=|S-1| to 0 do \n\n4 ret := (ret * x + S[i]) % p \n\n5 return ret \n\n<그림 10.5> 문자열 해시함수",
    "source": "ds10_3.1_해싱-### 3.1 해시함수",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.1 해시함수",
      "section_number": "3.1",
      "section_heading": "### 3.1 해시함수",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0134"
  },
  {
    "type": "텍스트북",
    "text": "### 3.2 충돌 처리 방법 \n\n아무리 좋은 해시함수를 사용하더라도 충돌은 불가피하다. 충돌이 발생할 경우 충돌된 데이터를 저장하는 방법이 필요하다. 충돌을 처리하는 방법은 크게 열린 기법(open addressing)과 닫힌 기법(closed addressing)으로 구분된다. 열린 기법은 원래 데이터를 저장해야 하는 곳이 아닌 다른 곳에 저장하는 기법이고, 닫힌 기법은 원래 데이터를 저장해야 하는 곳에 저장하는 기법이다. 충돌된 데이터를 원래 데이터를 저장해야 하는 곳에 저장한다는 것은 원래 데이터를 저장해야 하는 곳에 하나가 아니라 여러 개를 저장할 수 있다는 것을 말한다. \n\n열린 기법은 보통 닫힌 해상(closed hashing)에 해당한다. 닫힌 해상이란 최초 확보한 공간 내에 충돌된 데이터를 저장한다. 반면에 열린 해상은 최초 확보한 공간이 아닌 추가 공간을 확보해 충돌된 데이터를 저장한다.",
    "source": "ds10_3.2_해싱-### 3.2 충돌 처리 방법",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.2 충돌 처리 방법",
      "section_number": "3.2",
      "section_heading": "### 3.2 충돌 처리 방법",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0135"
  },
  {
    "type": "텍스트북",
    "text": "### 3.2.1 열린 기법 \n\n열린 기법 중 가장 기본적인 방법은 선형 조사(linear probing) 방법이다. 선형 조사는 해시 테이블을 순환 구조로 사용하며, 원래 저장해야 하는 위치에 저장할 수 없으면 그다음 색인부터 차례로 비어있는지 여부를 조사하고 비어있으면 그곳에 충돌된 데이터를 저장한다. 선형 조사는 저장할 수 없을 때 기본적으로 +1 위치를 반복적으로 조사하는데, 이때 +1 대신에 +k를 사용할 수 있다. +k를 사용할 경우 k가 해시 테이블의 용량과 서로소가 아니면 모든 위치를 조사할 수 없다. 선형 조사의 문제는 근접한 색인값으로 매핑되는 키 값들이 뭉쳐 존재하게 되며, 이를 clump 현상 또는 cluster 현상이라 한다. \n\n해시 테이블의 용량이 5라 하자. 그러면 모두 비어 있을 때 특정 슬롯에 저장할 확률은 20%이다. 첫 번째 슬롯에 데이터가 저장되어 있고, 나머지 슬롯은 모두 비어 있다. 이때 두 번째 슬롯에 데이터를 저장할 확률은 어떻게 되는가? \\(\\frac{1}{m}\\)에 해당하는 20%도 아니고, 4개의 슬롯이 남아 있기 때문에 25%도 아니다. 실제 두 번째 슬롯에 데이터가 저장될 확률은 40%이다. \\(h(k) = 0\\), \\(h(k) = 1\\)이어도 두 번째 슬롯에 저장해야 하기 때문이다. 따라서 선형조사 방법에서 충돌이 발생하면 특정 슬롯에 데이터를 저장할 확률이 높아지는 문제가 있으며, 이 때문에 clump 현상이 발생한다. \n\n+3을 이용하여 선형조사를 한다고 가정하고, 해시 테이블의 용량이 10이라 하자. 그러면 \\(h(k) = 3\\)인 키들이 조사하게 되는 색인 순서는 \\([3,6,9,2,5,8,1,4,7,0]\\)이고, \\(h(k) = 6\\)인 키들이 조사하게 되는 색인 순서는 \\([6,9,2,5,8,1,4,7,0,3]\\)이다. 제시된 것처럼 3과 6으로 해시되는 키 값들의 선형 조사 위치가 겹친다. 이 때문에 발생하는 clump 현상을 1차 클러스터링(primary clustering)이라 한다. \n\n1차 클러스터링 문제를 해결하는 방법은 크게 다음 2가지 방법이 있다. \n\n- 임의 조사 방법(random probing): 1부터 \\(m-1\\)까지 값을 임의로 써어 이들을 이용하여 선형 조사하는 방법을 말한다. 예를 들어 \\(m = 10\\)이면 \\([4,5,7,1,6,0,8,3,2]\\)와 같은 임의 순서를 만든 후 \\(h(k) = r\\)이면 \\(r+4\\), \\(r+5\\) 위치를 조사하는 방법이다. 서로 다른 해시값을 가진 키들의 조사 위치가 겹치지 않기 때문에 1차 클러스터링 문제는 해결된다. \n\n- 2차 함수 활용 조사 방법(quadratic probing): \\(p(i) = c_1i^2 + c_2i + c_3\\) 형태의 2차 함수를 이용하여 선형 조사 위치를 결정하는 방법을 말한다. 보통 \\(p(i) = i^2\\)을 많이 사용한다. \\(h(k) = r\\)이면 \\(r+1\\), \\(r+4\\), \\(r+9\\) 순서로 조사를 한다. 서로 다른 해시값을 가진 키들의 조사 위치가 겹치지 않지만 모든 위치를 조사하지 못하는 문제가 있다. \n\n임의 조사나 2차 함수 활용 조사 방법은 모두 같은 위치로 해시되는 키에 대해서는 항상 같은 위치를 조사하는 문제점이 있다. 이 문제를 2차 클러스터링(secondary clustering)이라 한다. 2차 클러스터링이 발생하는 이유는 조사 위치가 키 값에 의존하지 않고 최초 해시값에 의존하기 때문이다. 따라서 이 문제를 해결하기 위해서는 조사 위치 계산에 키 값을 활용할 필요가 있다. 조사 위치 계산에 키 값을 활용하는 기법이 이중 해상(double hashing)이다.\n\n\n이중 해싱은 최초 해시값을 계산할 때 사용하는 해시함수 \\(h_1\\)과 조사 위치를 결정하기 위해 사용하는 해시함수 \\(h_2\\).\n2개를 사용한다. 조사 위치는 \\(p(K, i) = i \\times h_2(K)\\)를 이용하여 결정한다. 이때 \\(h_2\\)의 요구사항은 다음과 같다. \n\n- 요구사항 1. 0을 반환하지 않아야 한다. \n\n- 요구사항 2. \\(m\\)과 서로 소이어야 한다. \n\n\\(m\\)과 서로 소가 아니면 모든 위치를 조사하지 못한다. 이 요구사항을 충족하기 위해 \\(m\\)을 소수를 사용할 수 있다. 또는\n\\(m = 2^r\\)을 사용하고 \\(h_2\\)가 1에서 \\(2^r\\) 사이의 홀수를 반환하도록 할 수 있다. 예를 들어 \\(h_2(K) = \\left(\\frac{K}{m} \\mod \\frac{m}{2}\\right) \\times 2 + 1\\)\n를 사용할 수 있다. \n\n선형 조사 기법에서 삭제는 조금 복잡하다. 예를 들어 해시 테이블의 용량이 7이고, 키 값의 타입이 정수라 하자.\n또 사용하는 해시함수는 \\(h(k) = k \\mod 7\\)이고, 현재 해시 테이블에 다음과 같이 8, 16, 11이 저장되어 있다고 하자. \n\n![](images/6_0.jpg)\n\n \n\n여기서 find(15)를 생각하여 보자. \\(h(15) = 1\\)이므로 색인 위치 1을 검사하게 되고, 그다음 색인 위치 2를 검사하고, 최종적으로 색인 위치 3를 검사하게 되는데, 색인 위치 3의 슬롯이 비어 있기 때문에 없다고 결론을 내리고 종료하게 된다. \n\n위 상태에서 insert(15), remove(16)이 이루어지면 해시 테이블은 다음과 같이 변경된다. \n\n![](images/6_1.jpg)\n\n \n\n이 상태에서 find(15)를 생각하면 색인 2가 빈 슬롯이기 때문에 15가 없다고 잘못 결론을 내리게 된다. 이와 같은 문제 때문에 데이터를 삽입한 후에 삭제하면 해당 슬롯에 별도 표시를 하여 빈 슬롯이더라도 계속 조사를 진행하도록 해야 한다. 이 용도로 사용하는 별도 표시를 삭제 플래그(delete flag)라 한다. \n\n삭제 플래그를 사용하면 위 상황에서 해시 테이블은 다음과 같다. \n\n![](images/6_2.jpg)\n\n \n\n이 경우 색인 2에 삭제 플래그가 있기 때문에 계속 조사를 진행하여 15를 올바르게 찾아준다. \n\n삭제 플래그를 사용할 경우 새 데이터를 삭제 플래그가 있는 슬롯에 저장할 수 있다. 하지만 바로 저장할 수 없고 조사 순서를 모두 검사하여 중복 여부를 확인한 후에 저장해야 한다. 또 삭제 플래그가 많아지면 성능에 나쁜 영향을 준다. 이 경우 해시 테이블을 초기화한 후에 기존 데이터를 전체 재해상하여 다시 저장할 필요가 있다. \n\n결론적으로 선형 조사 방법의 열린 해시 충돌 해결 방법은 최악의 경우 해시 테이블의 용량만큼 조사를 해야 데이터의 존재 여부를 알 수 있다. 이것은 해싱이 애초 목표로 하였던 O(1)의 삽입, 삭제, 검색과는 거리가 멀다.",
    "source": "ds10_2.1_해싱-### 3.2.1 열린 기법",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.2.1 열린 기법",
      "section_number": "2.1",
      "section_heading": "### 3.2.1 열린 기법",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [
        "ds10/images/6_0.jpg",
        "ds10/images/6_1.jpg",
        "ds10/images/6_2.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0136"
  },
  {
    "type": "텍스트북",
    "text": "### 3.2.2 닫힌 기법 \n\n닫힌 기법은 앞서 언급한 바와 같이 충돌이 발생하여도 원래 데이터의 해시값에 해당하는 위치에 데이터를 저장하는 기법이다. 따라서 각 슬롯마다 하나의 데이터가 아니라 여러 개를 저장할 수 있어야 한다. \n\n닫힌 기법 중 버킷 방법은 각 슬롯마다 b개 데이터를 저장할 수 있도록 공간을 미리 확보하여 사용하는 방법이다.\n하지만 b가 조금만 크더라도 공간 낭비가 많이 발생하며, 충돌이 발생하였을 때 검색하는 비용이 증가한다. 기존\n\n\n선형 조사 방법과 달리 전체 해시 테이블을 조사할 필요는 없지만 같은 슬롯 내에 b개 버킷에 대해 선형 검색을 해야 한다. b개의 버킷이 있을 때, 이 버킷에 모두 데이터가 저장되어 있으면 별도 넘침 버킷을 만들어 거기에 유지할 수 있다. 버킷 방법은 미리 확보한 공간 내에 데이터를 저장하기 때문에 별도 넘침 버킷을 사용하지 않으면 닫힌 해싱 기법이다. b가 각 슬롯에 준비한 버킷 수이면 접근 비용은 O(b)이며, 공간복잡도는 넘침 버킷을 고려하지 않으면 O(bm)이다. \n\n버킷 방법보다 실제 더 많이 사용하는 닫힌 기법은 체이닝(separate chaining) 기법이다. 이 기법에서 해시 테이\n블의 각 슬롯은 연결구조 기반 리스트를 유지한다. 충돌이 발생하였을 경우 데이터를 이 리스트를 유지한다. 이와\n같은 방법을 사용하기 때문에 같은 위치에 충돌이 지속적으로 발생하면 해당 색인에 유지된 리스트의 크기가 커질\n수 있으며, 이것은 성능에 나쁜 영향을 주게 된다. 체이닝 기법에서 접근 비용은 c가 가장 긴 체인의 길이일 때 O(c)\n이고, 공간 복잡도는 n개의 데이터를 저장할 때 O(m + n)이다.",
    "source": "ds10_2.2_해싱-### 3.2.2 닫힌 기법",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.2.2 닫힌 기법",
      "section_number": "2.2",
      "section_heading": "### 3.2.2 닫힌 기법",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0137"
  },
  {
    "type": "텍스트북",
    "text": "3.2.3 열린 기법 vs. 닫힌 기법 \n\n열린 기법에서 충돌이 발생하면 다음 두 가지 측면에서 성능에 나쁜 영향을 준다. \n\n• 첫째, 빈 곳을 찾기 위한 비용이 소요된다. 체이닝을 사용하는 닫힌 기법에서 삽입 비용은 항상 상수이다. \n\n• 둘째, 기존 충돌이 다음 충돌에 영향을 준다. 닫힌 기법에서는 기존 충돌이 다음 충돌에 영향을 주지 않는다. \n\n닫힌 기법 중 체이닝 기법은 공간 복잡도 측면에서 효과적이지만 다음과 같은 단점이 있다. \n\n• 연결구조 때문에 연결 정보 저장을 위한 추가 공간의 사용이 불가피하다. \n\n• 개성에 불리하다. \n\n닫힌 해싱을 사용하면 해시 용량에 의해 저장되는 키 값의 개수가 제한되지만 열린 해싱 방법은 제한되지 않는다.",
    "source": "ds10_2.3_해싱-3.2.3 열린 기법 vs. 닫힌 기법",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: 3.2.3 열린 기법 vs. 닫힌 기법",
      "section_number": "2.3",
      "section_heading": "3.2.3 열린 기법 vs. 닫힌 기법",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0138"
  },
  {
    "type": "텍스트북",
    "text": "3.3 쿠쿠 해싱 \n\n쿠쿠 해싱은 닫힌 기법이며 닫힌 해싱을 사용한다. 데이터는 원래 그 데이터가 저장되어야 하는 곳에 저장되기 때문\n에 닫힌 기법이며, 추가 공간을 사용하지 않고 최초 확보된 공간에 데이터를 저장하기 때문에 닫힌 해싱 기법이다.\n쿠쿠 해싱은 두 개의 해시 테이블을 사용한다. 따라서 해시함수도 2개 필요하다. 용량이 7인 해시 테이블과 5인\n해시 테이블을 두 개 사용한다고 가정하고 5, 12, 10, 3, 19를 연속하여 삽입한다고 가정하자. 그러면 그 진행사항은\n그림 10.6과 같다. 데이터를 삽입할 때 먼저 첫 번째 테이블에 저장을 시도한다. 이때 충돌이 발생하면 원래 테이\n블에 저장된 데이터를 추출하고 현재 저장할 데이터를 삽입한다. 그다음 추출한 데이터를 두 번째 해시 테이블에\n삽입한다. 이 과정이 생각보다 오랫동안 반복될 수 있고, 데이터가 많이 삽입되어 있으면 무한 반복이 일어날 수\n있다.",
    "source": "ds10_3.3_해싱-3.3 쿠쿠 해싱",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: 3.3 쿠쿠 해싱",
      "section_number": "3.3",
      "section_heading": "3.3 쿠쿠 해싱",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0139"
  },
  {
    "type": "텍스트북",
    "text": "3.4 해시 테이블 \n\n해시 테이블의 용량이 클수록 충돌 발생 가능성은 낮아지지만 반대로 낭비되는 공간은 증가한다. 그러면 저장할\n데이터가 n개 있을 때 해시 테이블의 용량 m을 어느 정도 확보하는 것이 좋은가? 이것을 알기 위해 n개 데이터를\n용량이 m인 해시 테이블에 저장할 때 충돌이 발생할 확률을 구해보자. 이때 각 입력이 특정 슬롯에 저장될 확률은\n\n![](images/8_0.jpg)\n\n \n\n<그림 10.6> 구구 해성 \n\n모두 같다고 가정하자. 충돌이 발생할 확률은 1에서 충돌이 발생하지 않을 확률을 빼면 구할 수 있다. 이것을 확률\n에서 자주 사용하는 표현으로 바꾸면 m개 통이 있을 때 n개의 구슬을 모두 다른 다른 통에 포함할 확률이 된다.\n따라서 충돌이 발생할 확률은 다음과 같다. \n\n\\[\nP_{n,m} = 1 - 1 \\times \\left( \\frac{m-1}{m} \\right) \\times \\left( \\frac{m-2}{m} \\right) \\times \\cdots \\times \\left( \\frac{m-n+1}{m} \\right)\n\\]\n\n예를 들어 m = 6이고 n = 3이면 충돌이 발생할 확률은 다음과 같다. \n\n\\[\n\\Pr_{6,3}(\\text{collision}) = 1 - \\Pr_{6,3}(\\text{no collision}) = 1 - 1 \\times \\frac{5}{6} \\times \\frac{4}{6} \\approx 0.444\n\\]\n\n충돌이 발생할 확률을 좀 더 면밀히 분석하여 보자. \n\n\\[\n1 \\times \\left( \\frac{m-1}{m} \\right) \\times \\left( \\frac{m-2}{m} \\right) \\times \\cdots \\times \\left( \\frac{m-n+1}{m} \\right) = \\prod_{i=1}^{n-1} \\left( 1 - \\frac{i}{m} \\right)\n\\]\n\n이때 x가 매우 작으면 1 - x를 e⁻x로 근사화할 수 있으므로 다음이 성립한다. \n\n\\[\n\\prod_{i=1}^{n-1} \\left( 1 - \\frac{i}{m} \\right) \\approx \\prod_{i=1}^{n-1} e^{\\frac{-i}{m}} = e^{-\\frac{1}{m} \\sum_{i=1}^{n-1} i} = e^{-\\frac{n(n-1)}{2m}}\n\\]\n\ne⁻x를 다시 1 - x로 근사하면 충돌이 발생할 확률은 다음과 같다. \n\n\\[\nP_{n,m} \\approx 1 - e^{-\\frac{n(n-1)}{2m}} \\approx 1 - \\frac{n(n-1)}{2m} \\approx 1 - \\frac{n^2}{2m}\n\\]\n\n따라서 충돌이 발생하지 않을 확률은 약 \\(\\frac{n^2}{2m}\\)이다.\n\n\n이와 유사한 방법으로 충돌 개수에 대한 기대값도 구할 수 있다. 두 번째 이후 구술이 첫 번째 구술과 같은 통에 포함될 확률은 \\(\\frac{n-1}{m}\\)이며, 세 번째 이후 구술이 두 번째 구술과 같은 통에 포함될 확률은 \\(\\frac{n-2}{m}\\)이다. 이것을 모두 합친 것이 충돌 개수에 대한 기대값이며, 다음과 같이 구할 수 있다. \n\n\\[E_{n,m} = \\sum_{i=1}^{n-1} \\frac{i}{m} = \\frac{n(n-1)}{2m} \\approx \\frac{n^2}{2m}\\]\n\n따라서 \\(\\sqrt{m}\\)개를 해시하였을 때 기대되는 충돌 개수는 0.5이며, \\(m = \\frac{n^2}{2}\\)을 하면 충돌 개수에 대한 기댓값이 1이 된다. 따라서 \\(m = n^2\\) 공간을 확보하면 평균적으로 하나 정도의 충돌만 발생하게 된다. 하지만 \\(m = n^2\\) 공간을 확보하면 공간 낭비가 많으며, 충돌이 특정 슬롯으로 집중되지 않으면 어느 정도 충돌이 발생하더라도 충돌을 처리하는 방법에 따라 우리가 기대하는 \\(O(1)\\) 성능을 얻을 수 있다. \n\n\\(n\\)개의 데이터를 저장할 때 기대되는 연산 수에 대한 실제적 분석은 너무 복잡하여 여기서 자세히 설명하지는 않는다. 하지만 이것을 분석하여 그래프로 표현해 보면 입력하는 데이터 개수가 증가하더라도 성능은 계속 \\(O(1)\\)을 유지하다가 \\(n/m \\ge 0.75\\) 이상이 되면 급격하게 증가하는 형태를 보여주고 있다. 따라서 \\(n/m < 0.75\\)로 계속 유지하면 우리가 기대한 \\(O(1)\\)의 성능을 유지할 수 있다. 이 때문에 입력할 데이터 개수 \\(n\\)을 알면 \\(m \\ge 1.3n\\)로 설정하면 우리가 기대하는 \\(O(1)\\) 성능을 얻을 수 있다. \n\n선형 조사 방법의 경우 해시 테이블의 용량이 뭉침 현상에 영향을 준다. 또 전체 위치를 조사하기 위해서는 선형 조사에서 더하는 상수 \\(c\\)는 해시 테이블의 용량과 서로 소이어야 한다. 보통 \\(a \\mod m = b\\)에서 \\(a\\)와 \\(m\\)이 공약수 \\(k\\)를 가지면 \\(b\\)는 \\(k\\)의 배수가 된다. 예를 들어 입력 데이터가 10, 20, 30, 40, 50이고 \\(m = 4\\)이면 \\(b\\)는 0이나면 2이다. 따라서 해시값과 \\(m\\)이 공약수를 가지면 충돌에 나쁜 영향을 줄 수 있다. 따라서 \\(m\\)을 소수로 선택하는 것이 바람직하다. 물론 입력 데이터가 균일하게 분포되어 있다면 \\(m\\)의 선택은 충돌에 영향을 주지는 않는다.",
    "source": "ds10_3.4_해싱-3.4 해시 테이블",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: 3.4 해시 테이블",
      "section_number": "3.4",
      "section_heading": "3.4 해시 테이블",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [
        "ds10/images/8_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0140"
  },
  {
    "type": "텍스트북",
    "text": "### 3.4.1 동적 해시 테이블",
    "source": "ds10_4.1_해싱-### 3.4.1 동적 해시 테이블",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.4.1 동적 해시 테이블",
      "section_number": "4.1",
      "section_heading": "### 3.4.1 동적 해시 테이블",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0141"
  },
  {
    "type": "텍스트북",
    "text": "입력할 데이터 개수 \\(n\\)을 모르면 충분한 크기로 확보한 후에 계속 \\(n/m\\) 비율을 관찰하여 이것이 0.75 이상이 되면 해시 테이블의 용량을 확장해야 한다. 이 확장은 일반 동적 배열과 마찬가지로 2배로 확장하면 평균 비용은 증가하지 않는다. 보통 보수적으로 \\(n/m\\)이 0.5 이상이 되었을 때 용량을 확장하는 경우도 많다. \n\n해시 테이블의 동적 확장은 저장된 기존 요소에 대한 해시값을 다시 계산해야 하기 때문에 리스트에서 살펴본 확장 비용보다 더 많은 비용이 소요된다. 따라서 이와 같은 부분을 충분히 고려하여 이 자료구조의 사용 여부를 결정해야 한다. 입력할 데이터 개수를 사전에 알 수 없다면 해시 집합, 해시 맵 대신에 균형 이전 검색 트리 기반 집합이나 맵을 사용하는 것이 바람직할 수 있다.",
    "source": "ds10_0.75_해싱-입력할 데이터 개수 \\(n\\)을 모르면 충분한 크기로 확보한 후에 계속 \\(n/m\\) 비율을 관찰하여 이것이 0.75 이상이 되면 해시 테이블의 용량을 확장해야 한다. 이 확장은 일반 동적 배열과 마찬가지로 2배로 확장하면 평균 비용은 증가하지 않는다. 보통 보수적으로 \\(n/m\\)이 0.5 이상이 되었을 때 용량을 확장하는 경우도 많다.",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: 입력할 데이터 개수 \\(n\\)을 모르면 충분한 크기로 확보한 후에 계속 \\(n/m\\) 비율을 관찰하여 이것이 0.75 이상이 되면 해시 테이블의 용량을 확장해야 한다. 이 확장은 일반 동적 배열과 마찬가지로 2배로 확장하면 평균 비용은 증가하지 않는다. 보통 보수적으로 \\(n/m\\)이 0.5 이상이 되었을 때 용량을 확장하는 경우도 많다.",
      "section_number": "0.75",
      "section_heading": "입력할 데이터 개수 \\(n\\)을 모르면 충분한 크기로 확보한 후에 계속 \\(n/m\\) 비율을 관찰하여 이것이 0.75 이상이 되면 해시 테이블의 용량을 확장해야 한다. 이 확장은 일반 동적 배열과 마찬가지로 2배로 확장하면 평균 비용은 증가하지 않는다. 보통 보수적으로 \\(n/m\\)이 0.5 이상이 되었을 때 용량을 확장하는 경우도 많다.",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0142"
  },
  {
    "type": "텍스트북",
    "text": "### 3.5 해상의 구현 \n\n배열로 해시 테이블을 만들어 사용하게 되는데, 이때 특정 슬롯이 비어 있는지 여부를 알 수 있어야 한다. 체이닝 방법은 각 슬롯이 연결구조 기반 리스트이므로 이 리스트가 빈 상태인지 여부를 통해 쉽게 슬롯이 비어 있는지 여부를 알 수 있다. 하지만 다른 경우에는 슬롯이 비어 있는지 알 수 있는 추가적인 방법이 필요하다. 적절한 초기값을 사용하여 빈 상태를 나타낼 수 있지만 범용적으로 사용하기에는 어렵다. 가장 간단한 방법은 해시 테이블을 저장할 데이터 타입과 슬롯의 빈 상태 여부를 나타내는 논리형 두 개의 맵비 변수로 구성된 구조체 배열로 만드는 것이다.\n\n\n<표 10.1> 해성을 이용한 기법 vs. 균형 이진 검색 트리를 이용한 기법 \n\n<table><tr><td></td><td>해성 기법</td><td>균형 이진 검색 트리 기법</td></tr><tr><td>구현 방법 가정</td><td>체이닝 기반 단일 기법</td><td>레드 블랙 트리와 같은 균형 이진 트리 기법</td></tr><tr><td>생성 주의사항</td><td>용량을 저장할 개수의 1.3배로 확보</td><td>없음</td></tr><tr><td>시간 복잡도</td><td>O(1)</td><td>O(log n)</td></tr><tr><td>추가 고려사항</td><td>해시 비용, 충돌 처리 비용, 용량 확장 비용</td><td>비교 비용</td></tr><tr><td>순서</td><td>저장된 데이터에 대한 순서 정보 없음</td><td>저장된 데이터에 대한 순서 정보 있음</td></tr><tr><td>데이터 요구사항</td><td>해시 함수, == 연산</td><td>비교 연산(&lt;)</td></tr></table>",
    "source": "ds10_3.5_해싱-### 3.5 해상의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.5 해상의 구현",
      "section_number": "3.5",
      "section_heading": "### 3.5 해상의 구현",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0143"
  },
  {
    "type": "텍스트북",
    "text": "### 3.5.1 해성을 이용한 기법과 균형 이진 검색 트리를 이용한 기법의 비교 \n\n해성을 내부적으로 이용하여 구현되는 자료구조 중에는 집합과 맥이 있다. 물론 집합과 맥은 해성 대신에 균형 이진 검색 트리를 이용하여 구현할 수 있다. 해성을 이용하면 삽입, 삭제, 검색이 평균적으로 O(1) 비용이 소요되지만 균형 이진 검색 트리를 이용하면 3개의 연산이 모두 O(log n)이 된다. 물론 해성을 이용할 경우 초기 용량을 잘 설정해야 하며, 해시 비용, 충돌 처리 비용 등 추가로 소요되는 비용도 있고, 용량을 확장해야 할 경우 비용이 많이 소요되는 단점도 있다. 따라서 앞서 언급한 바와 같이 적절한 초기 용량을 설정하기 어려우면 트리 기반 집합이나 맥을 사용하는 것이 더 유리할 수 있다. 또 균형 이진 검색 트리를 사용하면 순서 정보를 유지하고 있으므로 이에 대한 활용이 필요하면 해성보다는 균형 이진 검색 트리가 더 효과적일 수 있다. 두 방식을 비교하면 표 10.1와 같다.",
    "source": "ds10_5.1_해싱-### 3.5.1 해성을 이용한 기법과 균형 이진 검색 트리를 이용한 기법의 비교",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: ### 3.5.1 해성을 이용한 기법과 균형 이진 검색 트리를 이용한 기법의 비교",
      "section_number": "5.1",
      "section_heading": "### 3.5.1 해성을 이용한 기법과 균형 이진 검색 트리를 이용한 기법의 비교",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0144"
  },
  {
    "type": "텍스트북",
    "text": "## 3.6 기타 \n\n해시 테이블에 저장되는 요소들은 보통 충돌을 줄이기 위해 해시 테이블 내에 랜덤하게 분포된다. 따라서 특정 순서로 저장된 요소들을 차례로 방문하는 기능은 효과적으로 제공할 수 없다. 이것을 할 수 있도록 해시 집합이나 해시 맵에 기능을 추가한 자료구조도 있다. 예를 들어 자바의 LinkedInHashSet이 이와 같은 자료구조의 예이다. 해시 테이블 자체는 찾기, 삽입, 삭제만 효과적으로 제공하고 보통 동일한 키 값의 중복은 허용하지 않기 때문에 집합 자료구조를 구현할 때 해시 테이블을 많이 사용한다. 또한 키 값과 특정한 값을 연계하여 유지하는 맵도 해시 테이블을 이용하여 많이 구현된다.",
    "source": "ds10_3.6_해싱-기타",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "해싱: 기타",
      "section_number": "3.6",
      "section_heading": "## 3.6 기타",
      "parent_section": "3. 해싱",
      "parent_section_number": "3",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0145"
  },
  {
    "type": "텍스트북",
    "text": "## 4. 블룸 필터 \n\n해성을 이용한 해시 테이블은 충돌이 발생할 수 있기 때문에 데이터를 해시 테이블에 저장해야 한다. 주어진 데이 터가 테이블에 저장되어 있는지만 알면 되고, 거짓 양성(false negative) 결과를 주는 것을 허용할 수 있다면 해시 테이블을 이용하는 것보다 훨씬 적은 데이터 공간을 사용하지만 여전히 삽입과 검색을 모두 O(1)에 제공할 수 있다. 여기서 거짓 양성이란 삽입된 데이터가 아니지만 검색을 하였을 때 있다고 잘못 답변하는 것을 말한다. \n\n예를 들어 악성 사이트 목록이 주어져 있을 때, 이를 이용하여 악성 사이트 필터를 만들어야 한다고 생각하자. 균형 이진 검색 트리를 이용한 집합을 이용하면 공간 복잡도는 O(n)이고, 검색의 시간 복잡도는 O(log n)이다. 반면에 해성을 이용한 집합은 공간 복잡도는 O(n)이고, 검색의 시간 복잡도는 O(1)이다. 블룸 필터는 이와 같이 악성 사이트 필터를 해성을 이용한 집합 자료구조와 동일하게 O(1)에 삽입과 검색 기능을 제공하면서 상대적으로 적은 공간을 사용하여 제공할 수 있도록 해주는 자료구조이다. 다만, 해성을 이용한 집합 자료구조와 달리 데이터 자체를 저장하지 않으며, 삭제 연산을 보통 제공하지 않는다. 블룸 필터에서 삭제가 필요하면 그 요소를 제외하고 다시 만드는 것이 더 효과적이다. \n\n블룸 필터는 내부적으로 비트 벡터를 이용하며, 하나의 해시함수를 사용하지 않고, b개의 서로 독립적인 해시\n\n\n함수를 사용한다. 데이터를 삽입할 때 이 데이터에 대한 b개의 해시값을 구해 해당 위치를 모두 true로 설정한다.\n검색은 주어진 데이터에 대한 b개의 해시값을 구해 b개의 위치가 모두 true이면 true를 반환해준다. 이 때문에\n거짓양성 결과를 줄 수 있다. \n\n블룸 필터가 삭제 연산을 제공하기 어려운 이유는 특정 데이터를 삭제하기 위해서는 그 데이터를 저장할 때\n설정한 위치를 모두 false로 바꾸어야 하는데, 그 위치를 true로 설정한 데이터가 그 데이터가 유일한 것인지 알\n수 없기 때문이다. 따라서 앞서 언급한 것처럼 필요할 경우에는 필터를 그 데이터를 제외하고 다시 만드는 방법을\n보통 사용한다. 일반적으로 블룸 필터는 삭제가 필요없는 응용에서 많이 사용한다. \n\n거짓 양성이 높으면 블룸 필터를 사용하기 어렵다. 블룸 필터의 용량이 m이고, n개 데이터를 입력하였을 때,\n거짓 양성 확률 ε을 구할 수 있다. 이를 바탕으로 이 확률을 최소화하기 위한 해시함수의 수 b를 구할 수 있다. 실제\n구해보면 b = -log ε이다. 이를 바탕으로 블룸 필터를 만드는 절차는 다음과 같다. \n\n- 단계 1. 블룸 필터에 삽입할 요소의 개수 n를 추측한다. 잘 모르면 충분한 큰 크기로 예측한다. \n\n- 단계 2. 거짓 양성 확률 ε을 결정한다. 예를 들어 0.02로 결정하였다고 하자. \n\n- 단계 3. b = -log ε를 이용하여 b를 계산한다. ε = 0.02이면 b는 5 또는 6이어야 한다. \n\n- 단계 4. 블룸 테이블의 용량 m을 다음을 이용하여 결정한다. \n\n\\[m \\approx \\frac{n \\ln \\epsilon}{0.48} \\approx 8n\\]\n\n즉, 저장할 데이터의 8배 정도되는 용량이 필요하다. 그런데 블룸 필터는 내부적으로 비트 벡터를 사용하므로\n많은 공간이 필요한 것은 아니다.",
    "source": "ds10_4_블룸 필터",
    "meta_data": {
      "tables": [],
      "book_title": "제10장 집합, 맵 자료구조와 해싱",
      "chapter": "",
      "section": "블룸 필터",
      "section_number": "4",
      "section_heading": "## 4. 블룸 필터",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0146"
  },
  {
    "type": "텍스트북",
    "text": "### 1.1 기존 자료구조를 이용한 우선순위 큐의 구현 \n\n연결구조 기반 또는 배열 기반 비정렬 리스트를 이용할 경우 **add**는 \\(O(1)\\)이지만 **extract**는 \\(O(n)\\)이다. 배열 기반 정렬 리스트를 이용하면 **add**는 \\(O(n)\\)이지만 **extract**는 \\(O(1)\\)이다. 배열 기반 정렬 리스트로 우선순위 큐를 구현할 경우에는 우선순위가 가장 높은 것은 배열 맨 끝에 위치해야 **extract**가 \\(O(1)\\)이 된다. 연결구조 기반 정렬 리스트를 이용하여도 **add**는 \\(O(n)\\)이고 **extract**는 \\(O(1)\\)이다. 이 경우에는 배열 기반과 반대로 머리 노드에 가장 우선순위가 높은 것이 위치해야 한다. \n\n균형 이진 검색 트리를 이용하면 비용이 어떻게 될까? 균형 이진 검색 트리에서 최댓값은 루트에서 계속 오른쪽으로 이동하면 되고, 최솟값은 계속 왼쪽으로 이동하면 된다. 따라서 **add**는 \\(O(\\log n)\\)이고, **extract**는 \\(O(\\log n)\\)이다. 더욱이 가장 큰 값과 작은 값을 유지한 노드에 대한 포인터를 별도 유지하면 성능을 더 개선할 수 있다. 이보다 더 효과적으로 구현할 수 있는 방법은 없을까? **이진 힙**(binary heap)이라는 자료구조를 이용하면 성능을 더 개선할 수 있다.",
    "source": "ds11_1.1_### 1.1 기존 자료구조를 이용한 우선순위 큐의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "### 1.1 기존 자료구조를 이용한 우선순위 큐의 구현",
      "section_number": "1.1",
      "section_heading": "### 1.1 기존 자료구조를 이용한 우선순위 큐의 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0147"
  },
  {
    "type": "텍스트북",
    "text": "## 1.2 이진 힘 \n\n![](images/1_0.jpg)\n\n<center><그림 11.1> 이진 힘</center> \n\n이진 힘은 그림 11.1처럼 부모 노드 값이 항상 자식 노드 값보다 같거나 큰 이진 트리이다. 거꾸로 부모 노드 값이 항상 자식 노드 값보다 같거나 작도록 만들 수 있다. 이 특성을 힘 특성이라 한다. 두 경우 최댓값 또는 최솟값이 루트 노드에 존재하게 된다. 이진 힘은 이진 검색 트리와 달리 중복 데이터도 허용한다. 중복된 데이터가 있을 때 이것의 추출은 임의로 결정하게 된다. \n\n이진 힘에서 삽입은 이진 검색 트리와 마찬가지로 항상 단말 노드로 추가된다. 단말 노드로 추가되면 노드가 힘 특성을 만족하지 못할 수 있다. 따라서 부모 노드와 비교하여 힘 특성이 만족되지 않으면 서로 값을 바꾸어야 한다. 이 바꿈은 계속 루트 노드까지 올라가면서 반복될 수 있다. 이 과정을 reheap up, bubble up, sift up이라 한다. 이 과정이 끝나면 다시 모든 노드가 힘 특성을 만족하게 된다. 따라서 트리가 균형이면 삽입 비용은 O(log n)이다. \n\n최댓값과 최솟값은 루트 노드에 있으므로 최댓값과 최솟값은 언제든지 바로 알 수 있다. 이 값의 추출은 이 노드의 값과 단말 노드의 값 하나와 바꾼다. 이렇게 바꾸고 해당 단말 노드는 삭제한다. 이 경우 힘 특성이 만족되지 않을 수 있다. 따라서 새 루트 노드 값과 두 개의 자식 노드 값과 비교하여 두 자식 노드 중 하나와 값을 바꾸게 되며, 이 바꿈도 단말 노드까지 내려가면서 반복될 수 있다. 이 과정을 reheap down, bubble down, sift down이라 한다. 기존 reheap up과 마찬가지로 이 과정이 끝나면 모든 노드가 힘 특성을 만족하게 되며, 트리가 균형이면 우선순위가 가장 높은 값의 추출 비용도 O(log n)이다. \n\nchangePriority와 remove 연산은 데이터가 트리에 어디에 있는지 알아야 한다. 둘다 데이터가 어디에 있는지 알고 있다고 가정하고 구현하는 방법을 생각하여 보자. 우선순위 변경은 값을 변경한 후에 우선순위가 높아 젖는지 또는 낮아졌는지에 따라 그 위치에서 reheap up 또는 reheap down을 하면 된다. remove는 단말 노드 값과 교체하고 해당 단말을 삭제한 뒤에 원래 위치에서 reheap down을 하면 된다.",
    "source": "ds11_1.2_이진 힘",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘",
      "section_number": "1.2",
      "section_heading": "## 1.2 이진 힘",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds11/images/1_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0148"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 이진 힘의 구현 \n\n이진 검색 트리는 노드가 있을 때 그것에 왼쪽과 오른쪽에 올 수 있는 값에 제약이 있지만 이진 힘은 그것이 없고 부모와 자식 간의 제약만 존재한다. 이 때문에 완전 이진 트리로 데이터를 유지할 수 있다. 완전 이진 트리는 마지 막 레벨을 제외하고 꽉 채워진 형태이고, 마지막 레벨의 단말 노드들은 왼쪽에서부터 채워진 형태의 이진 트리를 말한다. \n\n완전 이진 트리로 데이터를 유지하면 트리의 높이가 최적이 되며, 노드를 연결하는 형태로 트리를 구성하지 않고 배열로 트리를 유지할 수 있다. 배열로 트리를 유지하면 노드가 저장되어 있는 배열 색인으로부터 그것의 부모와 자식 노드가 저장되는 있는 배열의 색인을 계산할 수 있다. 배열로 유지하면 트리의 단말에 접근하기도 매우 편리 하다. 배열의 맨 끝에 있는 노드는 항상 무조건 단말 노드에 해당한다. 또 배열의 첫 번째 색인에 있는 노드는 루트 노드가 되며, 여기에 우선순위가 가장 높은 데이터가 저장되어 있다. 실제 이진 힘에서는 루트 노드와 단말 노드에\n\n\n빠르게 접근할 수 있으면 각종 연산을 효과적으로 구현할 수 있다. \n\n배열로 이진 트리를 표현하면 한 가지 단점이 있다. 현재 위치에서 배열의 용량을 확장할 수 없으므로 기존 배열 기반 리스트처럼 현재 용량이 부족하면 동적 배열 기법을 사용하여 용량을 확장해야 한다. 따라서 이진 힙도 배열 기반 다른 모든 자료구조와 마찬가지로 초기에 적절한 용량을 확보해 주어야 효과적이다. \n\n![](images/2_0.jpg)\n\n \n\n<center><그림 11.2> 완전 이진 트리 형태의 이진 힙</center> \n\n완전 이진 트리를 배열로 유지하고 0색인을 사용할 때 색인 i가 주어지면 그것의 부모 노드가 위치한 색인은 (i - 1)/2이며, 왼쪽 자식 노드가 위치한 색인은 2i + 1이다. 또 오른쪽 색인은 왼쪽 색인에 +1하면 얻을 수 있다. 그림 11.2과 같은 완전 이진 트리 형태의 이진 힙에 대한 배열 표현은 다음과 같다. \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>값</td><td>16</td><td>12</td><td>14</td><td>5</td><td>6</td><td>11</td><td>7</td><td>2</td><td>3</td></tr></table>",
    "source": "ds11_2_이진 힘의 구현",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현",
      "section_number": "2",
      "section_heading": "## 2. 이진 힘의 구현",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds11/images/2_0.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0149"
  },
  {
    "type": "텍스트북",
    "text": "## 2.1 삽입 연산 \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>값</td><td>16</td><td>12</td><td>14</td><td>5</td><td>6</td><td>11</td><td>7</td><td>2</td><td>3</td><td>15</td></tr></table>\n\n(1) 새 데이터 15를 추가함 \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>값</td><td>16</td><td>12</td><td>14</td><td>5</td><td>6</td><td>11</td><td>7</td><td>2</td><td>3</td><td>6</td></tr></table>\n\n(2) 부모 색인 4 위치에 있는 것과 비교 \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>값</td><td>16</td><td>15</td><td>14</td><td>5</td><td>12</td><td>11</td><td>7</td><td>2</td><td>3</td><td>6</td></tr></table>\n\n(3) 부모 색인 1 위치에 있는 것과 비교 \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>값</td><td>16</td><td>15</td><td>14</td><td>5</td><td>12</td><td>11</td><td>7</td><td>2</td><td>3</td><td>6</td></tr></table>\n\n(4) 부모 색인 0 위치에 있는 것과 비교 \n\n<그림 11.3> 그림 11.2에 15의 추가 \n\n이진 힙에서 데이터의 삽입은 단말로 추가한 다음 reshape up을 진행하면 된다. 그림 11.2에서 15를 추가하는 과정은 다음과 같다. 먼저 색인 9에 15를 추가한다. 항상 데이터의 추가는 이처럼 배열 끝에 추가하게 된다. 그다음 부모 색인을 계산하면 (9 - 1)/2 = 4이므로 6과 비교하게 된다. 6보다 15가 크므로 서로 값을 바꾼다. 그다음 그 위치에서 부모 색인을 다시 계산한다. (4 - 1)/2 = 1이므로 12와 비교하게 된다. 역시 15가 더 크므로 서로 값을\n\n\n1 add(item): \n\n2 if numItems == capacity then increaseCapacity() \n\n3 heap[numItems] := item \n\n4 reheapUp(numItems) \n\n5 ++numItems \n\n6 \n\n7 reheapup(index): \n\n8 while index > 0 do \n\n9 parentIdx := (index-1)/2 \n\n10 if heap[parentIdx] < heap[index] then swap(heap[parentIdx], heap[index]) \n\n11 else return \n\n12 index := parentIndex \n\n<그림 11.4> 이진 힙: add와 reheapup 메소드 \n\n바꾼다. 그다음 부모는 (1 - 1)/2 = 0이므로 16과 비교하게 되고, 16보다 작으므로 reheap up 과정은 종료된다. 이 과정을 배열의 변화로 나타내면 그림 11.3과 같다. add 연산과 reheapup 연산의 의사코드는 그림 11.4와 같다.",
    "source": "ds11_2.1_이진 힘의 구현-삽입 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: 삽입 연산",
      "section_number": "2.1",
      "section_heading": "## 2.1 삽입 연산",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0150"
  },
  {
    "type": "텍스트북",
    "text": "## 2.2 extract 연산 \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>값</td><td>3</td><td>12</td><td>14</td><td>5</td><td>6</td><td>11</td><td>7</td><td>2</td><td>16</td></tr></table>\n\n(1) 가장 끝 단말과 루트를 교체한다 \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>값</td><td>14</td><td>12</td><td>3</td><td>5</td><td>6</td><td>11</td><td>7</td><td>2</td><td>16</td></tr></table>\n\n(2) 두 자식 중 큰 것에 해당하는 14와 비교한다. \n\n<table><tr><td>색인</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>값</td><td>14</td><td>12</td><td>11</td><td>5</td><td>6</td><td>3</td><td>7</td><td>2</td><td>16</td></tr></table>\n\n(3) 두 자식 중 큰 것에 해당하는 11과 비교한다. \n\n<그림 11.5> 그림 11.2에 16의 추출 \n\nextract 연산은 배열 가장 끝에 있는 값을 루트 노드와 바꾼 후 reheap down을 진행하면 된다. 그림 11.2에서 가장 우선순위가 높은 값을 추출하는 과정은 다음과 같다. 먼저 16과 3을 바꾼다. 그다음 numItems를 하나 감소한 뒤에 reheap down을 진행한다. 루트 노드의 왼쪽과 오른쪽 색인이 1과 2이므로 12와 14를 비교하여 더 큰 값이 14 와 3을 비교하게 되고, 14가 3보다 크므로 14와 3을 바꾼다. 그다음 색인 2의 왼쪽과 오른쪽 색인이 5와 6이므로 11 과 7를 비교하여 더 큰 값이 11과 3을 비교한다. 11이 더 크므로 11과 3을 바꾼다. 11의 왼쪽 자식 색인은 11이므로 현재 배열 범위를 벗어나기 때문에 reheap down은 끝난다. 이 과정을 배열의 변화로 나타내면 그림 11.5와 같다.",
    "source": "ds11_2.2_이진 힘의 구현-extract 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: extract 연산",
      "section_number": "2.2",
      "section_heading": "## 2.2 extract 연산",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0151"
  },
  {
    "type": "텍스트북",
    "text": "## 2.3 changePriority와 remove 연산 \n\nchangePriority와 remove 연산도 우선순위를 변경하고자 하는 데이터의 위치나 삭제할 데이터의 위치를 알면 reheapup 또는 reheapdown 연산을 통해 효과적으로 제공할 수 있다. 하지만 특정 데이터가 어디에 있는지 별도 유지하지 않으면 changePriority와 remove 연산은 데이터가 있는 위치부터 찾아야 한다. 이것은 데이터를 유지하고 있는 배열에 대한 선형 검색이 필요하다. 이 비용을 개선하기 위해 값과 값의 위치를 유지하는 맵 자료구\n\n\n1 extract(item):\n2 if isEmpty() then throw IllegalArgumentException\n3 ret := heap[0]\n4 swap(heap[0], heap[numItems-1])\n5 --numItems\n6 reheapdown(0)\n7 return ret\n8\n9 reheapdown(index):\n10 while index<numItems do\n11 leftIdx := 2*index + 1\n12 rightIdx := leftIdx + 1\n13 if leftIdx>=numItems then return\n14 maxChildIdx := leftIdx\n15 if rightIdx < numItems and heap[leftIdx] < heap[rightIdx] then\n16 maxChildIdx := rightIdx\n17 if heap[maxChildIdx]>heap[index] then swap(heap[maxChildIdx], heap[index])\n18 else return\n19 index := maxChildIdx \n\n<그림 11.6> 이진 팀: extract와 reheapdown 메소드 \n\n조를 추가로 사용할 수 있지만 데이터가 삽입, 추출, 우선순위 변경, 삭제될 때마다 갱신되어야 하므로 추가 사용에 대한 이득이 별로 없다. 더욱이 팀은 중복된 요소를 허용하기 때문에 이를 처리하는 방법도 모호하다. 이 때문에 라이브러리에서 우선순위 큐는 이들 연산을 제공하지 않는다.",
    "source": "ds11_2.3_이진 힘의 구현-changePriority와 remove 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: changePriority와 remove 연산",
      "section_number": "2.3",
      "section_heading": "## 2.3 changePriority와 remove 연산",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0152"
  },
  {
    "type": "텍스트북",
    "text": "## 2.4 heapify 연산 \n\n<table><tr><td>4</td><td>7</td><td>0</td><td>3</td><td>9</td><td>17</td><td>19</td><td>6</td><td>2</td></tr><tr><td>4</td><td>7</td><td>0</td><td>6</td><td>9</td><td>17</td><td>19</td><td>3</td><td>2</td></tr><tr><td>4</td><td>7</td><td>19</td><td>6</td><td>9</td><td>17</td><td>0</td><td>3</td><td>2</td></tr><tr><td>4</td><td>9</td><td>19</td><td>6</td><td>7</td><td>17</td><td>0</td><td>3</td><td>2</td></tr><tr><td>19</td><td>9</td><td>17</td><td>6</td><td>7</td><td>4</td><td>0</td><td>3</td><td>2</td></tr></table>\n\n<그림 11.7> 그림 11.2에 15의 추가 \n\nn개의 데이터로 구성된 이진 팀을 만드는 비용은 어떻게 될까? n번의 add 연산을 수행하면 쉽게 이진 팀을 만들 수 있다. 하지만 이렇게 하면 그 비용이 \\(O(n \\log n)\\)이다. 실제 이보다 더 효율적으로 이진 팀을 만들 수 있다. 주어진 n개 데이터를 우선 배열에 차례로 저장한다. 이 비용은 \\(O(n)\\)이다. 하지만 이렇게 저장한다고 이진 팀이 되지는 않는다. 배열에 있는 요소들이 팀 특성을 만족하도록 위치를 조정해 주어야 한다. 맨 뒤부터 reheap up을 하거나 맨 앞에서부터 reheap down을 하는 것은 그 과정을 통해 이진 팀을 만들 수 있다고 하더라도 앞서 살펴본 직관적 방법과 비교하여 비용의 차이가 없다. 그런데 첫 번째 중간 노드부터 reheap down을 하면 이진 팀을 만들 수 있을 뿐만 아니라 전체 중 절반 정도만 reheap down을 통해 이진 팀을 구성할 수 있다. 그림 11.7은 주어진 배열을 이 방법을 통해 이진 팀을 구성하는 과정을 보여주고 있다. \n\n앞서 언급한 바와 같이 중간 노드들만 reheap down하면 이진 팀을 구성할 수 있으며, 중간 노드의 수는 대략 \\(\\frac{n}{2}\\)이고 reheap down의 비용은 \\(O(\\log n)\\)이므로 여전치 전체 비용은 \\(O(n \\log n)\\)이라고 생각할 수 있다. 그런데 실제\n\n\n수행되는 연산의 수를 생각하여 보자. 2보다 적은 수의 노드 높이는 1이다. 또 4보다 적은 수의 노드 높이는 2이다. 이와 같이 reheap down해야 하는 것의 높이는 점점 높아져 루트 노드가 되었을 때 높이가 log n이 된다. reheap down의 비용은 높이에 비례하므로 전체 비용은 다음과 같다¹ \n\n\\[\n\\text{cost} \\le \\frac{n}{2} \\times 1 + \\frac{n}{4} \\times 2 + \\frac{n}{8} \\times 3 + \\cdots \\le n \\sum_{i=1}^{h} \\frac{i}{2^i} \\le n \\sum_{i=0}^{\\infty} ix^i = n \\frac{x}{(x-1)^2} = 2n\n\\]\n\n따라서 이와 같은 방법으로 이진 힘을 구성하는 비용은 O(n)이다. 기존 배열에 저장된 데이터를 이진 힘이 되도록\n바꾸는 이 연산을 heapify라 한다.",
    "source": "ds11_2.4_이진 힘의 구현-heapify 연산",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: heapify 연산",
      "section_number": "2.4",
      "section_heading": "## 2.4 heapify 연산",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0153"
  },
  {
    "type": "텍스트북",
    "text": "## 2.5 이진 힘 vs. 균형 이진 검색 트리 \n\n이진 힘은 내부적으로 배열로 구현하지만 균형 이진 검색 트리는 포인터를 이용한 연결구조 형태로 구현한다. 따\n라서 이진 힘은 연속 공간에 데이터를 유지하기 때문에 개성에 더 유리할 수 있다. 하지만 초기 용량을 적절하게\n확보하지 못하면 동적 배열 기법의 사용이 필요하다. 트리 높이는 이진 힘이 최적이다. 주어진 데이터로 더 짧은\n높이의 이진 트리를 구성할 수 없다. n개의 데이터로 이진 힘을 구성하는 비용은 O(n)인 반면 균형 이진 검색 트리는\nO(n log n)이 필요하다. 이진 힘에서 데이터 삽입 비용은 O(log n)이며, 구체적으로 배열 맨 끝에 데이터를 추가한\n다음 reheap up 연산을 수행하게 된다. 균형 이진 검색 트리의 경우에는 균형 이진 검색 트리에 따라 조금 다르지만\nAVL의 경우 단말로 삽입한 후에 루트 노드까지 올라가면서 조정을 위한 회전이 필요하다. 둘 다 O(log n)이지만 트\n리의 높이와 내부적으로 일어나는 연산을 고려하면 이진 힘이 훨씬 효과적이다. 최댓값, 최솟값을 추출하는 비용도\n유사하게 분석할 수 있다. 둘 다 O(log n)이지만 트리의 높이와 내부적으로 일어나는 연산을 고려하면 이진 힘이 더\n효과적이다. 이진 힘은 중복된 요소를 유지하지만 균형 이진 검색 트리는 그것의 특성 측면에서 보통 중복된 요소를\n유지하지 않는다. \n\n모든 것이 이진 힘이 좋은 것은 아니다. 이진 힘은 데이터 검색을 제공하지 않는다. 트리의 상하 관계만 존재하기\n때문에 배열에서 선형 검색하는 것 외에는 효과적으로 검색할 수 있는 방법이 없다. 반면에 균형 이진 검색 트리는\nO(log n)에 데이터의 유무를 알 수 있으며, 선행과 후속 요소, 가장 가까운 이웃 찾기, 구간 검색 등도 효과적으로\n할 수 있다. \n\n# 3. 힙의 응용",
    "source": "ds11_2.5_이진 힘의 구현-이진 힘 vs. 균형 이진 검색 트리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: 이진 힘 vs. 균형 이진 검색 트리",
      "section_number": "2.5",
      "section_heading": "## 2.5 이진 힘 vs. 균형 이진 검색 트리",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0154"
  },
  {
    "type": "텍스트북",
    "text": "## 3.1 힙 정렬 \n\n기본적인 정렬 알고리즘 중에 선택 정렬(selection sort) 알고리즘이 있다. 이 알고리즘은 반복적으로 정렬이 안\n된 요소 중에 가장 작은 요소를 찾아 그것의 위치로 이동하여 정렬한다. 이 알고리즘의 시간 복잡도는 O(n²)이다.\n그런데 이 알고리즘은 반복적으로 최솟값 또는 최댓값을 찾는다. 문제 해결이 반복적으로 최솟값 또는 최댓값을\n찾아야 하면 우선순위 큐의 사용을 생각해 볼 수 있다. 이진 힘에 정렬할 데이터가 저장되어 있으면 extract\n연산을 반복적으로 호출하여 데이터를 정렬할 수 있다. 이 경우 비용은 O(n log n)이다. 비교 기반 정렬 알고리즘은\nO(n log n)보다 좋을 수 없기 때문에 이와 같은 방법의 정렬 알고리즘은 가장 우수한 정렬 알고리즘과 시간 복잡도\n측면에서 차이가 없다. \n\n힙 정렬은 배열에 정렬할 데이터가 있을 때 이를 heapify 연산을 이용하여 이진 힘으로 바꾼 다음에 첫 번\n째 색인에 있는 것을 맨 뒤와 교체하는 것을 반복하여 정렬하는 알고리즘이다. 이 방식의 힙 정렬은 추가 공간을\n사용하지 않는 이점도 있다.",
    "source": "ds11_3.1_이진 힘의 구현-힙 정렬",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: 힙 정렬",
      "section_number": "3.1",
      "section_heading": "## 3.1 힙 정렬",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0155"
  },
  {
    "type": "텍스트북",
    "text": "## 3.2 이진 힘 vs. 정렬 \n\n주어진 데이터를 특정 기준에 따라 차례로 하나씩 처리해야 할 때 다음과 같은 방법을 사용할 수 있다. \n\n 방법 1. 데이터를 임의 접근을 제공하는 배열에 저장한 후에 기준에 따라 정렬한 후 하나씩 처리한다. \n\n 방법 2. 이진 힘에 데이터를 저장한 후에 하나씩 추출하여 처리한다. \n\n방법 2는 주어진 데이터를 빈 힘에 저장할 수 있고(방법 2-1), 임의 접근을 제공하는 배열에 저장한 후에 heapify 연산을 사용하여 이진 힘을 만들어 사용(방법 2-2)할 수 있다. 방법 1과 방법 2을 시간 복잡도와 공간 복잡도 측면에서 비교하여 보자. \n\n방법 1에서 데이터를 배열에 저장하는 비용은 O(n)이고, 이 배열을 정렬하는 비용은 O(n log n)이다. 그다음 하나씩 색인을 이용하여 차례로 접근하는 비용은 O(n)이다. 방법 2-1에서 n개 데이터를 빈 힘에 삽입하는 비용은 O(n log n)이고, 이 데이터를 모두 추출하는 비용은 O(n log n)이다. 하지만 방법 2-2에서 데이터를 배열에 저장 하고 heapify 연산을 수행하는 비용은 O(n)이다. 보통 방법 2-2를 사용하고자 하면 우선순위 큐를 사용할 수 없고, 직접 heapify 연산과 extract 연산을 만들어 사용해야 한다. C++를 이를 지원하는 std::make_heap, pop_heap 함수를 라이브러리로 제공해주며, 파이썬 3의 heapq는 heapify 연산을 제공해 준다. 방법 2-1은 데이터를 유지하는 배열과 힘이 별도 존재할 수 있으므로 다른 방법들에 비해 2배의 공간을 사용할 수 있다. \n\n결론적으로 주어진 데이터를 특정 기준에 따라 하나씩 차례로 처리해야 하면 주어진 데이터를 정렬하여 사용하 거나 주어진 데이터가 리스트나 배열로 주어지면 그 자체를 heapify하여 사용해야 효과적이다. 이 경우 사용하는 언어에 따라 라이브러리에서 이를 제공하지 않으면 정렬하여 사용하는 것이 효과적이다.",
    "source": "ds11_3.2_이진 힘의 구현-이진 힘 vs. 정렬",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: 이진 힘 vs. 정렬",
      "section_number": "3.2",
      "section_heading": "## 3.2 이진 힘 vs. 정렬",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0156"
  },
  {
    "type": "텍스트북",
    "text": "## 3.3  중간값 찾기 \n\n일련의 정수가 지속적으로 주어진 페마다 지금까지 주어진 데이터의 중간값을 알고 싶다. 배열 기반 비정렬 리스트 를 이용하여 이 문제를 해결하고자 하면 삽입 비용은 O(1)이지만 중간값을 찾는 비용은 O(n)이 소요된다. 비정렬 리스트에서 중간값은 빠른 정렬을 응용한 빠른 선택 알고리즘을 이용하여 O(n)에 찾을 수 있다. 배열 기반 정렬 리스트를 이용하면 삽입 비용은 O(n)이지만 중간값은 항상 O(1)에 찾을 수 있다. 살펴본 두 가지 방법은 필요한 두 개의 연산 중 하나는 매우 효과적으로 제공해주지만 다른 하나는 선형 비용이 필요한 단점이 있다. 이 문제를 이진 힘을 이용하여 어떻게 개선할 수 없을까? \n\n이 문제는 하나의 이진 힘이 아니라 두 개의 이진 힘을 사용하면 효과적으로 해결할 수 있다. n개의 요소가 있을 때 정렬된 상태를 가정하여 왼쪽 절반은 maxheap에 오른쪽 절반은 minheap에 유지할 수 있으면 항상 중간값을 상수 시간을 찾을 수 있다. 이를 위해 다음 3가지 규칙에 따라 새 데이터를 maxheap 또는 minheap에 삽입한다. \n\n 규칙 1. maxheap의 가장 큰 값보다 작으면 maxheap에 삽입한다. \n\n 규칙 2. minheap의 가장 작은 값보다 크면 minheap에 삽입한다. \n\n• 규칙 3. 규칙 1과 2를 적용하였을 때 두 힙의 크기 차이가 2가 되면 더 큰 쪽에 있는 가장 큰 값 또는 작은 값을 다른 힙으로 이동한다. \n\n최악의 경우 데이터 삽입 비용은 두 번의 이진 힘 add 연산이 필요하다. 따라서 두 개의 이진 힘을 이용하면 삽입은 O(log n)에 제공할 수 있고, 중간값은 O(1)에 제공할 수 있다.",
    "source": "ds11_3.3_이진 힘의 구현-중간값 찾기",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "",
      "section": "이진 힘의 구현: 중간값 찾기",
      "section_number": "3.3",
      "section_heading": "## 3.3  중간값 찾기",
      "parent_section": "2. 이진 힘의 구현",
      "parent_section_number": "2",
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0157"
  },
  {
    "type": "텍스트북",
    "text": "## 1. 개요 \n\n그래프는 트리보다 상위 개념으로 노드(node, vertex)와 노드를 연결하는 간선(edge)에 의해 정의된다. V가 노드의 집합이고 E가 간선의 집합일 때, 그래프는 G = (V, E)로 정의된다. 보통 주어진 그래프 G의 노드 수와 간선 수는 n과 m을 이용하여 나타낸다. 현재 우리는 GPS와 지도 앱을 활용하여 출발지에서 목적지까지 최단 경로를 확보할 수 있으며, 이를 이용하여 원하는 목적지까지 편하게 찾아 갈 수 있다. 보통 이와 같은 최단 경로는 그래프로 표현된 자료구조에서 한 노드에서 다른 노드까지의 최단 경로를 찾는 알고리즘을 이용한다.",
    "source": "ds12_1_개요",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "개요",
      "section_number": "1",
      "section_heading": "## 1. 개요",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0158"
  },
  {
    "type": "텍스트북",
    "text": "## 2. 그래프의 종류 \n\n![](images/0_0.jpg)\n\n![](images/0_1.jpg)\n\n![](images/0_2.jpg)\n\n![](images/0_3.jpg)\n\n(1) 무방향 그래프 \n\n(2) 방향 그래프 \n\n(3) 가중치 그래프 (4) 다중 그래프 \n\n<그림 12.1> 그래프의 종류 \n\n그래프는 간선의 방향성, 간선의 가중치 여부, 병행 간선(parallel edge) 존재 여부에 따라 그림 12.1와 같이 분류 할 수 있다. 간선의 방향이 없으면 무방향(undirected) 그래프라 하고, 방향이 있으면 방향 그래프(directed graph, digraph)라 한다. 방향 그래프에서 간선을 다른 말로 아크(arc)라고도 한다. 방향 그래프에서 간선은 시작 노드와 끝 노드를 가지게 된다. 간선에 특정 값이 부여되는 경우도 있고 그렇지 않는 경우도 있다. 전자를 가중치(weighted) 그래프라 하고, 후자를 비가중치 그래프라 한다. 두 노드를 연결하는 간선이 여러 개 존재할 수 있는 그래프를 다중 그래프(multigraph)라 하고, 이와 같은 간선을 병행 간선이라 한다.",
    "source": "ds12_2_그래프의 종류",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "그래프의 종류",
      "section_number": "2",
      "section_heading": "## 2. 그래프의 종류",
      "parent_section": null,
      "parent_section_number": null,
      "images": [
        "ds12/images/0_0.jpg",
        "ds12/images/0_1.jpg",
        "ds12/images/0_2.jpg",
        "ds12/images/0_3.jpg"
      ],
      "script": ""
    },
    "id": "자료구조_교재_0159"
  },
  {
    "type": "텍스트북",
    "text": "## 3. 용어 \n\n인접(adjacent) 노드란 간선에 의해 연결된 노드를 말하며, 무방향 그래프에서는 간선에 의해 연결된 두 노드는 항상 서로의 인접 노드가 되지만 방향 그래프에서는 간선의 끝 노드는 시작 노드의 인접 노드이지만 그 반대는 끝 노드에서 시작 노드를 잇는 또 다른 간선이 없으면 인접 노드가 아니다. 인접성은 보통 두 노드 간의 관계를 나타내기\n\n\n위해 사용되지만 간선과 노드 간의 관계를 나타내기 위해 사용될 때도 있다. 방향 그래프에서 간선은 소스 노드의\n인접 간선이 되지만 무방향에서 간선은 시작 노드와 끝 노드 모두의 인접 간선이 된다. \n\n노드의 차수(order)란 노드와 연결된 간선의 수를 말하며, 방향 그래프에서는 진입 차수(\\(indegree\\))와 진출 차수\n(outdegree)로 나누어 고려한다. \n\n경로(path)란 두 개의 노드를 연결하는 일련의 노드들을 말하며, 노드 \\(a\\)에서 \\(b\\)까지의 경로가 \\(a, v_1, v_2, \\dots, v_k\\),\n\\(b\\)라 하면 간선 \\((a, v_1), (v_1, v_2), \\dots, (v_k, b)\\)가 존재해야 한다. 비가중치 그래프에서 \\(a\\)에서 \\(b\\)까지의 경로의 길이는\n간선의 수로 계산되며, 가중치 그래프에서는 경로를 구성하는 가중치의 합으로 계산된다. 주어진 경로에서 첫 번째\n노드와 마지막 노드가 같은면 이 경로를 주기(cycle)라 한다. 단순 경로(simple path)는 한 노드를 두 번 거치지 않는\n경로를 말한다. 따라서 단순 경로는 주기가 없는 경로를 말한다. \n\n연결 그래프(connected graph)란 서로 다른 임의의 두 노드 사이에 경로가 항상 존재하는 그래프를 말한다.\n임의의 노드에서 출발하여 깊이 우선이나 너비 우선 탐색을 통해 방문할 수 있는 노드의 집합이 항상 전체 노드\n집합과 같은면 연결 그래프이다. 무방향 그래프의 경우에는 모든 노드를 검사하지 않고 하나의 노드에서 탐색을\n해보아도 그래프의 연결 여부를 알 수 있다. \\(n\\)개 노드로 구성된 무방향 연결 그래프의 최소 간선의 수는 \\(n-1\\)\n이다. 방향 그래프에서는 약한 연결 그래프와 강한 연결 그래프 개념이 있다. 약한 연결은 연결 그래프가 아니지만\n간성의 방향을 모두 제거하였을 때 연결 그래프가 되는 그래프를 말한다, 방향 그래프에서 루트 연결 그래프(rooted\ndigraph) 개념도 있다. 루트 연결 그래프는 한 노드에서는 다른 모든 노드로 경로가 존재하는 그래프를 말하며, 이\n노드를 해당 그래프의 루트라 한다. \n\n완전 그래프(complete graph)란 모든 노드는 다른 노드의 인접 노드가 되는 그래프를 말한다. 따라서 간선의\n시작과 끝 노드가 같은 간선을 고려하지 않고 다중 그래프가 아니면 완전 방향 그래프는 총 \\(n(n-1)\\)개의 간선이\n있고, 완전 무방향 그래프는 \\(n(n-1)/2\\)개의 간선이 있다. 이것이 같은 조건의 그래프가 가질 수 있는 최대 간선\n수이다. 참고로 다중 그래프를 고려하지 않고, 간선의 시작과 끝 노드가 같은 간선이 존재할 수 있다면 방향 그래프에\n존재할 수 있는 간선의 최대 수는 \\(n^2\\)이고, 간선의 최소 수는 0이다. 그래프의 간선 수가 최대 간선 수에 가까우면\n밀집(dense) 그래프라 하고, 반대로 최소 간선 수에 가까우면 최소(sparse) 그래프라 한다. \n\n그래프 \\(G = (V, E)\\)가 있을 때 \\(V' \\subseteq V\\), \\(E' \\subseteq E\\)인 그래프 \\(G'(V', E')\\)를 \\(G\\)의 부분 그래프라 한다. 그래프의 부분\n그래프 중 원래 그래프의 모든 노드를 포함하는 트리를 신장 트리(spanning tree)라 한다. 신장 트리는 항상 \\(n-1\\)\n개의 간선으로 구성된다. 가중치 그래프에는 최소 비용 신장 트리(MST, Minimum Spanning Tree)가 정의될 수\n있으며, 최소 비용 신장 트리는 신장 트리 중 간선의 가중치 합이 가장 작은 신장 트리를 말한다. \n\n4. 그래프의 구현 \n\n그래프는 크게 인접 행렬(adjacent matrix)을 이용하거나 인접 리스트를 이용하여 표현한다. 인접 행렬의 공간\n복잡도는 항상 \\(O(n^2)\\)이다. 또한 무방향 그래프의 경우에는 항상 대칭 행렬이 되기 때문에 정보가 중복 표현되며,\n최소 그래프의 경우에는 낭비되는 공간이 많다. 가중치 그래프를 인접 행렬로 표현할 경우에는 가중치 값의 범위에\n따라 간선이 없는 경우를 어떤 값으로 표현할 것인지 결정해야 한다. 보통 음의 가중치가 없는 그래프에서는 -1\n을 사용하는 경우도 있고, 가중치의 범위가 제한적이면 매우 큰 수를 이용하는 경우도 있다. 또 그래프의 적용해야\n하는 알고리즘에 따라 더 적합한 값이 있을 수 있다. \n\n마땅한 값으로 간선이 없다는 것을 나타내기 힘든 경우에는 두 개의 배열이나 가중치와 존재 유무를 나타내는\n두 개의 값으로 구성된 구조체 배열을 사용할 수 있다. 이 경우에는 공간 복잡도가 더 증가하므로 인접 행렬 대신에\n인접 리스트를 이용하는 것이 더 효과적일 수 있다. \n\n최소 그래프는 인접 리스트를 이용하여 표현하는 것이 공간 복잡도 측면에서 효과적이다. 인접 리스트의 공간\n복잡도는 \\(O(n+m)\\)이다. 특히, 무방향 그래프는 역인접 리스트가 없어도 노드의 진출 정보와 진입 정보를 모두 알\n\n\n수 있기 때문에 효과적이다. 반면에 방향 그래프에서 진입 노드 정보가 필요하면 역인접 리스트의 유지가 필요하다. 이 경우에는 역인접 리스트를 추가하는 것보다 인접 행렬을 사용하는 것이 더 효과적일 수 있다. 반면에 방향 그래프이지만 응용에 따라 역인접 리스트가 필요 없으면 여전히 인접 리스트를 사용하는 것이 효과적일 수 있다. 인접 리스트의 경우 리스트의 리스트로 나타낼 수 있고, 노드 레이블과 리스트 쌍으로 구성된 맵으로 표현할 수도 있다.",
    "source": "ds12_3_용어",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "용어",
      "section_number": "3",
      "section_heading": "## 3. 용어",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0160"
  },
  {
    "type": "텍스트북",
    "text": "## 5. 깊이 우선, 너비 우선 탐색 \n\n1 DFS(G, v. visited)  2 visited[node] := true  3 for each adjacent node w of v do  4 if not visited[w] then DFS(G, w, visited) \n\n<그림 12.2> 재귀호출을 이용한 DFS \n\n1 DFS(G)  2 visited[v] := false for all v  3 S := empty stack  4 s := starting node  5 S.push(s)  6 visited[s] := true  7 while S is not empty do  8 v := S.pop()  9 for each adjacent node w of v do  10 if not visited[w] then  11 visited[w] := true  12 S.push(w) \n\n<그림 12.3> 스택을 이용한 DFS \n\n1 BFS(G)  2 visited[v] := false for all v  3 Q := empty stack  4 s := starting node  5 Q.push(s)  6 visited[s] := true  7 while Q is not empty do  8 v := Q.pop()  9 for each adjacent node w of v do  10 if not visited[w] then  11 visited[w] := true  12 Q.push(w) \n\n<그림 12.4> 큐를 이용한 BFS \n\n깊이 우선 탐색은 스택을 이용하여 구현하고, 너비 우선은 FIFO 큐를 이용하여 구현한다. 깊이 우선은 스택을 이용하지 않고 재귀적으로 구현할 수 있다. 이들 알고리즘은 이미 7장에서 설명하였으며, 그것의 의사코드도 제시 하였다. 그래프에 대한 이들 알고리즘의 의사코드는 그림 12.2, 그림 12.3, 그림 12.4과 같으며 7장과의 차이점은 그래프에서는 한 노드를 탐색 과정에서 여러 번 만날 수 있기 때문에 방문 여부를 나타내는 visited 배열의 사용이 필요하다. \n\n기본적으로 두 알고리즘은 큐와 스택을 사용하는 것을 제외하고 동일하기 때문에 두 알고리즘은 모두 최악의\n\n\n경우 시간 복잡도가 같으며, 인접 행렬을 사용할 경우에 시간 복잡도는 O(n²)이며, 인접 리스트를 사용할 경우에는 시간 복잡도가 O(n + m)이다. \n\n더 구체적으로 시간 복잡도를 분석해 보자. 스택이나 큐를 이용한 깊이 우선과 너비 우선을 분석하면 다음과 같다. \n\n• while 반복문 이전에는 큐 생성 비용, visited 배열 초기화 등이 필요하며. 이 비용은 O(n)이다. \n\n• 각 노드마다 한번 push되고 pop되므로 전체 큐 연산은 총 2n번 발생한다. 따라서 이 비용도 O(n)이다. \n\n• 반복문 반복 횟수는 인접 행렬은 n²이고 인접 리스트는 m이다. 인접 행렬의 경우에는 바깥 while 문이 n번 반복되며, 내부 for 문도 항상 n번 반복되므로 n²이다. 반면에 인접 리스트는 내부 for 문이 현재 노드에 따라 반복하는 횟수가 달라진다. 하지만 while 문이 반복되는 동안 for 문의 전체 반복 횟수는 간선 수에 비례한다. 무방향 그래프는 각 간선을 두 번 검사하게 되며, 방향 그래프는 한 번 검사하게 된다. \n\n종합적으로 인접 행렬은 O(n²)이며, 인접 리스트는 O(m + n)이다. 이때 다중 그래프가 아니면 m은 n²보다 클 수 없으므로 O(m + n) = O(n²)이다. 하지만 다중 변수 빅O에서는 두 변수를 모두 이용하여 표현하는 것이 더 많은 정보를 주기 때문에 O(m + n)으로 나타내는 것이 더 적합하다. \n\n재귀적 깊이 우선의 경우에도 분석하면 차이는 없다. 각 노드에 대해 한 번의 재귀 호출만 이루어지며, 전체 재귀 호출 과정에서 for문의 반복은 인접 행렬이면 n²이 되고, 인접 리스트이면 m이 된다. 이 반복을 제외한 재귀 함수에서 나머지 비용은 상수 비용이므로 전체 비용은 인접 행렬이면 O(n²), 인접 리스트이면 O(m + n)이다. 비 재귀적인 것과 비교하면 직접적으로 스택을 사용하지 않기 때문에 스택 초기화 비용, 스택 연산 비용은 소요되지 않지만 거꾸로 비재귀적인 것은 재귀 호출 비용이 소요되지 않는다. \n\n이들 알고리즘의 공간 복잡도를 분석하여 보자. 비재귀적 구현의 경우 그래프 표현, 스택 또는 큐 공간, visited 배열 공간이 필요하다. 그래프 표현은 인접 행렬이면 O(n²), 인접 리스트이면 O(m) 공간을 사용한다. 스택 또는 큐 공간, 배열 공간은 모두 O(n)이므로 전체 공간 복잡도는 인접 행렬이면 O(n²)이고, 인접 리스트이면 O(m + n)이다. \n\n재귀적 구현의 경우에는 그래프 표현, visited 배열 공간, 함수 스택 공간이 필요하다. 함수 스택은 고정된 크기를 사용하며, 최대 재귀 호출 깊이는 n에 비례하므로 함수 스택에 의한 공간 복잡도는 O(n)이다. 따라서 재귀적 구현의 DFS의 공간 복잡도도 기존 스택을 이용한 것과 차이가 없다. \n\n하지만 그래프 형태에 따라 공간 복잡도 측면에서 미묘한 차이가 있을 수 있다. 비재귀적 두 탐색 방법에서 특정 노드를 방문하였을 때 이웃 노드들을 큐나 스택에 push해야 하는데, 완전 그래프처럼 한 노드의 인접 노드가 많으면 큐나 스택에 저장하는 노드의 수가 매우 많아질 수 있다. 반면에 깊이 우선 탐색을 재귀적으로 구현하면 이전 노드 하나만 기억하면 되기 때문에 한 노드의 이웃 노드가 많은 것은 공간 복잡도에 영향을 주지 않는다. 그러나 재귀적 구현의 경우에는 연결 그래프이면 재귀 호출의 깊이가 깊어지기 때문에 재귀 호출에 의한 스택 공간이 공간 복잡도에 영향을 주게 된다. \n\n무방향 그래프의 경우에는 깊이 우선이나 너비 우선을 이용하여 탐색하여 그래프의 연결 여부를 확인할 수 있다. 탐색 알고리즘을 통해 방문한 노드 수가 전체 그래프의 노드 수와 같으면 연결 그래프이다. 무방향 연결 그래프의 모든 노드의 차수가 짝수이면 여기서 하나의 간선을 제거하여도 여전히 연결 그래프가 된다.",
    "source": "ds12_5_깊이 우선, 너비 우선 탐색",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "깊이 우선, 너비 우선 탐색",
      "section_number": "5",
      "section_heading": "## 5. 깊이 우선, 너비 우선 탐색",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0161"
  },
  {
    "type": "텍스트북",
    "text": "## 6. 최단 경로 알고리즘 \n\n비가중치 그래프는 DFS, BFS를 이용하여도 최단 경로를 찾을 수 있다. 보통 BFS를 이용하여 최단 경로를 찾으며, BFS를 이용한 최단 경로 알고리즘을 다른 말로 Moore 알고리즘이라 한다. 하지만 가중치가 존재하면 단순 그래프\n\n\n탐색 알고리즘으로 최단 경로를 찾을 수 없다. \n\n다익스트라(Dijkstra) 알고리즘은 가중치가 양의 정수만 존재할 경우 사용할 수 있는 알고리즘이다. 이 알고리즘 기본적으로 FIFO 큐 대신에 우선순위 큐를 사용하는 BFS을 변형한 알고리즘이다. 다익스트라의 경우 최단 경로를 찾다보면 이미 찾은 경로보다 더 짧은 경로를 찾을 수 있다. 이 경우 우선순위 큐에 이미 포함되어 있는 노드의 값을 갱신해야 한다. 하지만 11장에서 살펴본 바와 같이 우선순위 큐는 보통 찾기나 삭제 연산을 제공하지 않는다. 이 때문에 큐에 이미 포함된 노드의 우선순위를 갱신하지 않고 추가로 삽입하는 형태로 알고리즘을 구성하는 것이 보통이다. 이 버전의 다익스트라를 게으른 다익스트라 알고리즘이라 한다. 여전히 우선순위 큐를 사용하기 때문에 한 노드가 여러 번 큐에 삽입되더라도 그 중에 가장 짧은 경로의 것을 처리하게 되므로 알고리즘 정확성에는 영향이 없다. 하지만 우선순위 큐에 삽입되는 데이터의 수가 많아지기 때문에 성능에는 나쁜 영향을 준다. \n\n음수 가중치가 가능하고 음의 주기가 없으면 Bellman과 Ford 알고리즘을 이용하여 최단 경로를 찾을 수 있다. 이 알고리즘은 출발노드가 주어졌을 때 다른 모든 노드까지의 최단 경로를 찾아준다. 이 알고리즘은 경로의 간선 수가 1인 것부터 n-1인 것까지 모두 구하여 최단 경로를 찾는다. Floyd와 Warshall 알고리즘은 모든 노드에서 다른 모든 노드까지의 최단 경로를 찾아주며, 시간 복잡도는 Bellman과 Ford 알고리즘을 n번 수행한 것보다 우수하다. \n\n이 교재는 자료구조를 학습하는 것이 목적이므로 최단 경로 알고리즘과 다음 절에서 간단히 설명하는 최소 신장 트리 알고리즘은 간단히 소개만 한다.",
    "source": "ds12_6_최단 경로 알고리즘",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "최단 경로 알고리즘",
      "section_number": "6",
      "section_heading": "## 6. 최단 경로 알고리즘",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0162"
  },
  {
    "type": "텍스트북",
    "text": "## 7. 최소 신장 트리 알고리즘 \n\n비가중치 그래프의 경우에는 BFS나 DFS를 이용하여 신장 트리를 구할 수 있다. 하지만 가중치 그래프에서는 BFS 나 DFS가 최단 경로를 찾을 수 없듯이 이들을 이용하여 최소 신장 트리를 구할 수 없다. 가중치 그래프에서 최소 신장 트리는 Prim 알고리즘이나 Kruskal 알고리즘을 이용할 수 있다. Prim은 현재 노드 집합에서 이 노드 집합에 없는 노드로 연결되는 간선 중 최소 비용 간선을 추가하여 노드 집합을 확장하는 방식이다. Kruskal은 전체 간선 중 최소 비용 간선을 추가하였을 때 주기가 생기지 않으면 해당 간선을 추가하는 방식이다. Prim은 우선 순위 큐를 이용하여 구현하며, Kruskal은 Union-find라는 자료구조를 이용하여 구현한다. Prim은 Dijkstra 최단 경로 알고리즘으로 거의 동일하다.",
    "source": "ds12_7_최소 신장 트리 알고리즘",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "최소 신장 트리 알고리즘",
      "section_number": "7",
      "section_heading": "## 7. 최소 신장 트리 알고리즘",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0163"
  },
  {
    "type": "텍스트북",
    "text": "## 8. 마무리 \n\n지금까지 12장에 걸쳐 다양한 자료구조를 살펴보았다. 응용을 개발할 때 필요한 대부분의 자료구조는 살펴보았지만 Kruskal 최소 신장 트리 알고리즘에서 사용하는 union-find 자료구조처럼 자세히 다루지 않은 자료구조도 있다. 하지만 이 교재에 있는 내용들을 이해하였다면 여기서 자세히 다루지 않은 자료구조도 스스로 충분히 학습하여 사용할 수 있을 것이다. \n\n자료구조를 학습하는 가장 큰 목적은 응용 개발할 때 응용의 특성과 목적에 맞는 자료구조를 선택할 수 있는 능력을 배양하는 것이다. 이를 위해서는 각종 자료구조의 특성을 정확하게 이해하고 있어야 한다. \n\n이 교재에서는 각종 자료구조를 실제 구현하는 방법을 설명하였다. 하지만 응용을 개발할 때 실제 자료구조를 직접 구현할 일은 별로 없다. 대부분 라이브러리로 제공하는 자료구조를 잘 선택하여 사용하면 된다. 하지만 이때에 도 각 라이브러리에서 제공하는 자료구조를 내부적으로 어떻게 구현하고 있는지 이해하여야 하며, 해당 자료구조를 사용할 때 효과적으로 사용하는 방법을 이해하고 해당 방법에 맞게 사용할 수 있어야 한다. \n\n모든 자료구조를 라이브러리에서 가져다 사용할 수 있는 것은 아니다. 트리나 그래프의 경우에는 보통 직접 표현하고 관련 알고리즘을 직접 구현해야 한다. 특히, 트리나 그래프에서 많이 사용하는 깊이 우선이나 너비 우선\n\n\n탐색 알고리즘은 정렬 알고리즘과 달리 라이브러리에 포함되어 제공되지 않는다.",
    "source": "ds12_8_마무리",
    "meta_data": {
      "tables": [],
      "book_title": "자료구조및실습",
      "chapter": "제12장 그래프",
      "section": "마무리",
      "section_number": "8",
      "section_heading": "## 8. 마무리",
      "parent_section": null,
      "parent_section_number": null,
      "images": [],
      "script": ""
    },
    "id": "자료구조_교재_0164"
  }
]